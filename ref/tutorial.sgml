<!DOCTYPE BOOK PUBLIC "UNREGISTERED::Eric Kidd//DTD DylanDoc V3.0//EN" [
 <!ENTITY % entities SYSTEM "entities.sgml">
 %entities;
]>

<Book id="tutorial">
  <Title>Getting Started with &dylan;</Title>
  <TitleAbbrev>Dylan Tutorial</TitleAbbrev>

  <BookInfo>
    <BookBiblio id="about">
      <Title>Getting Started with &dylan;</Title>
      <TitleAbbrev>Dylan Tutorial</TitleAbbrev>
      <AuthorGroup>
	<Author>&person.emk;</Author>
      </AuthorGroup>

      <Abstract id="abstract">
	<Title>Abstract</Title>
	
	<Para><CiteTitle/Getting Started with Dylan/ introduces <ulink
	url="http://www.apple.com/">Apple Computer</>'s &dylan programming
	language. Dylan is a object-oriented dynamic language designed for
	efficient compilation. It uses an algebraic infix syntax similar to
	Pascal or C, but supports an object model not unlike the Common
	Lisp Object System (<Acronym/CLOS/).</>

	<Para>This tutorial is written primarily for those with solid
	programming experience in &cpp; or another object-oriented static
	language. It provides a gentler introduction to Dylan than does the
	&drm;, although it refers to the latter book frequently.</>
      </Abstract>
    </BookBiblio>
  </BookInfo>


  <!-- ==================== Chapter 1 ==================== -->

  <Chapter id="why-dylan">
    <Title>Why &dylan;?</Title>

    <Para>What earthly reason could there be for learning yet
    <Emphasis/another/ computer language? And why should that language be
    Dylan?</>

    <Para>Dylan has an interesting combination of features. It is a dynamic
    language, but is designed to perform nearly as well as a static
    language. It is a <Link linkend="functional">functional</>
    language&mdash;like Scheme or TCL&mdash;but uses an algebraic infix
    syntax similar to C's. Dylan is object-oriented from the ground up,
    supports multiple inheritence and exceptions, implements <Link
    linkend="multiple-dispatch">multiple dispatch</>, and <Link
    linkend="gc">collects garbage</>.</>
    
    <Sect1 id="dynamic-vs-static">
      <Title>Dynamic vs. Static Languages</Title>

      <Para><GlossTerm/Static/ languages need to know the type of every
      variable at compile time. Examples of static languages include C,
      Pascal and Eiffel. Code written in static languages typically
      compiles efficiently, and strong type-checking reduces the risk of
      errors.</>

      <Para><GlossTerm/Dynamic/ languages allow the programmer to create
      variables without explicitly specifying the type of information they
      contain. This simplifies prototyping and cleans up certain kinds of
      object oriented code. Typical dynamic languages include LISP, Perl
      and SmallTalk.</>

      <Para>Dylan provides a good balance between the advantages of static
      and dynamic languages. The programmer may choose to specify or omit
      type declarations as desired. Code using explicit variable types can
      be compiled very efficiently, and type mismatch errors can be caught
      at compile time. Code omitting those type declarations gains the
      flexibility of a dynamic language.</>
    </Sect1>

    <Sect1 id="functional">
      <Title>Functional Languages</Title>

      <Para><GlossTerm/Functional/ languages, such as LISP, Scheme and to a
      large extent TCL, view an entire program as one large function to be
      evaluated. Expressions, statements and even control structures all
      return values, which may in turn be used as arguments elsewhere.</>

      <Para>Dylan is a functional language, permitting programmers to write
      functions like the following:</>

<ProgramListing>
define method shoe-size(person :: &lt;string&gt;)
  if (person = "Larry")
    14;
  else
    11;
  end if;
end method;
</ProgramListing>
      
      <Para>The function <Function/shoe-size/ has one argument, a string,
      and an untyped return value. (If this function didn't link against
      external code, the compiler could easily infer the return type.) If
      <Literal/person/ equals <Literal/"Joe"/, then the <Literal/if/
      statement evaluates to 14, otherwise it returns 11. Since no other
      statements follow the <Literal/if/, its return value is used as the
      return value of the entire function.</>

      <Para>The same function could also have been written as follows, in a
      more <GlossTerm/imperative/ idiom:</>

<ProgramListing>
define method shoe-size(person :: &lt;string&gt;)
  let the-size = 11;
    if (person = "Joe")
      the-size := 14;
    end if;
  the-size;
end method;
</ProgramListing>

    </Sect1>

    <Sect1 id="algebraic">
      <TITLE>Algebraic Infix Syntax</TITLE>
	
      <Para>Languages based on LISP typically use a notation called
      <GlossTerm/fully-parethesized prefix syntax/. This consists of
      innumerable nested paretheses, as seen in the following Scheme
      version of the <Function/shoe-size/ function:</>

<ProgramListing>
(define (shoe-size person)
  (if (equal? person "Joe")
      14
      11))
</ProgramListing>

      <Para>This has a certain elegance, but takes some time to learn to
      read. Dylan, as shown in <Link linkend="functional">the previous
      section</>, uses a syntax similar to those of C and Pascal.</>
    </Sect1>

    <Sect1 id="object-oriented">
	<TITLE>Object Orientation</TITLE>
	
      <Para>Unlike many other object-oriented languages, Dylan uses objects
      for every data value. Integers and strings are objects, as are
      functions and classes themselves.</>

      <Para>Dylan's design makes this reasonably efficient. Compile-time
      analysis and explicit <Link linkend="type-declarations"/type
      declarations/ allow the compiler to optimize away most of the
      overhead. Other language features permit the programmer to mark
      certain classes as <GlossTerm/sealed/, that is, inelligible for
      further subclassing.</>

      <Para>Dylan's object model, detailed in the following sections of
      this tutorial, differs from that of &cpp; in several important
      respects. Multiple inheritance may be used freely, without concern
      for <GlossTerm/object slicing/, erroneous down-casting or a whole
      host of other gotchas familiar to &cpp; programmers. Methods are
      separate from class declarations, allowing a programmer to write new
      polymorphic functions without editing the relevant base
      class. Methods may also dispatch ploymorphically on more than one
      parameter, a powerful technique known as <GlossTerm/multiple
      dispatch/. All of these features will be explained in greater detail
      later on.</>
    </Sect1>

    <Sect1 id="gc">
      <Title>Garbage Collection</Title>
	
      <Para>Languages with <GlossTerm/garbage collection/ have no need of a
      <Function/free/ or <Function/delete/ operator, because unused heap
      memory gets reclaimed automatically by the language runtime. This
      reduces the complexity of source code, eliminates the need of keeping
      reference counts for shared objects, and prevents most memory
      allocation bugs and all memory leaks.</>

      <Para>Over the years, garbage collection has gained a reputation for
      inefficiency. A large, object-oriented LISP program performed
      terribly compared to hand coded, micro-optimized assembly, and a good
      portion of the blame was placed on garbage collection.</>

      <Para>Times have changed, however. Garbage collection technology has
      improved. Processors speed has increased enormously. Most
      importantly, however, the standard practice of the industry has
      changed, and large commerical software is now built in &cpp;.</>

      <Para>No good benchmarks exist for the relative performance of large
      &cpp; systems (greater than 15 thousand lines of code or so), and
      similar systems <Emphasis/designed from the ground/ up to use garbage
      collection. The benchmarks which do exist typically test the
      performance of relatively small pieces of code&mdash;small enough
      that one programmer can optimize the overall usage of memory&mdash;or
      have compared a good system without garbage collection to a direct
      reimplementation of that system using a garbage collector. Overall,
      no one seems to know just how fast GC is, relative to a typical large
      &cpp; program. It <Emphasis/is/ known, however, that good GC code
      uses different designs than non-GC code, and often spends less time
      needlessly copying data.</>
    </Sect1>

    <Sect1 id="why-not">
      <Title>Why Not Dylan?</Title>
	
      <Para>Dylan's greatest weakness is the lack of commercial-quality
      compilers, especially on the Macintosh. Apple has refused to comment
      on the future of their technology release, and <ulink
      url="http://www.harlequin.com/full/dylan.html">Harlequin</> is
      targeting the Windows market with their compiler. The &gwydprj;'s
      Dylan implementation will support multiple UNIXs when complete.</>

      <Para>Even when good Dylan environments become available, experience
      suggests that Dylan applications will use more RAM than programs
      written in traditional languages.</>
    </Sect1>
</Chapter>


  <!-- ==================== Chapter 2 ==================== -->

  <Chapter id="expressions-variables">
    <Title>Expressions &amp; Variables</Title>

    <Para>Dylan identifiers may contain a greater variety of characters
    than those of C or Pascal. Specifically, variable names may contain all
    alphanumeric characters, plus the symbols <Literal>! & * &lt; = &gt; |
    ^ $ % @ _ - + ~ ? /</>. Identifiers may not begin with the symbols
    <Literal>- + ~ ? /</>, although identifiers may begin with numbers,
    provided they contain at least two alphabetic characters in a row. As
    in Pascal, variable names are not case sensitive. <Comment/Need &drm
    footnote here./</>

    <Para>This means that <Literal/(a - b)/ subtracts one variable from
    another, whereas <Literal/(a-b)/ simply returns the value of the
    hyphenated variable named <Literal/a-b/. Because of this, infix
    operators, such as addition, subtraction and equality, must be
    surrounded by whitespace.</>

    <Para>As in &cpp;, Dylan infix operators may also be refered to as
    functions. In &cpp;, <Literal/(a + b)/ could also be written as
    <Literal/operator+(a, b)/. In Dylan, the same expression could be
    written <Literal/\+(a, b)/. In both languages, programmers can use this
    flexibility to define operators for custom numeric classes.</>

    <Sect1 id="naming-conventions">
      <Title>Naming Conventions</Title>

      <Para>Dylan uses the extra characters permitted in variable names to
      support a number of standard naming conventions, as shown in <xref
      linkend="table.naming-conventions">.</>

      <Table id="table.naming-conventions">
	<Title>Naming Conventions</Title>
	<TGroup cols=2>
	  <TBody>
	    <Row>
	      <Entry><Literal/&lt;string&gt;/</>
	      <Entry>a class</>
	    </>
	    <Row>
	      <Entry><Literal/insert!/</>
	      <Entry>mutative function (modifies arguments destructively)</>
	    </>
	    <Row>
	      <Entry><Literal/empty?/</>
	      <Entry>predicate function (tests one or more arguments and
	      returns either true or false)</>
	    </>
	    <Row>
	      <Entry><Literal/write-line/</>
	      <Entry>two word name</>
	    </>
	    <Row>
	      <Entry><Literal/$name/</>
	      <Entry>constant</>
	    </>
	    <Row>
	      <Entry><Literal/*name*/</>
	      <Entry>module-level variable</>
	    </>
	  </TBody>
	</TGroup>
      </Table>
    </Sect1>

    <Sect1 id="true-and-false">
      <Title>True and False</Title>

      <Para>Dylan represents true as <Literal/#t/ and false as
      <Literal/#f/. When evaluated in a Boolean context, all values other
      than <Literal/#f/ return true. Thus, the number zero&mdash;and other
      common <Quote/false/ values&mdash;evaluate as true in Dylan.</>
    </Sect1>

    <Sect1 id="nature-of-variables"
      <Title>The Nature of Variables</Title>
	
      <Para>Dylan variables differ from those found in C and
      Pascal. Instead of <Emphasis/holding/ their values, Dylan variables
      <Emphasis/refer/ to them. Conceptually, they resemble a cross between
      pointers and &cpp; references. Like references, Dylan variables may
      be evaluated without any indirection. Like pointers, they may be set
      to point to new objects whenever the programmer desires.</>

      <Para>Furthermore, there's only one of any given numeric value in a
      Dylan program, at least from the programmer's point of view. All
      variables which refer to the integer 2&mdash;or, in Dylan-speak, are
      <GlossTerm/bound/ to the integer 2&mdash;point to the exact same
      thing.</>

<ProgramListing>
let x = 2; // creates x and binds it to 2
x := 3;    // rebinds x to the value 3
let y = x; // creates y, and binds it to
           //   whatever x is bound to
</ProgramListing>

      <Para>If two variables are bound to one object with internal
      structure, the results may suprise C and Pascal programmers.</>

<ProgramListing>
let car1 = make(&lt;car&gt;); // bind car1 to a
                        // new car object
car1.odometer := 10000; // set odometer
let car2 = car1;        // bind new name
car2.odometer := 0;     // reset odometer
car1.odometer;          // evaluates to 0!
</ProgramListing>

      <Para>As long as one or more variables refer to an object, it
      continues to exist. However, as soon as the last reference either
      goes out of scope or gets rebound, the object becomes
      <GlossTerm/garbage/. Since there's no way that the program could ever
      refer to the object again, the <GlossTerm/garbage collector/ feels
      free to reuse the memory which once held it.</>

      <Para>Note that Dylan variables <Emphasis/must/ be bound to a
      particular value when they are declared. In the name of type safety
      and implementation efficiency, every variable must refer to some
      well-defined object.</>
    </Sect1>

    <Sect1 id="equals">
      <Title>Assignment, Equality and Identity</Title>
	
      <Para>Dylan uses all three of the <Quote/equals/ operators found in C
      and Pascal, albeit in a different fashion. The Pascal assignment
      operator, <Literal/:=/, rebinds Dylan variable names to new
      values. The Pascal equality operator, <Literal/=/, tests for equality
      in Dylan and also appears in some language constructs such as
      <Literal/let/. (Two Dylan objects are equal, generally, if they
      belong to the same class and have equal substructure.)</>

      <Para>The C equality operator, <Literal/==/, acts as the
      <GlossTerm/identity/ operator in Dylan. Two variables are
      <GlossTerm/identical/ if and only if they are bound to the exact same
      object. For example, the following three expressions mean roughly the
      same thing:</>

<ProgramListing>
(a == b)   // in Dylan
(&amp;a == &amp;b) // in C or C++
(@a = @b)  // in Pascal
</ProgramListing>

      <Para>The following piece of source code demonstrates all three
      operators in actual use.</>

<ProgramListing>
let car1 = make(&lt;car&gt;);
let car2 = make(&lt;car&gt;);
let car3 = car2;

car2 = car3;	// #t
car1 = car2;	// ??? (see below)
car2 == car3;	// #t
car1 == car2;	// #f

car2 := car1;	// rebind
car1 == car2;	// #t

let x = 2;
let y = 2;

x = y;			// #t
x == y;			// #t (only one 2!)
</ProgramListing>

      <Para>Two of the examples merit further explanation. First, we don't
      know whether <Literal/car1 = car2/, because we don't know if make
      creates each car with the same serial number, driver and other
      information as previous cars. If and only if none of those values
      differ, then <Literal/car1/ equals <Literal/car2/. Second, <Literal/x
      == y/ because every variable bound to a given number refers to the
      exact same instance of that number, at least from the programmer's
      perspective. (The compiler will normally do something more useful and
      efficient when generating the actual machine code.) Strings behave in
      a fashion different from numbers&mdash;instances of strings are
      stored separately, and two equal strings are not necessarily the same
      string.</>
    </Sect1>

    <Sect1 id="parallel-values">
      <Title>Parallel Values</Title>
	
      <Para>It's possible to bind more than one variable at a time in
      Dylan. For example, a single <Literal/let/ statement could bind
      <Literal/x/ to 2, <Literal/y/ to 3 and <Literal/z/ to 4.</>

<ProgramListing>
let (x, y, z) = values (2, 3, 4);
</>

      <Para>In Perl, the equivalent statement would assign a vector of
      values to a vector of variables. In Dylan, no actual vectors or lists
      are used. All three values are assigned directly, using some
      implementation-dependant mechanism.</>
    </Sect1>

    <Sect1 id="type-declarations">
      <Title>Type Declarations</Title>
	
      <Para>Dylan variables may have explicit types. This allows the
      compiler to generate better code and to catch type-mismatch errors at
      compile time. To take advantage of this feature, use the <Literal/::/
      operator:</>

<ProgramListing>
let x :: &lt;integer&gt; = 2;
let vehicle :: &lt;vehicle&gt; = make(&lt;car&gt;);
let y :: &lt;number&gt; = 3; // any numeric class
let z :: &lt;integer&gt; = vehicle; // error!
</>

      <Para>As seen in the example, a variable may be bound to values of
      its declared type or to values of subclasses of its declared
      type. Type mismatch errors should be caught at compile time. In
      general, the compiler may infer the types of variables at when
      generating machine code. If a local variable never gets rebound to
      anything other than an integer, for example, the compiler can rely on
      this fact to optimize the resulting code.</>
    </Sect1>

    <Sect1 id="module-variables">
      <Title>Module Variables and Constants</Title>
	
      <Para>Dylan supports <GlossTerm/module-level/ variables, which serve
      roughly the same purpose as C's global variables. Although the
      <Literal/let/ function may only be used within <GlossTerm/methods/
      (Dylan-speak for regular functions), the forms <Literal/define
      variable/ and <Literal/define constant/ may be used at the top
      level.</>

<ProgramListing>
define variable *x* :: &lt;integer&gt; = 3;
define variable *y* = 4;
define constant $hi = "Hi!";
</>

      <Para>Note that there's not much point in declaring types for
      constants. Any remotely decent compiler will be able to figure that
      information out on its own.</>
    </Sect1>
  </Chapter>


  <!-- ==================== Chapter 3 ==================== -->

  <Chapter id="methods-generic-functions">
    <Title>Methods &amp; Generic Functions</Title>

    <Para>Dylan <GlossTerm/methods/ correspond roughly to the functions
    found in C and Pascal. They take zero or more named parameters, but
    also return zero or more named return values. A minimal Dylan method
    might look like the following:</>

<ProgramListing>
define method hello-world()
  puts("Hello, world!");
end;
</>

    <Para>This method has no parameters and an unspecified return value. It
    could return any number of values of any type. In order to make the
    above code more clear, the function could be rewritten as follows:</>

<ProgramListing>
define method hello-world() =&gt; ();
  puts("Hello, world!");
end method;
</>

    <Para>There have been two changes. The function now officially returns
    no value whatsoever. Also note that <Literal/end/ has been replaced by
    <Literal/end method/ which could in turn be rewritten as <Literal/end
    method hello-world/. In general, Dylan permits all the obvious
    combinations of keywords and labels to follow an end statement.</>

    <Sect1 id="parameters">
      <Title>Parameters &amp; Parameter Lists</>

      <Para>Dylan methods declare parameters in fashion similar to that of
      conventional languages, except for the fact that parameters may
      optionally be untyped. Both of the following methods are legal:</>

<ProgramListing>
define method foo(x :: &lt;integer&gt;, y) end;
define method bar(m, s :: &lt;string&gt;) end;
</>

      <Para>Both <Function/foo/ and <Function/bar/ have one typed and one
      untyped parameter, but neither has a well-defined return value (or
      actually does anything). As in C, each typed parameter must have its
      own type declaration; there's no syntax for saying <Quote/the last
      three parameters were all integers/.</>

      <Para>Functions with variable numbers of parameters include the
      <Literal/#rest/ keyword at the end of their parameter lists. Thus,
      the declaration for C's <Function/printf/ function would appear
      something like the following in Dylan:</>

<ProgramListing>
define method printf(format-string :: &lt;string&gt;, #rest arguments) =&gt; ();
  // Print the format string, extracting
  // one at a time from &quot;arguments&quot;. Note
  // that Dylan actually allows us to
  // verify the types of variables,
  // preventing those nasty printf errors,
  // such as using %d instead of %ld.
  // ...
end method printf;
</>

      <Para>For an actual implementation of a lightweight <Function/printf/
      function, see Appendix A. <!-- <Link linkend="printf-code"/Appendix
      A/. --></>

      <Para>Note that Dylan makes no provision for passing variables by
      reference in the Pascal sense, or for passing pointers to
      variables. Parameter names are simply bound to whatever values are
      passed, and may be rebound like regular variables. This means that
      there's no way to write a <Function/swap/ function in Dylan (except
      by using macros). However, the following function works just fine,
      because it modifies the <GlossTerm/internal state/ of another
      object:</>

<ProgramListing>
define method sell(car :: &lt;car&gt;, new-owner :: &lt;string&gt;) =&gt; ();
  if (credit-check(new-owner))
    car.owner = new-owner;
  else
    error(&quot;Bad credit!&quot;);
  end;
end;
</>

      <Para>If this sounds unclear, reread the chapter on <Link
      linkend="expressions-variables"/variables and expressions/.</>
    </Sect1>

    <Sect1 id="return-values">
      <Title/Return Values/
      
      <Para>Because Dylan methods can't have normal <Quote/output/
      parameters in their parameter lists, they're allowed considerably
      more flexibility when it comes to return values. Methods may return
      more than one value. As with parameters, these values may be typed or
      untyped. Interestingly enough, all return values <Emphasis/must/ be
      named.</>

      <Para>A Dylan method&mdash;or any other control
      construct&mdash;returns the value of the last expression in its
      body.</>

<ProgramListing>
define method foo() =&gt; sample :: &lt;string&gt;;
  &quot;Sample string.&quot;;		// return string
end;

define method bar() =&gt; my-untyped-value;
  if (weekend-day?(today()))
    &quot;Let's party!&quot;;	// return string
  else
    make(&lt;excuse&gt;);	// return object
  end if;
end method;

define method moby( )
  =&gt;	sample :: &lt;string&gt;, my-untyped-value;
  values( foo(), bar() ); // return both!
end;

define method baz( ) =&gt; ( );
  let (x,y) = moby( );		// assign both
end;
</>

    </Sect1>

    <Sect1 id="bare-methods">
      <Title/Bare Methods/

      <Para>Nameless methods may be declared inline. Such <GlossTerm/bare
      methods/ are typically used as parameters to other methods. For
      example, the following code fragment squares each element of a list
      using the built in <Function/map/ function and a bare method:</>

<ProgramListing>
define method square-list(in :: &lt;list&gt;)
	=&gt; out :: &lt;list&gt;
	map(method(x) x * x end, in);
end;
</>

      <Para>The <Function/map/ function takes each element of the list
      <Literal/in/ and applies the anonymous method. It then builds a new
      list using the resulting values and returns it. The method
      <Function/square-list/ might be invoked as follows:<Comment>Must
      distinguish return values from code.</></>

<ProgramListing>
square-list( #(1,2,3,4) );
=&gt; #(1,4,9,16)
</>

    </Sect1>


    <Sect1 id="local-methods">
      <Title/Local Methods/

      <Para>Local methods resemble bare methods but have names. They are
      declared within other methods, often as private utility
      routines. Local methods are typically used in a fashion similar to
      Pascal's local functions.</>

<ProgramListing>
define method sum-squares(in :: &lt;list&gt;) =&gt; sum-of-element-squares :: &lt;integer&gt;;
	local	method square( x )
				x * x;
			end,
			method sum(list :: &lt;list&gt;)
				reduce1(\+, list);
			end;
	sum(map(square, in));
end;
</>

      <Para>Local methods can actually outlive the invocation of the
      function which created them. Parameters of the parent function remain
      bound in a local method, allowing some interesting techniques:</>

<ProgramListing>
define method build-put(string :: &lt;string&gt;) =&gt; &lt;function&gt;;
	local	method string-putter()
				puts(string);
			end;
	string-putter; // return local method
end;

define method print-hello() =&gt; ();
	let f = build-put(&quot;Hello!&quot;);
	f();				// print &quot;Hello1&quot;
end;
</>

      <Para>Local functions which contain bound variables in the above
      fashion are known as <GlossTerm/closures/.</>
    </Sect1>
    

    <Sect1 id="generic-functions">
      <Title/Generic Functions/
	
      <Para>A <GlossTerm/generic function/ represents zero or more similar
      methods. Every method created by means of <Literal/define method/ is
      automatically <GlossTerm/contained/ within the generic function of
      the same name. For example, a programmer could define three methods
      named <Function/display/, each of which acted on a different data
      type:</>

<ProgramListing>
define method display(i :: &lt;integer&gt;)
	do-display-integer(i);
end;

define method display(s :: &lt;string&gt;)
	do-display-string(s);
end;

define method display(f :: &lt;float&gt;)
	do-display-float(f);
end;
</>

      <Para>When a program calls <Function/display/, Dylan examines all
      three methods. Depending on the number and type of arguments to
      <Function/display/, Dylan invokes one of the above methods. If no
      methods match the actual parameters, an error occurs.</>

      <Para>In &cpp;, this process occurs only at compile time. (It's
      called operator overloading.) In Dylan, calls to <Function/display/
      may be resolved either at compile time or while the program is
      actually executing. This makes it possible to define methods like:</>

<ProgramListing>
define method display(c :: &lt;collection&gt;)
  for (item in c)
    display(item); // runtime dispatch
  end;
end;
</>

      <Para>This method extracts objects of unknown type from a collection,
      and attempts to invoke the generic function <Function/display/ on
      each of them. Since there's no way for the compiler to know what type
      of objects the collection actually contains, it must generate code to
      identify and invoke the proper method at runtime. If no applicable
      method can be found, the Dylan runtime environment throws an
      exception.</>

      <Para>Generic functions may also be declared explicity, allowing the
      programmer to exercise control over what sort of methods get
      added. For example, the following declaration limits all
      <Function/display/ methods to single parameter and no return
      value:</>

<ProgramListing>
define generic display(thing :: &lt;object&gt;) =&gt; ()
</>

      <Para>Generic functions are explained in greater detail in the
      chapter on <Link linkend="multiple-dispatch"/multiple dispatch/.</>
    </Sect1>

    <Sect1 id="keyword-arguments">
      <Title/Keyword Arguments/
	
      <Para>Functions may accept <GlossTerm/keyword arguments/, extra
      parameters which are identified by a label rather than by their
      postion in the argument list. Keyword arguments are often used in a
      fashion similar to <GlossTerm/default parameter values/ in &cpp;. For
      example, the following hypothetical method might print records to an
      output device:</>

<ProgramListing>
define method print-records(records :: &lt;collection&gt;,
	#key init-codes = &quot;&quot;, lines-per-page = 66) =&gt; ();

	send-init-codes(init-codes);
	// ...print the records
end method;
</>

      <Para>This method could be invoked in one of several ways. The first
      specifies no keyword arguments, and the latter two specify some
      combination of them. Note that order of keyword arguments doesn't
      matter.</>

<ProgramListing>
print-records(recs);
print-records(recs, lines-per-page: 65);
print-records(recs, lines-per-page: 120, init-codes: &quot;***42\n&quot;);
</>

      <Para>Programmers have quite a bit of flexibility in specifying
      keyword arguments. They may optionally omit the default value for a
      keyword (in which case <Literal/#f/ is used). Default value
      specifiers may be actually be function calls themselves, and may rely
      on regular parameters already being in scope. Variable names may be
      different from keyword names, a handy tool for preventing name
      conflicts.</>

      <Para>For more information on keyword arguments, especially their use
      with <Link linkend="generic-functions"/generic functions/, see the
      &drm;.</>
    </Sect1>
  </Chapter>


  <!-- ==================== Chapter 4 ==================== -->

  <Chapter id="objects">
    <Title>Objects</Title>

    <Para>The feautres of Dylan's object system don't map directly onto the
    features found in &cpp;. Dylan handles access control using
    <GlossTerm/modules/, not <Literal/private/ declarations within
    individual objects. Standard Dylan has no destructors, but instead
    relies upon the garbage collector to recover memory and on exception
    handling blocks to recover other resources. Dylan objects don't even
    have real member functions.</>

    <Para>Despite these oddities, Dylan's object system is at least as
    powerful as that of &cpp;. Multiple inheritance works smoothly,
    constructors are rarely needed and there's no such thing as object
    slicing. Alternate constructs replace the missing &cpp; features. Quick
    and dirty classes can be turned into clean classes with little editing
    of existing code.</>

    <Para>Before starting, temporarily set aside any low-level expertise in
    &cpp; or Object Pascal. Dylan differs enough that such knowledge can
    actually interfere with the initial learning process.</>

    <Sect1 id="built-in-classes">
      <Title/Built-In Classes/
	
      <Para>Dylan has a large variety of built-in classes. Several of these
      represent primitive data types, such as <Literal/&lt;integer&gt;/ and
      <Literal/&lt;character&gt;/. A few represent actual language-level
      entities, such as <Literal/&lt;class&gt;/ and
      <Literal/&lt;function&gt;/. Most of the others implement collection
      classes, similar to those found in &cpp;'s Standard Template
      Library. A few of the most important classes are shown in <Xref
      linkend="figure.class-tree">.</>

      <Figure id="figure.class-tree">
	<Title/Several Standard Dylan Classes/
	<Graphic fileref="class-tree.pic" format="PIC"></>
      </Figure>

      <Para>The built-in collection classes include a number of common data
      structures. Arrays, tables, vectors, ranges and deques should be
      provided by all Dylan implementations. The language specification
      also standardizes strings and byte-strings, certainly a welcome
      convenience.</>

      <Para>Not all the built-in classes may be subclassed. This allows the
      compiler to heavily optimize code dealing with basic numeric types
      and certain common collections. The programmer may also mark classes
      as <GlossTerm/sealed/, restricting how and where they may be
      subclassed. See <Xref linkend="modules-libraries"> for details.</>
    </Sect1>

    <Sect1 id="slots">
      <Title/Slots/
	
      <Para>Objects have <GlossTerm/slots/, which resemble the data members
      found in most other object-oriented languages. Like variables, slots
      are bound to values; they don't actually contain their data. A simple
      Dylan class shows how slots are declared:</>

<ProgramListing>
define class &lt;vehicle&gt; (&lt;object&gt;)
	slot serial-number;
	slot owner;
end;
</>

      <Para>The above code would quick and convenient to write while
      building a prototype, but it could be improved. The slots have no
      types, and worse, they have no initial values. (That's no easy
      achievement in Dylan, to create an uninitialized variable!) The
      following snippet fixes both problems:</>

<ProgramListing>
define class &lt;vehicle&gt; (&lt;object&gt;)
	slot serial-number :: &lt;integer&gt;,
		required-init-keyword: sn:;
	slot owner :: &lt;string&gt;,
		init-keyword: owner:, // optional
		init-value: &quot;Northern Motors&quot;;
end class &lt;vehicle&gt;;
</>

      <Para>The type declarations work just like type declarations anywhere
      else in Dylan; they limit a binding to objects of a given class or of
      one of its subclasses, and they let the compiler optimize. The new
      keywords describe how the slots get their initial values. (The
      keyword <Literal/init-function/ may also be used; it must be followed
      by a function with no arguments and the appropriate return type.)</>

      <Para>To create a vehicle object using the new class declaration, a
      programmer could write one of the following:</>

<ProgramListing>
make(&lt;vehicle&gt;, sn: 1000000)
make(&lt;vehicle&gt;, sn: 2000000, owner: &quot;Sal&quot;)
</>

      <Para>In the first example, <Function/make/ returns a vehicle with
      the specified serial number and the default owner. In the second
      example, <Function/make/ sets both slots using the keyword
      arguments.</>

      <Para>Only one of <Literal/required-init-keyword/,
      <Literal/init-value/ and <Literal/init-function/ may be
      specified. However, <Literal/init-keyword/ may be paired with either
      of the latter two if desired. More than one slot may be initialized
      by a given keyword.</>

      <Para>Dylan also provides for the equivalent of &cpp;
      <Literal/static/ members, plus several other useful allocation
      schemes. See the &drm; for the full specifications.</>
    </Sect1>

    <Sect1 id="getters-setters">
      <Title/Getters and Setters/
	
      <Para>An object's slots are accessed using to functions: a getter and
      a setter. By default, the getter function has the same name as the
      slot, and the setter function appends
      <Quote><Literal/-setter/</>. These functions may be invoked as
      follows:</>

<ProgramListing>
owner(sample-vehicle);	// returns owner
owner-setter(sample-vehicle, &quot;Faisal&quot;);
</>

      <Para>Dylan also provides some convenient <Quote/syntactic sugar/ for
      these two functions. They may also be written as:</>

<ProgramListing>
sample-vehicle.owner;		// returns owner
sample-vehicle.owner := &quot;Faisal&quot;;
</>

    </Sect1>

    <Sect1 id="generic-functions-objects">
      <Title/Generic Functions and Objects/
	
      <Para>Generic functions, introduced in <Link
      linkend="methods-generic-functions"/Methods and Generic Functions/,
      provide the equivalent of &cpp; and Object Pascal member
      functions. In the simplest case, just declare a generic function
      which dispatches on the first parameter.</>

<ProgramListing>
define generic tax(v :: &lt;vehicle&gt;)
	=&gt; tax-in-dollars :: &lt;float&gt;;

define method tax(v :: &lt;vehicle&gt;)
	=&gt; tax-in-dollars :: &lt;float&gt;;
	100.00;
end;

//=== Two new subclasses of vehicle

define class &lt;car&gt; (&lt;vehicle&gt;)
end;

define class &lt;truck&gt; (&lt;vehicle&gt;)
	slot capacity,
		required-init-keyword: tons:;
end;

//=== Two new &quot;tax&quot; methods

define method tax( c :: &lt;car&gt; )
	=&gt; tax-in-dollars :: &lt;float&gt;;
	50.00;
end method;

define method tax( t :: &lt;truck&gt; )
	=&gt; tax-in-dollars :: &lt;float&gt;;
	// standard vehicle tax plus $10/ton
	next-method( ) + t.capacity * 10.00;
end method;
</>

      <Para>The function <Function/tax/ could be invoked as
      <Literal/tax(v)/ or <Literal/v.tax/, because it only has one
      argument. Generic functions with two or more arguments must be
      invoked in the usual Dylan fashion; no syntactic sugar exists to make
      them look like &cpp; member functions.</>

      <Para>The version of tax for <Literal/&lt;truck&gt;/ objects calls a
      special function named <Function/next-method/. This function invokes
      the next most specific method of a generic function; in this case,
      the method for <Literal/&lt;vehicle&gt;/ objects. Parameters to the
      current method get passed along automatically.</>

      <Para>Technically, <Function/next-method/ is a special parameter to a
      method, and may be passed explicitly using <Literal/#next/. &mindy;,
      a popular but incomplete bytecode compiler written as part of the
      &gwydprj;, currently requires the use of <Literal/#next/.</>

<ProgramListing>
define method tax(t :: &lt;truck&gt;, #next next-method)
	=&gt; tax-in-dollars :: &lt;float&gt;;
	// standard vehicle tax plus $10/ton
	next-method() + t.capacity * 10.00;
end method;
</>

      <Para>Dylan's separation of classes and generic functions provides
      some interesting design ideas. Classes no longer need to
      <Quote/contain/ their member functions; it's possible to write a new
      generic function without touching the class definition. For example,
      a module handling traffic simulations and one handling municipal
      taxes could each have many generic functions involving vehicles, but
      both could use the same vehicle class.</>

      <Para>Slots in Dylan may also be replaced by programmer-defined
      accessor functions, all without modifying existing clients of the
      class. The &drm; describes numerous ways to accomplish the change;
      several should be apparent from the preceding discussion. This
      flexibility frees programmers from creating functions like
      <Literal/GetOwnerName/ and <Literal/SetOwnerName/, not to mention the
      corresponding private member variables and constructor code.</>

      <Para>For even more creative uses of generic functions and the Dylan
      object model, see the chapter on <Link
      linkend="multiple-dispatch"/Multiple Dispatch/.</>
    </Sect1>


    <Sect1 id="initializers">
      <Title/Initializers/

      <Para>The <Function/make/ function handles much of the drudgery of
      object construction. It processes keywords and initializes
      slots. Programmers may, however, customize this process by adding
      methods to the generic function <Function/initialize/. For example,
      if vehicle serial numbers must be at least seven digits:</>

<ProgramListing>
define method initialize(v :: &lt;vehicle&gt;, #all-keys) // accepts all keywords
	next-method( );
	if (v.serial-number &lt; 1000000)
		error(&quot;Bad serial number!&quot;);
	end if;
end method;
</>

      <Para><Function/Initialize/ methods get called after regular slot
      initialization. They typically perform error checking or calculate
      values for unusual slots. Initialize methods must accept all keywords
      using <Literal/#all-keys/.</>

      <Para>It's possible to access the values of slot keywords from
      <Function/initialize/ methods, and even to specify additional
      keywords in the class declaration. See the &drm; for further
      details.</>
    </Sect1>

    <Sect1 id="abstract-classes">
      <Title/Abstract Classes and Overriding Make/
	
      <Para>Abstract classes define the interface, not the implementation,
      of an object. There are no direct instances of an abstract
      class. Concrete classes actually implement their interfaces. Every
      abstract class will typically have one or more concrete
      subclasses. For example, if plain vanilla vehicles shouldn't exist,
      <Literal/&lt;vehicle&gt;/ could be defined as follows:</>

<ProgramListing>
define abstract class &lt;vehicle&gt; (&lt;object&gt;)
	// ...as before
end;
</>

      <Para>The above modification prevents the creation of direct
      instances of <Literal/&lt;vehicle&gt;/. At the moment, calling
      <Function/make/ on this class would result in an error. However, a
      programmer could add a method to make which allowed the intelligent
      creation of vehicles based on some criteria, thus making
      <Literal/&lt;vehicle&gt;/ an <GlossTerm/instantiable abstract
      class/:</>

<ProgramListing>
define method make(class == &lt;vehicle&gt;,
	#rest keys, #key big? (#f), #all-keys)
	=&gt; &lt;vehicle&gt;;
	
	if ( big? )
		make( &lt;truck&gt;, keys, tons: 2 );
	else
		make( &lt;car&gt;, keys );
	end;
end;
</>

      <Para>A number of new features appear in the parameter list. The
      expression <Quote><Literal/class == &lt;vehicle&gt;/</> specifies a
      <GlossTerm/singleton/, one particular object of a class which gets
      treated as a special case. Singletons are discussed in the chapter on
      <Link linkend="multiple-dispatch"/Multiple Dispatch/. The use of
      <Literal/#rest/, <Literal/#key/ and <Literal/#all-keys/ in the same
      parameter list accepts any and all keywords, binds one of them to
      <Literal/big?/ and places all of them into the variable
      <Literal/keys/. The new make method could be invoked in any of the
      following fashions:</>

<ProgramListing>
let x = 1000000;
make(&lt;vehicle&gt;, sn: x, big?: #f); =&gt;car
make(&lt;vehicle&gt;, sn: x, big?: #t); =&gt;truck
make(&lt;vehicle&gt;, sn: x);           =&gt;car
</>

      <Para>Methods added to <Function/make/ don't actually need to create
      new objects. Dylan officially allows them to return existing
      objects. This can be used to manage lightweight shared objects, such
      as the <Quote/flyweights/ described by Gamma, et al., in <ulink
      url="http://st-www.cs.uiuc.edu/users/patterns/DPBook/DPBook.html">
      <CiteTitle/Design Patterns/</>.</>
    </Sect1>
  </Chapter>


  <!-- ==================== Chapter 5 ==================== -->
  
  <Chapter id="multiple-dispatch">
    <Title/Multiple Dispatch/

    <Para><GlossTerm/Multiple dispatch/ is one of the most powerful and
    elegant features of Dylan. As explained in the section on <Link
    linkend="generic-functions-objects"/generic functions and objects/,
    Dylan methods are declared separately from the classes upon which they
    act. <GlossTerm/Polymorphism/, the specialization of methods for use
    with particular classes, can be implemented by declaring several
    methods with different parameters and attaching them to one generic
    function:</>

<ProgramListing>
define generic inspect-vehicle(v :: &lt;vehicle&gt;, i :: &lt;inspector&gt;) =&gt; ();

define method inspect-vehicle(v :: &lt;vehicle&gt;, i :: &lt;inspector&gt;) =&gt; ();
	look-for-rust(car);
end;

define method inspect-vehicle(car :: &lt;car&gt;, i :: &lt;inspector&gt;) =&gt; ();
	next-method(); // perform vehicle inspection
	check-seat-belts(car);
end;

define method inspect-vehicle(truck :: &lt;truck&gt;, i :: &lt;inspector&gt;) =&gt; ();
	next-method(); // perform vehicle inspection
	check-cargo-attachments(truck);
end;
</>

    <Para>However, different types of vehicle inspectors may have different
    policies. A state inspector, in addition to the usual procedures, will
    also typically check a car's insurance policy. To implement this, add
    another method to the generic function
    <Function/inspect­vehicle/:</>

<ProgramListing>
define method inspect-vehicle(car :: &lt;car&gt;, i :: &lt;state-inspector&gt;) =&gt; ();
	next-method(); // perform car inspection
	check-insurance(car);
end;

let inspector = make(&lt;state-inspector&gt;);
let car = make(&lt;car&gt;);
inspect-vehicle(car, inspector);
</>

    <Para>Calling the generic function <Function/inspect-vehicle/ with
    these arguments performs three separate tasks:
    <Function/look-for-rust/, <Function/check-seat-belts/ and
    <Function/check-insurance/. The most specific method on
    <Function/inspect-vehicle/&mdash;the one for the classes
    <Literal/&lt;car&gt;/ and <Literal/&lt;state-inspector&gt;/&mdash;is
    invoked first and calls <Function/next-method/ to invoke the
    less-specific methods in turn.</>
    
    <Para>For an exact definition of <Quote/specific/, see the &drm;.</>


    <Sect1 id="singleton-dispatch">
      <Title/Dispatching on Specific Objects/
      
      <Para>Dylan also allows functions to dispatch on specific
      objects. For example, state inspectors might pass the governor's car
      without actually looking at it. Dylan expresses this situation using
      <GlossTerm/singletons/, objects which are treated as though they were
      in a class of their own. For example:</>

<ProgramListing>
define constant $governors-car = make(&lt;car&gt;);

define method inspect-vehicle(car == $governors-car,
	i :: &lt;state-inspector&gt;) =&gt; ();
	wave-through(car);
end;
</>

      <Para>(In this example, none of the usual inspection methods will be
      invoked since the above code neglects to call
      <Function/next-method/.)</>
    </Sect1>
  </Chapter>


  <!-- ==================== Chapter 6 ==================== -->

  <Chapter id="modules-libraries">
    <Title/Modules &amp; Libraries/

    <Para>Modules and libraries provide the structure of a Dylan
    program. Modules represent namespaces and control access to objects and
    functions. Libraries contain modules, and act as units of compilation
    in a finished Dylan program.</Para>

    <Sect1 id="simple-modules">
      <Title/Simple Modules/
	
      <Para>Modules import the symbols of other modules and export their
      own. The dependencies between modules must form a directed, acyclic
      graph. Two modules may not use each other, and no circular
      dependencies may exist.</>

      <Para>Modules only export variables. Since the names of classes and
      generic functions are actually stored in variables, this represents
      no hardship. A sample module containing the vehicle classes from
      earlier chapters might resemble:</>

<ProgramListing>
define module Vehicles
  use Dylan;
  export
    &lt;vehicle&gt;,
      serial-number,
      owner, owner-setter,
      tax,
    &lt;car&gt;,
    &lt;truck&gt;,
      capacity;
end module;
</>

      <Para>Like all normal modules, this one uses the <Literal/Dylan/
      module, which contains all of the standard built-in functions and
      classes. In turn, the <Literal/Vehicles/ module exports all three of
      the vehicle classes, the generic function <Literal/tax/, several
      getter functions and a single setter function.</>

      <Para>To control access to a slot, export some combination of its
      getter and setter functions. To make a slot public, export both. To
      make it read-only, export just the getter function. To make it
      private, export neither. In the above example, the slot
      <Literal/serial-number/ is read-only, while the slot <Literal/owner/
      is public.</>

      <Para>Note that when some module adds a method to a generic function,
      the change affects all modules using that function. The new method
      actually gets added <Emphasis/into/ the variable representing the
      generic function. Since the variable has been previously exported,
      all clients can access the new value.</>
    </Sect1>

    <Sect1 id="import-options">
      <Title/Import Options/

      <Para>Dylan allows very precise control over how symbols are imported
      from other modules. For example, individual symbols may be imported
      by name. They may be renamed, either one at a time, or by adding a
      prefix to all a module's symbols at once. Some or all of them may be
      re-exported immediately. See the &drm; for specific examples.</>

      <Para>Dylan's import system has a number of advantages. Name
      conflicts occur rarely. Programmers don't need to define or maintain
      function prototypes. There's no explicit need for header
      files. Modules may also provide different interfaces to the same
      objects&mdash;one module exports a complete interface, which another
      module imports, redefines and re-exports.</>
    </Sect1>

    <Sect1 id="libraries">
      <Title/Libraries/
	
      <Para>Libraries contain modules. For example, the <Literal/Dylan/
      library contains the <Literal/Dylan/ module described earlier, the
      <Literal/Extensions/ module, and possibly several other
      implementation-dependent modules. Note that a library and a module
      may share a given name. Modules with the same name may also appear in
      more than one library.</>

      <Para>By default, a Dylan environment provides a library called
      <Literal/Dylan-User/ for the convenience of the programmer. This is
      typically used for short, single library programs which depend only
      on modules found in the Dylan library.</>

      <Para>Additionally, every library contains an implicit module, also
      known as <Literal/Dylan-User/, which imports all of the modules found
      in the <Literal/Dylan/ library. This may be used for single module
      programs. Many Dylan environments, however, use it to bootstrap new
      library definitions. The vehicle library, for example, might be
      defined as follows in a <Literal/Dylan-User/ module:</>

<ProgramListing>
define library Vehicles
  use Dylan;            // This is the library!
  export                // These are modules.
    Vehicles,           // (Defined above.)
    Traffic-Simulation,
    Crash-Testing,
    Inspection;         // (Hypothetical.)
end library Vehicles;
</>

      <Para>This library could in turn be imported by another library:</>

<ProgramListing>
define library Vehicle-Application
  use Dylan;
  use My-GUI-Classes;
  use Vehicles;
end;
</>

      <Para>Libraries import other libraries and export modules, whereas
      modules import other modules and export variables. In general, a
      module may import any module found in its own library or exported
      from a library imported by its own library. The following module, for
      example, could belong to the <Literal/Vehicle-Application/
      library.</>

<ProgramListing>
define module Sample-Module
  // module name         source library
  use Dylan;          // Dylan
  use Extensions;     // Dylan
  use Menus;          // My-GUI-Classes
  use Vehicles;       // Vehicles
  use Inspection;     // Vehicles
end module;
</>

    </Sect1>


    <Sect1 id="sample-libraries">
      <Title/A Sample Set of Libraries/
      
      <Para><Xref linkend="figure.mindy-libraries"> and <Xref
      linkend="table.mindy-libraries-modules"> show the libraries included
      with &mindy;, a bytecode compiler produced as part of the
      &gwydprj;. Also shown are the dependencies between the libraries and
      the major modules contained within each. For more information on
      these libraries and their use, see the &mindy; documentation and
      source code.</>

      <Figure id="figure.mindy-libraries">
	<Title/Dependencies Among the Stanard Mindy Libraries/
	<Graphic fileref="mindy-libraries.pic" format="PIC"></>
      </Figure>

      <Table id="table.mindy-libraries-modules">
	<Title>Standard Mindy Libraries and Modules</Title>
	<TGroup cols=3>
	  <THead>
	    <Row role="label">
	      <Entry/Library/
	      <Entry/Module/
	      <Entry/Purpose/
	    </>
	  </THead>
	  <TBody>
	    <Row>
	      <Entry/<Literal/Dylan//
	      <Entry/<Literal/Dylan//
	      <Entry/standard Dylan/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Extensions//
	      <Entry/Mindy extensions/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/System//
	      <Entry/general functions/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/File-Descriptors//
	      <Entry/UNIX-style file support/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Threads//
	      <Entry/threads and semaphores/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Hash-Tables//
	      <Entry/additional table support/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Introspection//
	      <Entry/program examination/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Cheap-IO//
	      <Entry>basic, unformatted I/O</>
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Extern//
	      <Entry/support for linking to C/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Transcendental//
	      <Entry/trig and other math/
	    </>
	    
	    <Row>
	      <Entry/<Literal/Collection-Extensions//
	      <Entry/<Literal/Heap//
	      <Entry/standard heaps/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Self-Organizing-List//
	      <Entry/<Quote/poor man's hash table//
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Vector-Search//
	      <Entry/search, replace support/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Subseq//
	      <Entry/slices of sequences/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Sequence-Diff//
	      <Entry/<Quote/diff/ for sequences/
	    </>
	    
	    <Row>
	      <Entry/<Literal/String-Extensions//
	      <Entry/<Literal/String-Conversions//
	      <Entry>strings to/from integers</>
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Character-Type//
	      <Entry/similar to C's <Quote/<Literal/ctype.h///
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/String-Hacking//
	      <Entry/useful string functions/
	    </>
	    <Row>
	      <Entry//
		<Entry/<Literal/Substring-Search//
	      <Entry/similar to Perl/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Regular-Expressions//
	      <Entry/similar to Perl/
	    </>
	    
	    <Row>
	      <Entry/<Literal/Streams//
	      <Entry/<Literal/Streams//
	      <Entry>UNIX stream I/O</>
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Standard-IO//
	      <Entry/the 3 standard streams/
	    </>
	    
	    <Row>
	      <Entry/<Literal/Print//
	      <Entry/<Literal/PPrint//
	      <Entry/Pretty-printing/
	    </>
	    <Row>
	      <Entry//
	      <Entry/<Literal/Print//
	      <Entry/General object output/
	    </>
	    
	    <Row>
	      <Entry/<Literal/Format//
	      <Entry/<Literal/Format//
	      <Entry/Formatted output/
	    </>

	    <Row>
	      <Entry/<Literal/Random//
	      <Entry/<Literal/Random//
	      <Entry/Random distributions/
	    </>
	  </TBody>
	</TGroup>
      </Table>

      <Para>The <Literal/String-Extensions/ library, in particlar, contains
      a number of useful functions. It provides many of Perl's popular
      text-manipulation features.</>
    </Sect1>

    <Sect1 id="sealing">
      <Title/Sealing/
	
      <Para>Classes and generic functions may be <GlossTerm/sealed/ using a
      number of Dylan forms. This prevents code in other libraries from
      subclassing objects or adding methods to generic functions, and lets
      the compiler optimize more effectively. Both classes and generic
      functions are sealed by default.</>

      <Para>To allow code in other libraries to subclass a given class,
      declare it as <Literal/open/:</>

<ProgramListing>
define open class &lt;sample&gt; (&lt;object&gt;) end;
</>

      <Para>To allow other libraries to add methods to a generic function,
      use a similar syntax:</>

<ProgramListing>
define open generic sample-function( o :: &lt;object&gt; ) =&gt; ();
</>

      <Para>A third form, <Literal/define inert domain/, partially seals a
      generic function, disallowing only some additions from outside a
      library.</>

      <Para>For more information on sealing, see the chapter
      <Quote/Controlling Dynamism/ in the &drm;.</>
    </Sect1>
  </Chapter>


  <!-- ==================== Chapter 7 ==================== -->
  
  <Chapter id="conditions">
    <Title/Conditions/

    <Para>Dylan offers sophisticated exception handling, allowing programs
    to recover smoothly from error conditions. Like &cpp;, Dylan represents
    errors with objects. Dylan also supports advisory warnings and
    potentially correctable errors.</>

    <Para>When something unusual happens, a program can <GlossTerm/signal/
    a <GlossTerm/condition/. <GlossTerm/Handlers/ specify how to react to
    various sorts of conditions.</>

    <Sect1 id="blocks">
      <Title/Blocks/
      
      <Para>A <GlossTerm/block/ is a group of statements. As with other
      control structures, it may return a value. A simple block might
      appear as follows:</>

<ProgramListing>
block ()
  1 + 1;
end; // returns 2
</>

      <Para>Blocks also support non-local exits. These allow a block to
      exit at any time, optionally returning a value. In some ways, they
      are similar to <Literal/goto/ statements or the <Acronym/POSIX/
      <Function/longjmp/ function. To use them, specify a name in the
      parentheses following a <Literal/block/ statement. Dylan binds this
      name to an <GlossTerm/exit function/ which can be called from
      anywhere within the block or the functions it calls. The following
      block returns either <Literal/"Weird!"/ or <Literal/"All's well."/,
      depending on the color of the sky.</>

<ProgramListing>
block (finished)
	if (sky-is-green())
		finished("Weird!");
	end;
	"All's well."
end block;
</>

      <Para>Many programs need to dispose of resources or perform other
      cleanup work, regardless of how a block is exited. Blocks may contain
      an optional <Literal/cleanup/ clause, which doesn't affect the return
      value of the block and will always be executed.</>

<ProgramListing>
let fd = open-input-file();
block (return)
	let (errorcode, data) = read-data(fd);
	if (errorcode)
		return(errorcode);
	end if;
	process-data(data);
cleanup
	close(fd);
end;
</>

    </Sect1>
  </Chapter>
</Book>
