<!DOCTYPE BOOK PUBLIC "UNREGISTERED::Eric Kidd//DTD DylanDoc V3.1//EN" [
 <!ENTITY % entities SYSTEM "dylandoc.ent">
 %entities;

 <!ELEMENT DylanCharFnDef - O EMPTY>
 <!ATTLIST DylanCharFnDef name CDATA #IMPLIED 
                          condition CDATA #IMPLIED
			  elaboration CDATA #IMPLIED 
			  DylanDefName CDATA #FIXED "Function">

]>
<BOOK id="gdlibs">
  <title>Gwydion Dylan Library Reference Guide</title>
  <titleabbrev>Library Reference Guide</titleabbrev>

  <bookinfo>
    <COPYRIGHT>
      <YEAR>1996</YEAR>
      <YEAR>1997</YEAR>
      <YEAR>1998</YEAR>
      <YEAR>1999</YEAR>
      <YEAR>2000</YEAR>
      <YEAR>2001</YEAR>
      <YEAR>2002</YEAR>
      <HOLDER>Carnegie Mellon University</HOLDER>
      <HOLDER>Gwydion Dylan Maintainers</HOLDER>
    </COPYRIGHT>
    &cmu.terms;
    <bookbiblio>
      <date>12 November 2000</date>
      <editor>&person.housel;</editor>
      <editor>&person.bogk;</editor>
      <editor>&person.neel;</editor>
      <editor>&person.auclair;</editor>
    </bookbiblio>
  </bookinfo>

  <CHAPTER ID="libs-introduction">
    <TITLE>Introduction</TITLE>

    <PARA>This manual serves as a guide to the libraries included with
    Gywdion &dylan;.  These libraries include:</PARA>

    <VARIABLELIST>
      <VARLISTENTRY>
	<TERM>Dylan</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Streams</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Standard-IO</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Format</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Format-Out</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Print</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Collection-Extensions</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Table-Extensions</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>String-Extensions</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Regular-Expressions</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Transcendental</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Time</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Random</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Matrix</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
    </VARIABLELIST>
    
  </CHAPTER>

  <CHAPTER ID="libs-dylan">
    <TITLE>The Dylan Library and Gwydion Dylan Extensions</TITLE>

    <SECT1 id="libs-dylan-introduction">
      <TITLE>Introduction</TITLE>
      
      <PARA>In the process of working with Dylan, the Gwydion Project
      has come up with numerous extensions to the Dylan language. Some
      of them form entire libraries, like the
      <DLIBRARY>Collection-Extensions</DLIBRARY> and
      <DLIBRARY>String-Extensions</DLIBRARY> libraries. Others have
      been added to the <DLIBRARY>Dylan</DLIBRARY> library, in such
      modules as <DMODULE>Extensions</DMODULE> and
      <DMODULE>System</DMODULE>.</PARA>
      
      <PARA>We continue to make no claims about future support for our
      extensions. However, some extensions are more likely than others
      to make it into our future compilers. This file documents those
      extensions which we think will be included in our compiler's
      <DLIBRARY>Dylan</DLIBRARY> library.</PARA>
      
      <PARA>Extensions which go in separate libraries are documented
      in their own files; extensions which are part of the Mindy
      <DLIBRARY>Dylan</DLIBRARY> library but which have a less certain
      future are documented in the Mindy documentation.</PARA>

      <PARA>For the remainder of this chapter, we shall refer to
      "Gwydion compilers" as a shorthand for "Mindy and other
      Dylan compilers that the Gwydion Project may write." It is
      not meant as a guarentee that all future Gwydion releases will
      support these extensions.</PARA>

      <PARA>Specific Gwydion compilers may support extensions not
      listed here; see their documentation for details.</PARA>
    </SECT1>

    <SECT1 id="libs-dylan-modules">
      <TITLE>Modules of the Dylan Library</TITLE>
      
      <PARA>In addition to containing the <DMODULE>Dylan</DMODULE>
      module, the <DLIBRARY>Dylan</DLIBRARY> library contains a
      variety of modules which provide extensions. Gwydion compilers
      export the following modules from the <DLIBRARY>Dylan</DLIBRARY>
      library:</PARA>

      <VARIABLELIST>
	<VARLISTENTRY>
	  <TERM><DMODULE>Extensions</DMODULE></TERM>
	  <LISTITEM>
	    <PARA>This module exports useful extensions to the Dylan
	    language (see <XREF LINKEND="libs-dylan-extensions">).
	    Ultimately, there will be several, more logically separate
	    libraries that extend Dylan or provide an application
	    framework for users. For now, we put any commonly used
	    utilities in the <DMODULE>Extensions</DMODULE>
	    module.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><DMODULE>System</DMODULE></TERM>
	  <LISTITEM>
	    <PARA>This module exports an interface to operating system
            calls and special, low-level functionality (see <XREF
            LINKEND="libs-dylan-system">).</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><dmodule>Introspection</dmodule></TERM>
	  <LISTITEM>
	    <PARA>This module exports reflective operations for
	    examining classes, functions, and so on.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><dmodule>Cheap-io</dmodule></TERM>
	  <LISTITEM>
	    <PARA>This module exports some basic, unextendable input
	    and output functionality.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>
      </VARIABLELIST>
    </SECT1>

    <SECT1 id="libs-dylan-dylan">
      <TITLE>The Dylan Module</TITLE>

      <PARA>Whenever possible, we have tried to keep the
      <dmodule>Dylan</dmodule> module pristine and unextended,
      prefering to add our extensions to separate modules or
      libraries. However, this is not always possible, particularly
      when it involves extending the behavior of a function or macro
      that is exported from the <dmodule>Dylan</dmodule>
      module. Currently, Gwydion compilers support these extensions to
      the <dmodule>Dylan</dmodule> module as described below:</PARA>

      <ITEMIZEDLIST>
	<LISTITEM>
	  <PARA>Gwydion compilers support <dlit>keyed-by</dlit>
	  clauses in <dlit>for</dlit> statements.  The format of
	  such a clause is</PARA>

	  <SYNOPSIS><PARAMETER>var</PARAMETER> keyed-by <PARAMETER>key</PARAMETER> in <PARAMETER>collection</PARAMETER></SYNOPSIS>

	  <PARA>The <PARAMETER>var</PARAMETER> is bound to each
	  element in <PARAMETER>collection</PARAMETER>, and
	  <PARAMETER>key</PARAMETER> is bound to the element's key
	  value.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Gwydion compilers supports <dlit>using</dlit>
	  clauses in <dlit>for</dlit> statements.  The format of
	  such a clause is</PARA>

	  <SYNOPSIS><PARAMETER>var</PARAMETER> in <PARAMETER>collection</PARAMETER> using <PARAMETER>protocol</PARAMETER></SYNOPSIS>

	  <PARA>The <PARAMETER>protocol</PARAMETER> will be used
	  instead of
	  <dname>forward-iteration-protocol</dname>. The
	  <PARAMETER>protocol</PARAMETER> argument must be a variable
	  name, not an expression. These <dlit>using</dlit>
	  clauses may be used together with
	  <dlit>keyed-by</dlit>:</PARA>
	  
	  <SYNOPSIS><PARAMETER>var</PARAMETER> keyed-by <PARAMETER>key</PARAMETER> in <PARAMETER>collection</PARAMETER> using <PARAMETER>protocol</PARAMETER></SYNOPSIS>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Gwydion compilers have an additional type of top level
	  definition, <dlit>define function</dlit>, which
	  creates a constant binding in the current module and
	  initializes it to a new function. The usage of
	  <dlit>define function</dlit> usage is similar to that
	  of <dlit>define method</dlit>. The following is an
	  example:</PARA>

	  <PROGRAMLISTING>
define function cube (x)
  x * x * x;
end function cube;
</PROGRAMLISTING>

	  <PARA>A similar result might be had by writing</PARA>

	  <PROGRAMLISTING>
define constant cube = method (x)
                         x * x * x;
                       end method;
</PROGRAMLISTING>

	  <PARA>or</PARA>

	  <PROGRAMLISTING>
define method cube (x)
  x * x * x;
end method cube;
</PROGRAMLISTING>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Gwydion compilers supports subclass specializers via
	  the <dname>limited</dname> function.  A subclass
	  specializer causes a method to be invoked whenever the
	  generic function was called on a value that is the specified
	  class or any subclass of the specified class.  The method is
	  never invoked on a value that is an instance (direct or
	  indirect) of the specified class, only when the value is a
	  subclass of the specified class.  The following is an
	  example:</PARA>

	  <PROGRAMLISTING>
define method make
    (result-class :: limited(&lt;class&gt;, subclass-of: &lt;my-class&gt;));
  let x = next-method();
  do-special-logging-or-something(x);
  x;
end method;</PROGRAMLISTING>
	</LISTITEM>
      </ITEMIZEDLIST>
    </SECT1>

    <SECT1 ID="libs-dylan-extensions">
      <TITLE>The Extensions Module</TITLE>

      <PARA>Ultimately, there will be several, more logically separate
      libraries that extend Dylan or provide an application framework
      for users.  For now, we put any commonly used utilities in the
      Extensions module.</PARA>

      <SECT2>
	<TITLE>Generally Useful Definitions</TITLE>

	<PARA>The Extensions module exports the following generally
	useful functionality:</PARA>

	<dylanclassdef>
	  <defname>&lt;byte-vector&gt;</DEFNAME>
	  <defadjectives>sealed</defadjectives>
	  <defsummary>
	    A &lt;vector&gt; that holds integers between 0
	    and 255 inclusively
	  </defsummary> 
	  <defsupers><defsuper>&lt;simple-vector&gt;</defsuper></defsupers>
	  <definitkeywords>
	    <keyparam>
	      <paramname>fill</paramname>
	      <paramtype>&lt;byte&gt;</paramtype>
	      <paramdefault>0</paramdefault>
	      <paramsummary>The default value of each element</paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>size</paramname>
	      <paramdefault>0</paramdefault>
	      <paramsummary>The size of the vector</paramsummary>
	    </keyparam>
	  </definitkeywords>
	  <defdescription>
	    <para>
	      An efficient vector for byte-storage.
	    </para>
	  </defdescription>
	</dylanclassdef>

	<dylanconstantdef>
	  <defname>&lt;byte-character&gt;</DEFNAME>
	  <defsummary>
	    An ASCII character.
	  </defsummary>
	  <deftype>&lt;byte-character-type&gt;</deftype>
	  <defdescription>
	    <para>
	      Characters of this type represent the ASCII
	      character set (or extensions to ASCII such as ISO
	      8859). Note, in Gwydion compilers the
	      <dclass>character</dclass> class is
	      equivalent to Unicode characters.
	    </para>
	  </defdescription>
	</dylanconstantdef>

	<dylanfunctiondef>
	  <defname>assert</defname>
	  <defsummary>Signals an error if assumption is incorrect</defsummary>
	  <defparameters>
	    <param>
	      <paramname>value</paramname>
	      <paramsummary>
	        A boolean condition which should be &true;
	      </paramsummary>
	    </param>
	  </defparameters>
	  &no-returns;
	  <defdescription>
	    <para>
	      This function signals an error if
	      <PARAMETER>value</PARAMETER> is &false;. Otherwise, it
	      does nothing. In future Gwydion compilers, assert may be
	      changed to a macro, which may or may not evaluate its
	      argument exactly once.
	    </para>
	    <note>
	      <para>
	        So, it goes to follow that users of
		<dname>assert</dname> should not have side-effects
		in the expression that is passed to
		<dname>assert</dname> because if we ever turn
		assertions off, that would mean the program runs
		differently in debug mode than it does in release
		mode.
	      </para>
	    </note>
	  </defdescription>
	</dylanfunctiondef>

	<dylanmethoddef>
	  <defname>one-of</defname>
	  <defsummary>
	    Creates a class that is one of the supplied arguments.
	  </defsummary>
	  <defparameters>
	    <restparam>
	      <paramname>things</paramname>
	      <paramsummary>The allowable classes</paramsummary>
	    </restparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>res</paramname>
	      <paramtype>&lt;type&gt;</paramtype>
	      <paramsummary>
	        The resulting type from the supplied classes.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <PARA>This function takes any number of objects, and
	    returns the type that is the type-union of the singletons
	    of those objects. For example, the expression</PARA>

	    <PROGRAMLISTING>
one-of(#"foo", #"bar", #"baz")</PROGRAMLISTING>

	    <PARA>is equivalent to</PARA>

	    <PROGRAMLISTING>
type-union(singleton(#"foo"), singleton(#"bar"), singleton(#"baz"))</PROGRAMLISTING>
	  </defdescription>
	</dylanmethoddef>

	<dylanmethoddef>
	  <defname>false-or</defname>
	  <defsummary>
	    Creates a class that is either &false; or the supplied class.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>type</paramname>
	      <paramsummary>The alternate type</paramsummary>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>res</paramname>
	      <paramtype>&lt;type&gt;</paramtype>
	      <paramsummary>
	        The resulting type-union.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <PARA>This function is useful in type expressions. It
	    captures the common idiom of returning an instance of a
	    particular type or the value &false;. The expression</PARA>

	    <PROGRAMLISTING>
false-or(&lt;integer&gt;)</PROGRAMLISTING>

	    <PARA>is equivalent to the expression</PARA>

	    <PROGRAMLISTING>
type-union(&lt;integer&gt;, singleton(#f))</PROGRAMLISTING>

	  </defdescription>
	</dylanmethoddef>

      </SECT2>

      <SECT2>
	<TITLE>Debugger Customizations</TITLE>

	<PARA>(A note on terminology: We use the term "debugger" here
	in the loose, Dylan sense of anything that handles an uncaught
	error. In Mindy, this debugger is indeed a full fledged
	debugger, but in other Gwydion compilers it may not be.)</PARA>

	<PARA>The debugger uses the function
	<dname>report-condition</dname> to print conditions as error
	messages to users; for example, this is the function that
	implements the <dlit>%S</dlit> format-string directive
	for conditions. The debugger also uses the
	<dname>format</dname> function exported from the
	<dmodule>Cheap-io</dmodule> 
	module to process format strings, and it prints directly to
	the Unix stdout. If any library that is used itself uses the
	<dlibrary>Debugger-format</dlibrary> library, then the
	debugger uses format from 
	the <dlibrary>Format</dlibrary> library, which is shipped with Gwydion
	compilers. You can extend how the debugger prints conditions,
	change what formatting function it uses, and direct where
	debugger output goes with the following:</PARA>

	<dylangenericdef>
	  <defname>report-condition</defname>
	  <defadjectives>open</defadjectives>
	  <defsummary>Writes a condition to a stream.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>condition</paramname>
	      <paramtype>&lt;condition&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>stream</paramname>
	      <paramtype>&lt;object&gt;</paramtype>
	      <paramsummary>
	        As we don't know the underlying output
		system, we'll accept any object.
	      </paramsummary>
	    </param>
	  </defparameters>
	  &no-returns;
	  <defdescription>
	    <PARA>This is the function that is used to print condition
	    variables as error messages to users. The internal
	    <dname>format</dname> function used by Mindy uses
	    report-condition for condition arguments to the
	    <dlit>%S</dlit> format directive. The <dlibrary>Format</dlibrary>
	    library's <dname>print-message</dname> method for
	    conditions calls
	    <dname>report-condition</dname>.</PARA>

	    <PARA>If you are writing a module that does no output but
	    still provides <dname>report-condition</dname>
	    methods, you should use 
	    <dname>condition-format</dname> to format
	    output. Using <dname>condition-format</dname> makes
	    your module more flexible for users of your module. If you
	    call <dmodule>Cheap-IO</dmodule>'s
	    <dname>format</dname>, you'll be forced to write to
	    only one destination, <dlit>stdout</dlit>, ignoring the
	    <PARAMETER>stream</PARAMETER> argument. If you call the
	    <dlibrary>Format</dlibrary> library's
	    <dname>format</dname> function, 
	    then your module will require the
	    <dlibrary>Format</dlibrary>, <dlibrary>Print</dlibrary>,
	    and <dlibrary>Streams</dlibrary> libraries; therefore,
	    users of your module may ultimately load these other
	    libraries needlessly. Of course, if you want to make use
	    of the extended functionality of the
	    <dlibrary>Format</dlibrary> library's format control 
	    strings, then you only have one choice anyway, and there's
	    no reason to use
	    <dname>condition-format</dname>.</PARA>
	    <para>
	      <dname>Report-condition</dname> has several
	      supplied methods.  The default method (on
	      <dclass>condition</dclass>) simply prints
	      the condition (not very descriptive).  The
	      <dclass>format-string-condtion</dclass>
	      (of which the simple conditions are derived) method uses
	      the supplied format-string to output information about
	      the cause of the condition.  The
	      <dclass>type-error</dclass> method gives
	      the expected and actual types, and the
	      <dclass>abort</dclass> method just prints
	      the supplied description. 
	    </para>
	  </defdescription>
	</dylangenericdef>

	<dylangenericdef>
	  <defname>condition-format</defname>
	  <defadjectives>open</defadjectives>
	  <defsummary>
	    Serves as a firewall between the condition system and streams.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>stream</paramname>
	      <paramtype>&lt;object&gt;</paramtype>
	      <paramsummary>
	        As we don't know the underlying output
		system, we'll accept any object.
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>control-string</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	      <paramsummary>
	        The format string to print the condition.
	      </paramsummary>
	    </param>
	    <restparam>
	      <paramname>arguments</paramname>
	    </restparam>
	  </defparameters>
	  &no-returns;
	  <defdescription>
	    <PARA>This function serves as a firewall between the
	    condition system and the <dlibrary>Streams</dlibrary> and
	    <dlibrary>Format</dlibrary> 
	    libraries. Methods on
	    <dname>report-condition</dname> should use
	    <dname>condition-format</dname> to do their
	    formatting. Users will generally use
	    <dlit>*debug-output*</dlit> or
	    <dlit>*warning-output*</dlit> for the
	    <parameter>stream</parameter> 
	    argument, but this is not required.</PARA>

	    <PARA>Mindy supplies a method for when
	    <parameter>stream</parameter> is 
	    <dlit>#"Cheap-IO"</dlit>. The Gwydion
	    <dlibrary>Format</dlibrary> library 
	    supplies a method for when <parameter>stream</parameter>
	    is a subclass of <dclass>stream</dclass>. If
	    you are implementing your own streams or format libraries,
	    you will need to define a method on
	    <dname>condition-format</dname> for your type of
	    stream.</PARA> 
	  </defdescription>
	</dylangenericdef>

	<dylangenericdef>
	  <defname>condition-force-output</defname>
	  <defadjectives>open</defadjectives>
	  <defsummary>
	    Flushes the condition output stream.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>stream</paramname>
	      <paramtype>&lt;object&gt;</paramtype>
	      <paramsummary>
	        As we don't know the underlying output
		system, we'll accept any object.
	      </paramsummary>
	    </param>
	  </defparameters>
	  &no-returns;
	  <defdescription>
	    <PARA><dname>Condition-force-output</dname> forces
	    any pending output from <PARAMETER>stream</PARAMETER>'s
	    buffer to <PARAMETER>stream</PARAMETER>'s
	    destination. This function is invoked by the debugger
	    after a condition has been reported and before it pauses
	    for user input. Unless you are writing a debugger, you do
	    not need to call
	    <dname>condition-force-output</dname>
	    yourself.</PARA>

	    <PARA>Mindy supplies a method for when stream is
	    <dlit>#"Cheap-IO"</dlit>. The Gwydion
	    <dlibrary>Format</dlibrary> library 
	    supplies a method for when <parameter>stream</parameter>
	    is a subclass of 
	    <dclass>stream</dclass>. If you are
	    implementing your own streams or format libraries, you
	    will need to define a method on
	    <dname>condition-force-output</dname> for your type
	    of stream.</PARA>
	  </defdescription>
	</dylangenericdef>

	<dylanvariabledef>
	  <defname>*default-level*</defname>
	  <defsummary>
	    Gives how far down recursively to print
	  </defsummary>
	  <deftype>&lt;object&gt;</deftype>
	  <defdescription>
	    <PARA>Default-handler for
	    <dclass>warning</dclass> uses
	    <dlit>*warning-output*</dlit> to print warning
	    messages. This variable must be either a
	    <dclass>stream</dclass> from the
	    <dlibrary>Streams</dlibrary> 
	    library, or <dlit>#"Cheap-IO"</dlit> (the
	    default). When this variable is
	    <dlit>#"Cheap-IO"</dlit>, the output goes to
	    <dlit>stderr</dlit>.</PARA>
	  </defdescription>
        </dylanvariabledef>

      </SECT2>

      <SECT2 ID="libs-dylan-exiting-applications">
	<TITLE>Exiting Applications</TITLE>

	<PARA>The Extensions module exports the following
	functionality for controlling the exiting of
	applications:</PARA>

	<dylanmethoddef>
	  <defname>exit</defname>
	  <defsummary>Causes the application to quit.</defsummary>
	  <defparameters>
	    <keyparam>
	      <paramname>exit-code</paramname>
	      <paramtype>&lt;integer&gt;</paramtype>
	      <paramdefault>0</paramdefault>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>res</paramname>
	      <paramtype>&lt;never-returns&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <PARA>Causes the process to exit with return code
	    <PARAMETER>exit-code</PARAMETER>.</PARA>
	  </defdescription>
	</dylanmethoddef>

	<dylanmethoddef>
	  <defname>on-exit</defname>
	  <defsummary>Adds a function to be called just before quitting.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>function</paramname>
	      <paramtype>&lt;function&gt;</paramtype>
	      <paramsummary>A function to execute before quitting.
	      </paramsummary>
	    </param>
	  </defparameters>
	  &no-returns;
	  <defdescription>
	    <PARA>Arranges for the <dname>exit</dname> function
	    to call the argument function.  The argument function must
	    take no required arguments.  Users may call
	    <dname>on-exit</dname> multiple times to install
	    more than one function for <dname>exit</dname> to
	    call, but the order in which exit invokes the functions is
	    undefined. Calling <dname>on-exit</dname> on the
	    same function repeatedly installs that function multiple
	    times.</PARA>
	  </defdescription>
	</dylanmethoddef>

      </SECT2>

      <SECT2>
	<TITLE>Collections</TITLE>

	<PARA>The Extensions module exports the following
	<dclass>collection</dclass>
	functionality:</PARA>

	<dylanmethoddef>
	  <defname>key-exists?</defname>
	  <defsummary>
	    Returns &true; if a key is in a collection.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>coll</paramname>
	      <paramtype>&lt;collection&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>key</paramname>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>result</paramname>
	      <paramtype>&lt;boolean&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>value</paramname>
	      <paramtype>&lt;object&gt;</paramtype>
	      <paramsummary>The associated datum for the key</paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <PARA>Return whether <PARAMETER>key</PARAMETER> is in
	    <PARAMETER>coll</PARAMETER>. If the
	    <PARAMETER>key</PARAMETER> is in the
	    <PARAMETER>coll</PARAMETER>, then the second value
	    is the element associated with <PARAMETER>key</PARAMETER>;
	    otherwise, the second return value is &false;.</PARA>
	  </defdescription>
	</dylanmethoddef>

      </SECT2>
      <SECT2>
	<TITLE>Integers</TITLE>

	<PARA>Gwydion compilers have an abstract class
	<dclass>general-integer</dclass> which has two
	concrete subclasses, <dclass>integer</dclass>
	and <dclass>extended-integer</dclass>.
	<dclass>integer</dclass>s have a limited range
	of values, and <dclass>integer</dclass>
	arithmetic uses the computer's underlying integer
	facilities. <dclass>extended-integer</dclass>s
	can take on any value, and are similar to Common Lisp
	"bignums."  Expressions involving
	<dclass>extended-integer</dclass>s produce
	<dclass>extendedinteger</dclass> results because
	<dclass>extended-integer</dclass>s are
	contagious. If an expression involving only
	<dclass>integer</dclass> values would produce a
	result that does not fit in an
	<dclass>integer</dclass>, then the Gwydion
	compiler will signal an overflow error. You can use the
	<dname>as</dname> function to convert back and forth
	between <dclass>integer</dclass>s and
	<dclass>extended-integer</dclass>s. As signals
	an error when converting an
	<dclass>extended-integer</dclass> to a
	<dclass>integer</dclass>, and the value does not fit in a
	<dclass>integer</dclass>.</PARA>

	<PARA>The Extension module exports the following integer
	functionality:</PARA>

	<dylanclassdef>
	  <defname>&lt;general-integer&gt;</dEFNAME>
	  <defadjectives>abstract</defadjectives>
	  <defsummary>Parent class of all integers.</defsummary>
	  <defsupers><defsuper>&lt;rational&gt;</defsuper></defsupers>
	  <definitkeywords>
	  </definitkeywords>
	  <defdescription>
	    <PARA>The superclass of
	    <dclass>integer</dclass> and
	    <dclass>extended-integer</dclass>.</PARA>
	  </defdescription>
	</dylanclassdef>

	<dylanclassdef>
	  <defname>&lt;extended-integer&gt;</dEFNAME>
	  <defadjectives></defadjectives>
	  <defsummary>An integer of any size.</defsummary>
	  <defsupers><defsuper>&lt;general-integer&gt;</defsuper></defsupers>
	  <definitkeywords>
	  </definitkeywords>
	  <defdescription>
	    <PARA>
	      A bignum is just a vector of digits.
	    </PARA>
	  </defdescription>
	</dylanclassdef>

	<dylanconstantdef>
	  <defname>$maximum-integer</defname>
	  <defsummary>
	    Highest computed integer for the architecture.
	  </defsummary>
	  <deftype>&lt;integer&gt;</deftype>
	  <defdescription>
	    <PARA>Holds the largest positive
	    <dclass>integer</dclass>.</PARA>
          </defdescription>
        </dylanconstantdef>

	<dylanconstantdef>
	  <defname>$minimum-integer</defname>
	  <defsummary>
	    Lowest computed integer for the architecture.
	  </defsummary>
	  <deftype>&lt;integer&gt;</deftype>
	  <defdescription>
	    <PARA>Holds the smallest negative
	    <dclass>integer</dclass>.</PARA>
          </defdescription>
        </dylanconstantdef>

      </SECT2>

      <SECT2>
	<TITLE>Ratios</TITLE>

	<PARA>The <dmodule>Extensions</dmodule> module exports the
	following:</PARA> 

	<dylanclassdef>
	  <defname>&lt;ratio&gt;</dEFNAME>
	  <defadjectives>functional</defadjectives>
	  <defsummary>An exact fractional number.</defsummary>
	  <defsupers><defsuper>&lt;rational&gt;</defsuper></defsupers>
	  <definitkeywords>
	    <keyparam>
	      <paramname>numerator</paramname>
	      <paramtype>&lt;extended-integer&gt;</paramtype>
	    </keyparam>
	    <keyparam>
	      <paramname>denominator</paramname>
	      <paramtype>&lt;extended-integer&gt;</paramtype>
	      <paramsummary>Guaranteed positive.</paramsummary>
	    </keyparam>
	  </definitkeywords>
	  <defdescription>
	    <para>A ratio has two slots: <dname>numerator</dname> and
	    <dname>denominator</dname>.  It is normalized so that it
	    has a positive 
	    denominator, and the greatest common divisor of the
	    numerator and the denominator is one. Ratios are never
	    automatically converted to integers. For example,
	    <dlit>ratio(4, 2)</dlit> would return
	    <dlit>2/1</dlit>.</PARA>

	    <PARA>A numeric operation involving two ratios produces a
	    normalized ratio result. A numeric operation involving a
	    ratio and an integer produced a normalized ratio result. A
	    numeric operation involving a ratio and a float produces a
	    float result.</PARA>
	  </defdescription>
	</dylanclassdef>

	<dylanmethoddef>
	  <defname>ratio</defname>
	  <defsummary>Makes a ratio from to integers.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>num</paramname>
	      <paramtype>&lt;extended-integer&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>denom</paramname>
	      <paramtype>&lt;extended-integer&gt;</paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>res</paramname>
	      <paramtype>&lt;ratio&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <PARA>This function makes a ratio from the two
	    integers.</PARA>
	  </defdescription>
	</dylanmethoddef>

      </SECT2>
    </SECT1>

    <SECT1 ID="libs-dylan-system">
      <TITLE>The System Module</TITLE>

      <PARA></PARA>
    </SECT1>

    <SECT1 ID="libs-dylan-introspection">
      <TITLE>The Introspection Module</TITLE>

      <PARA></PARA>
    </SECT1>

    <SECT1 id="libs-dylan-cheap-io">
      <TITLE>The Cheap-IO Module</TITLE>

      <PARA></PARA>

    </SECT1>
  </CHAPTER>

  <CHAPTER ID="libs-streams">
    <DOCINFO>
      <TITLE>The Streams Library</TITLE>
      <DATE>06 Feb 1997</DATE>
      <!-- Heavily modified structure (and added functions) Douglas M. Auclair,
       Dec 3, 2000 -->
      <EDITOR>
	<FIRSTNAME>Andrew</FIRSTNAME><SURNAME>Shires</SURNAME>
      </EDITOR>
      <AUTHORGROUP>
	<AUTHOR>
	  <FIRSTNAME>Scott</FIRSTNAME><SURNAME>McKay</SURNAME>
	  <AFFILIATION>
	    <ORGNAME>Harlequin, Inc.</ORGNAME>
	  </AFFILIATION>
	</AUTHOR>
	<AUTHOR>
	  <FIRSTNAME>Bill</FIRSTNAME><SURNAME>Chiles</SURNAME>
	</AUTHOR>
	<AUTHOR>
	  <FIRSTNAME>Marc</FIRSTNAME><SURNAME>Ferguson</SURNAME>
	</AUTHOR>
	<AUTHOR>
	  <FIRSTNAME>Eliot</FIRSTNAME><SURNAME>Miranda</SURNAME>
	</AUTHOR>
      </AUTHORGROUP>
    </DOCINFO>
    <TITLE>The Streams Library</TITLE>

    <AUTHORBLURB>
      <FORMALPARA>
	<TITLE>Acknowlegements</TITLE>
	<PARA>We'd like to thank the other people who
	have been instrumental in the production of this proposal:
	Jonathan Bachrach, Dave Berry, John Dunning, Chris Fry, Paul
	Haahr, William Lott, Rob Maclachlan, Tim McNerney, Tony Mann,
	Keith Playford, Robert Stockton, and Tucker Withington.</PARA>
      </FORMALPARA>
    </AUTHORBLURB>

    <SECT1 id="libs-streams-error-conventions">
      <TITLE>Discussing error conditions</TITLE>

      <PARA>This document uses two special terms in discussions of
      error conditions.</PARA>

      <PARA>When we say that something is an error, we mean that the
      result is undefined. In particular, we do not mean that a
      Streams implementation must signal an error condition; that is
      the implementor's choice. So, for instance, the following text
      means only that the result of using unread-element
      in the case described is undefined:</PARA>

      <PARA>It is an error to apply
      <dname>unread-element</dname> to an element that is not
      the element most recently read from the stream.</PARA>

      <PARA>Only when we specifically mention signaling do we mean
      that a Streams implementation must signal an error
      condition. Note that we may not, in such a case, say exactly
      which error condition must be signaled; if we do not say so, the
      choice is again up to the implementor. In the following text,
      for instance,
      we state that an implementation must signal an error, but we do
      not say what error must be signaled:</PARA>

      <PARA>When position is a
      <dclass>stream-position</dclass>, if it is invalid
      for some reason, this function signals an error.</PARA>

      <PARA>By contrast, the following text 
      says exactly
      which error must be signaled:</PARA>

      <PARA>If the end of the stream is encountered and no value was
      supplied for on-end-of-stream, read-element signals an
      <dclass>end-of-stream-error</dclass>
      condition. </PARA>
    </SECT1>

    <SECT1 id="libs-streams-goals">
      <TITLE>Goals of the Library</TITLE>

      <PARA>The Dylan Streams library aims to provide:</PARA>

      <ITEMIZEDLIST>
	<LISTITEM>
	  <PARA>A generic, easy-to-use interface for streaming over
	  sequences and files. The same high-level interface for
	  consuming or producing is available irrespective of the type
	  of stream, or the types of the elements being streamed
	  over.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Efficiency, especially for the common case of file
	  I/O.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Access to an underlying buffer management protocol.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>An extensible framework. Other areas of functionality
	  that require a stream interface should be easy to integrate
	  with the library.</PARA>
	</LISTITEM>
      </ITEMIZEDLIST>

      <PARA>The proposal presents the design of a Streams library that
      meets these goals using Dylan's built-in sequences and a
      buffered disk file interface. </PARA>

      <PARA>The proposal does not address a number of related issues,
      including:</PARA>

      <ITEMIZEDLIST>
	<LISTITEM>
	  <PARA>A standard object-printing package such as Smalltalk's
	  <dlit>printOn:</dlit> or Lisp's
	  <dlit>print-object</dlit>, or a formatted printing
	  facility such as Lisp's
	  <dlit>format</dlit>. Additional libraries are expected
	  to provide these facilities.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>General object dumping and loading.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>A comprehensive range of I/O facilities for using
	  memory-mapped files, network connections, and so on. Such
	  facilities should be easy to add to the Streams library
	  because of its extensible framework.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>An interface for naming files.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>An interface to operating system functionality, such
	  as file renaming or deleting operations.  </PARA>
	</LISTITEM>
      </ITEMIZEDLIST>
    </SECT1>

    <SECT1 id="libs-streams-concepts">
      <TITLE>Concepts</TITLE>

      <PARA>A stream provides sequential access to an aggregate of
      data, such as a Dylan sequence or a disk file. Streams grant
      this access according to a metaphor of reading and writing:
      elements can be read from streams or written to them.</PARA>

      <PARA>Streams are represented as Dylan objects, and all are
      general instances of the class
      <dclass>stream</dclass>, which the Streams library
      defines.</PARA>

      <PARA>We say that a stream is established over the data
      aggregate. Hence, a stream providing access to the string
      <dlit>"hello world"</dlit> is said to be a stream over the
      string <dlit>"hello world"</dlit>.</PARA>

      <PARA>Streams permitting reading operations are called input
      streams. Input streams allow elements from the underlying data
      aggregate to be consumed. Conversely, streams permitting writing
      operations are called output streams. Output streams allow
      elements to be written to the underlying data aggregate. Streams
      permitting both kinds of operations are called input-output
      streams. </PARA>

      <PARA>The library provides a set of functions for reading
      elements from an input stream. These functions hide the details
      of indexing, buffering, and so on. For instance, the function
      read-element reads a single data element from an input
      stream. </PARA>

      <PARA>The following expression binds stream to an input stream
      over the string <dlit>"hello world"</dlit>: </PARA>

      <PROGRAMLISTING>
let stream = make(&lt;string-stream&gt;, contents: "hello world");</PROGRAMLISTING>

      <PARA>The first invocation of read-element on stream returns the
      character 'h', the next invocation 'e', and so on. Once a stream
      has been used to consume all the elements of the data, the
      stream is said to be at its end. This condition can be tested
      with the function <dname>stream-at-end?</dname>. The
      following code fragment applies function to all elements of the
      sequence:</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;sequence-stream&gt;, contents: seq);
while (~stream-at-end?(stream)) 
	function(read-element(stream));
end;</PROGRAMLISTING>

      <PARA>When all elements of a stream have been read, further
      calls to <dname>read-element</dname> result in the
      <dclass>end-of-stream-error</dclass> condition
      being signalled. An alternative end-of-stream behavior is to
      have a distinguished end-of-stream value returned. You can
      supply such an end-of-stream value as a keyword argument to the
      various read functions; the value can be any object. Supplying
      an end-of-stream value to a read function is more efficient than
      asking whether a stream is at its end on every iteration of a
      loop. </PARA>

      <PARA>The library also provides a set of functions for writing
      data elements to an output stream. Like the functions that
      operate upon input streams, these functions hide the details of
      indexing, growing an underlying sequence, buffering for a file,
      and so on. For instance, the function
      <dname>write-element</dname> writes a single data element
      to an output stream. </PARA>

      <PARA>The following forms bind stream to an output stream over
      an empty string and create the string <dlit>"I
      see!"</dlit>, using the function
      <dname>stream-contents</dname> to access all of the
      stream's elements.</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;byte-string-stream&gt;, direction: #"output");
write-element(stream, 'I');
write-element(stream, ' ');
write(stream, "see");
write-element(stream, '!');
stream-contents(stream);</PROGRAMLISTING>

      <PARA>Calling <dname>write</dname> on a sequence has the
      same effect as calling <dname>write-element</dname> on all
      the elements of the sequence. However, it is not required that
      <dname>write</dname> be implemented directly in terms of
      <dname>write-element</dname>; it might be implemented more
      efficiently, especially for buffered streams.</PARA>

      <PARA>Some streams are positionable; that is, they permit random
      access to their elements. Postionable streams allow you to set
      the position at which the stream will be accessed by the next
      operation. The following example uses positioning to return the
      character <dlit>'w'</dlit> from a stream over the string
      <dlit>"hello world"</dlit>:</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;string-stream&gt;, contents: "hello world");
stream-position(stream) := 6;
read-element(stream);</PROGRAMLISTING>
      
      <PARA>The following example returns a string, but the contents
      of the first ten characters are undefined:</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;string-stream&gt;, direction: #"output");
adjust-stream-position(stream, 10); 
write(stream, "whoa!");
stream-contents(stream);</PROGRAMLISTING>
      
      <PARA>You can request a sequence containing all of the elements
      of a positionable stream by calling
      <dname>stream-contents</dname> on it. The sequence
      returned never shares structure with any underlying sequence
      that might be used in future by the stream. For instance, the
      string returned by calling <dname>stream-contents</dname>
      on an output <dclass>string-stream</dclass> will
      not be the same string as that being used to represent the
      string stream.</PARA>

      <PARA>When making an input <dclass>string-stream</dclass>, you can cause
      the stream to produce elements from any subsequence of the
      supplied string. For example:</PARA>

      <PROGRAMLISTING>
read-to-end(make(&lt;string-stream&gt;, 
                 contents: "hello there, world",
                 start: 6, 
                 end: 11));</PROGRAMLISTING>

      <PARA>This example evaluates to "there". The interval (start,
      end) includes the index start but excludes the index end. This
      is consistent with standard Dylan functions over sequences, such
      as copy-sequence. The read-to-end function is one of a number of
      convenient utility functions for operating on streams and
      returns all the elements up to the end of the stream from the
      stream's current position.</PARA>
    </SECT1>

    <SECT1 id="libs-streams-growing-sequences">
      <TITLE>Streams, growing sequences, and object identity</TITLE>

      <PARA>When writing to output streams over sequences, Dylan may
      from time to time need to grow the underlying sequence that it
      is using to represent the stream data. </PARA>

      <PARA>Consider the example of an output stream instantiated over
      an empty string. As soon as a write operation is performed on
      the stream, it is necessary to replace the string object used in
      the representation of the string stream. As well as incurring
      the cost of creating a new string, the replacement operation can
      affect the integrity of other references to the string within
      the program. </PARA>

      <PARA>To guarantee that alias references to a sequence used in
      an output <dclass>sequence-stream</dclass> will
      have access to any elements written to the sequence via the
      stream, supply a <dclass>stretchy-vector</dclass>
      to make. A stream over a stretchy vector will use the same
      stretchy vector throughout the stream's existence. </PARA>

      <PARA>For example:</PARA>

      <PROGRAMLISTING>
let sv = make(&lt;stretchy-vector&gt;);
let stream = make(&lt;sequence-stream&gt;, 
                  contents: sv, 
                  direction: #"output");
write(stream, #(1, 2, 3, 4, 5, 6, 7, 8, 9));
write(stream, "ABCDEF");
values(sv, stream-contents(stream));</PROGRAMLISTING>

      <PARA>The example returns two values. Each value is the same
      (<dlit>\==</dlit>) stretchy vector:</PARA>

      <PROGRAMLISTING>
#[1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F']</PROGRAMLISTING>

      <PARA>If a stretchy vector is not supplied, the result is
      different: </PARA>

      <PROGRAMLISTING>
let v = make(&lt;vector&gt;, size: 5);
let stream = make(&lt;sequence-stream&gt;,
                  contents: v, 
                  direction: #"output");
write(stream, #(1, 2, 3, 4, 5, 6, 7, 8, 9));
write(stream, "ABCDEF");
values(v, stream-contents(stream));</PROGRAMLISTING>

      <PARA>This example returns as its first value the original
      vector, whose contents are undefined, but the second value is a
      new vector:</PARA>

      <PROGRAMLISTING>
#[1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F']</PROGRAMLISTING>

      <PARA>This difference arises because the output stream in the
      second example does not use a stretchy vector to hold the stream
      data. A vector of at least 15 elements is necessary to
      accommodate the elements written to the stream, but the vector
      supplied, <dlit>v</dlit>, can hold only 5. Since the
      stream cannot change <dlit>v</dlit>'s size, it must
      allocate a new vector each time it grows. </PARA>
    </SECT1>

    <SECT1 id="libs-streams-ref">
      <TITLE>Streams Reference</TITLE>

      <PARA>The exported streams class heterarchy is as follows:</PARA>

      <FIGURE>
	<TITLE>Streams library classes.</TITLE>
	<GRAPHIC fileref="streams.png"></GRAPHIC>
      </FIGURE>

      <PARA>Except for the classes
      <dclass>stream</dclass>,
      <dclass>buffered-stream</dclass>, and
      <dclass>positionable-stream</dclass>, these are
      instantiable classes.</PARA>

      <para>Streams, in general, have a host of operations for walking over
        or changing collections, and file streams have some specific issues
        of their own.  Therefore, we will cover the general stream classes
        and operations in <xref linkend="libs-streams-ref-general">, and file
        streams in <xref linkend="libs-streams-ref-file">.</para>

      <sect2 id="libs-streams-ref-general">
        <title>General Stream Classes and Operations</title>
        <sect3 id="libs-streams-ref-general-classes">
          <title>General Stream Classes</title>
        <dylanclassdef>
          <defname>&lt;stream&gt;</defname>
          <defadjectives>open abstract</defadjectives>
	  <defsummary>
	    The superclass of all stream classes.
          </defsummary>
	  &obj-super;
          <definitkeywords>
            <keyparam>
              <paramname>outer-stream</paramname>
            </keyparam>
          </definitkeywords>
          <defdescription>
            <para>All other streams inherit from this class</para>
          </defdescription>
        </dylanclassdef>

        <dylanclassdef>
	  <defname>&lt;positionable-stream&gt;</defname>
          <defadjectives>open abstract</defadjectives>
	  <defsummary>It supports the Positionable Stream Protocol</defsummary>
	  <defsupers><defsuper>&lt;stream&gt;</defsuper></defsupers>
          <definitkeywords>
          </definitkeywords>
          <defdescription>
            <para>Positionable streams allow one to specify from where in
              the stream to read or to write (see
              <xref linkend="libs-streams-general-fns-position">).
            </para>
          </defdescription>
        </dylanclassdef>

        <dylanclassdef>
	  <dEFNAME>&lt;stream-position&gt;</dEFNAME>
	  <defadjectives>abstract</defadjectives>
	  <defsummary>Gives the location in a &lt;positionable-stream&gt;.
          </defsummary>
	  &obj-super;
          <definitkeywords>
          </definitkeywords>
          <defdescription>
            <para>
              Allows random access to elements in 
              <dclass>positionable-stream</dclass>s.
            </para>
          </defdescription>
        </dylanclassdef>

        <dylanclassdef>
	  <dEFNAME>&lt;buffered-stream&gt;</dEFNAME>
	  <defadjectives>Open abstract</defadjectives>
	  <defsummary>
            Streams that can access multiple elements with a single 
            read/write command.
          </defsummary>
	  <defsupers><defsuper>&lt;stream&gt;</defsuper></defsupers>
          <definitkeywords>
            <keyparam>
	      <paramname>buffer-size</paramname>
	      <paramtype>&lt;integer&gt;</paramtype>
	      <paramsummary>Suggests the size of the underlying collection.
	      </paramsummary>
            </keyparam>
          </definitkeywords>
          <defdescription>
	    <PARA>A subclass of <dclass>stream</dclass>
	    supporting the Stream Extension Protocol and the Buffer
	    Access Protocol. It is not instantiable.</PARA>

	    <PARA>Streams of this class support the
	    <dlit>buffer-size:</dlit> init-keyword, which can be
	    used to suggest the size of the stream's buffer. However,
	    the instantiated stream might not use this value: it is
	    taken purely as a suggested value. For example, a stream
	    that uses a specific device's hardware buffer might use a
	    fixed buffer size regardless of the value passed with the
	    <dlit>buffer-size:</dlit> init-keyword. </PARA>
          </defdescription>
        </dylanclassdef>


        <dylanclassdef>
	  <dEFNAME>&lt;sequence-stream&gt;</dEFNAME>
	  <defadjectives>Open instantiable</defadjectives>
	  <defsummary>The class of streams over sequences.</defsummary>
	  <defsupers>
            <defsuper>&lt;positionable-stream&gt;</defsuper>
          </defsupers>
          <definitkeywords>
	    <keyparam><paramname>contents</paramname></keyparam>
	    <keyparam><paramname>direction</paramname></keyparam>
	    <keyparam><paramname>start</paramname></keyparam>
	    <keyparam><paramname>end</paramname></keyparam>
          </definitkeywords>
          <defdescription>
	    <PARA>The <dclass>sequence-stream</dclass>
	    class can be used for streaming over all sequences, but
	    there are also subclasses
	    <dclass>string-stream</dclass>,
	    <dclass>byte-string-stream</dclass>, and
	    <dclass>unicode-string-stream</dclass>,
	    which are specialized for streaming over strings.</PARA>
          </defdescription>
        </dylanclassdef>

        <dylanclassdef>
	  <defname>&lt;string-stream&gt;</dEFNAME>
	  <defadjectives>Open instantiable</defadjectives>
	  <defsummary>The class of streams over strings.</defsummary>
	  <defsupers><defsuper>&lt;sequence-stream&gt;</defsuper></defsupers>
	  <definitkeywords>
	    <keyparam><paramname>contents</paramname></keyparam>
	    <keyparam><paramname>direction</paramname></keyparam>
	    <keyparam><paramname>start</paramname></keyparam>
	    <keyparam><paramname>end</paramname></keyparam>
	  </definitkeywords>
          <defdescription>
	    <PARA>The superclass of the byte and unicode implementation
              classes.</para>
          </defdescription>
        </dylanclassdef>

        <dylanclassdef>
	  <defname>&lt;byte-string-stream&gt;</dEFNAME>
	  <defadjectives>Open instantiable</defadjectives>
	  <defsummary>The class of streams over strings.</defsummary>
	  <defsupers><defsuper>&lt;sequence-stream&gt;</defsuper></defsupers>
	  <definitkeywords>
	    <keyparam><paramname>contents</paramname></keyparam>
	    <keyparam><paramname>direction</paramname></keyparam>
	    <keyparam><paramname>start</paramname></keyparam>
	    <keyparam><paramname>end</paramname></keyparam>
	  </definitkeywords>
          <defdescription>
	    <PARA>Streams over byte strings.</para>
          </defdescription>
        </dylanclassdef>

        <dylanclassdef>
	  <defname>&lt;unicode-string-stream&gt;</dEFNAME>
	  <defadjectives>Open instantiable</defadjectives>
	  <defsummary>The class of streams over strings.</defsummary>
	  <defsupers><defsuper>&lt;sequence-stream&gt;</defsuper></defsupers>
	  <definitkeywords>
	    <keyparam><paramname>contents</paramname></keyparam>
	    <keyparam><paramname>direction</paramname></keyparam>
	    <keyparam><paramname>start</paramname></keyparam>
	    <keyparam><paramname>end</paramname></keyparam>
	  </definitkeywords>
          <defdescription>
	    <PARA>Streams over unicode strings</para>
          </defdescription>
        </dylanclassdef>
       </sect3>
       <sect3 id="libs-streams-ref-general-fns">
         <title>General Stream Functions</title>

	  <PARA>There are make methods on
	  <dclass>sequence-stream</dclass>,
	  <dclass>string-stream</dclass>,
	  <dclass>byte-string-stream</dclass> and
	  <dclass>unicode-string-stream</dclass>. The
	  <dname>make</dname> methods on
	  <dclass>sequence-stream</dclass> and
	  <dclass>string-stream</dclass> might not
	  create direct instances of those classes, but instead an
	  instance of a subclass determined by
	  <dname>type-for-sequence-stream</dname>.</PARA>

        <dylangenericdef>
          <defname>type-for-sequence-stream</defname>
          <defadjectives>open</defadjectives>
          <defsummary>Returns a stream depending on the sequence.</defsummary>
          <defparameters>
            <param>
              <paramname>seq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	  </defparameters>
          <defreturns>
            <param>
	      <paramname>sequence-stream-type</paramname>
	      <paramtype>&lt;type&gt;</paramtype>
            </param>
          </defreturns>
          <defdescription>
            <para>
              Called by <dname>make</dname>.  Returns a type for 
              creating a 
	      <dclass>sequence-stream</dclass>.
            </para>
          </defdescription>
        </dylangenericdef>

        <dylangenericdef>
          <defname>close</defname>
          <defadjectives>open</defadjectives>
          <defsummary>Closes a stream.</defsummary>
          <defparameters>
            <param>
              <paramname>stream</paramname>
	      <paramtype>&lt;stream&gt;</paramtype>
            </param>
            <allkeys>
          </defparameters>
	  &no-returns;
          <defdescription>
            <para>Streams are automatically opened when created, and closed
              when they go out of scope.  But, sometimes it is necessary to
              close a stream immediately (for example, to open another one
              over the same sequence but in the opposite direction).  This
              function provides for that necessity.
            </para>
          </defdescription>
        </dylangenericdef>

	<sect4 id="libs-streams-reg-general-fns-reading">
	  <title>Reading Functions</title>
	  <para>
	    From a stream, one can read one element, a number of
	    elements, or a line at a time.
	  </para>

          <dylangenericdef>
            <defname>read-element</defname>
	    <defadjectives>open</defadjectives>
	    <defsummary>Reads the next element from the stream.</defsummary>
	    <defparameters>
	      <param>
	        <paramname>stream</paramname>
		<paramtype>&lt;stream&gt;</paramtype>
              </param>
	      <keyparam>
	        <paramname>on-end-of-stream</paramname>
		<paramdefault>$not-supplied</paramdefault>
		<paramsummary>Value returned if reading past the stream.
		</paramsummary>
              </keyparam>
            </defparameters>
            <defreturns>
              <param>
                <paramname>element-or-eof</paramname>
              </param>
            </defreturns>
            <defdescription>
              <para>
                Reads the next element from the stream and advances
                the stream's position.</para>
	      <para>When the stream is past the end
                of the contents, two possible results occur.  If the
                caller supplied a value to the 
                <dlit>on-end-of-stream:</dlit> keyword, then that
                value is returned.  Otherwise,
                <dname>read-element</dname> throws an
                <dclass>end-of-stream-error</dclass>.
              </para>
            </defdescription>
          </dylangenericdef>

          <dylangenericdef>
            <defname>unread-element</defname>
	    <defadjectives>open</defadjectives>
	    <defsummary>Backs up the stream by one element.</defsummary>
	    <defparameters>
	      <param>
	        <paramname>stream</paramname>
		<paramtype>&lt;stream&gt;</paramtype>
              </param>
	      <param>
	        <paramname>elemnt</paramname>
		<paramsummary>What the previous element should be.
		</paramsummary>
              </param>
            </defparameters>
            <defreturns>
              <param>
                <paramname>the-elemnt</paramname>
              </param>
            </defreturns>
            <defdescription>
              <para>
                Backs up the stream by one element.  In some methods this
                function will ensure that
                <parameter>elemnt</parameter> is at the stream's
                position.  If it isn't then
                <dname>unread-element</dname> will signal an error.
                Otherwise, it will return <parameter>elemnt</parameter>.
              </para>
	      <note>
	        <para>
		  One must be careful about using <dlit>element</dlit>
		  as a variable name, for Dylan uses the function 
		  <dname>element</dname> to resolve element access of
		  sequences with the bracket syntax
		  (i.e. <dlit>[</dlit> and <dlit>]</dlit>).  Results
		  can be unpredicable when one has a local binding to
		  <dname>element</dname> and also indexes into
		  sequences with the bracket syntax.
		</para>
	      </note>
            </defdescription>
          </dylangenericdef>

          <dylangenericdef>
            <defname>peek</defname>
	    <defadjectives>open</defadjectives>
	    <defsummary>Retrieves the next element from the stream.</defsummary>
	    <defparameters>
	      <param>
	        <paramname>stream</paramname>
		<paramtype>&lt;stream&gt;</paramtype>
              </param>
	      <keyparam>
	        <paramname>on-end-of-stream</paramname>
		<paramdefault>$not-supplied</paramdefault>
		<paramsummary>Value returned if reading past the stream.
		</paramsummary>
              </keyparam>
            </defparameters>
            <defreturns>
              <param>
                <paramname>element-or-eof</paramname>
              </param>
            </defreturns>
            <defdescription>
              <para>
                Reads the next element from the stream but does not advance
                the stream's position.  Handles end-of-stream
                conditions just as <dname>read-element</dname> does.</para>
            </defdescription>
          </dylangenericdef>

          <dylangenericdef>
            <defname>read</defname>
	    <defadjectives>open</defadjectives>
	    <defsummary>Reads in a group of elements from a stream.</defsummary>
	    <defparameters>
	      <param>
	        <paramname>stream</paramname>
		<paramtype>&lt;stream&gt;</paramtype>
              </param>
	      <param>
	        <paramname>n</paramname>
		<paramtype>&lt;integer&gt;</paramtype>
		<paramsummary>Number of elements to read.</paramsummary>
              </param>
	      <keyparam>
	        <paramname>on-end-of-stream</paramname>
		<paramdefault>$not-supplied</paramdefault>
		<paramsummary>Value returned if reading past the stream.
		</paramsummary>
              </keyparam>
            </defparameters>
            <defreturns>
              <param>
                <paramname>sequence-or-eof</paramname>
              </param>
            </defreturns>
            <defdescription>
              <para>
                Reads in <parameter>n</parameter> elements from the
                stream starting from the
                the stream's current position.  The type of the
                collection returned depends on the collection
                underlying the stream.  Handles end-of-stream
                conditions just as <dname>read-element</dname> does.</para>
            </defdescription>
          </dylangenericdef>

          <dylangenericdef>
            <defname>read-into!</defname>
	    <defadjectives>open</defadjectives>
	    <defsummary>Reads a group of elements from a stream into a
	      collection.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>stream</paramname>
		<paramtype>&lt;stream&gt;</paramtype>
              </param>
	      <param>
	        <paramname>n</paramname>
		<paramtype>&lt;integer&gt;</paramtype>
		<paramsummary>Number of elements to read.</paramsummary>
              </param>
	      <param>
	        <paramname>sequence</paramname>
		<paramtype>&lt;mutable-sequence&gt;</paramtype>
		<paramsummary>Note: this sequence must allow for
		  changes in its size.
		</paramsummary>
              </param>
	      <keyparam>
	        <paramname>start</paramname>
		<paramdefault>0</paramdefault>
		<paramsummary>What index to start writing into the sequence.
		</paramsummary>
              </keyparam>
	      <keyparam>
	        <paramname>on-end-of-stream</paramname>
		<paramdefault>$not-supplied</paramdefault>
		<paramsummary>Value returned if reading past the stream.
		</paramsummary>
              </keyparam>
            </defparameters>
            <defreturns>
              <param>
                <paramname>count-or-eof</paramname>
		<paramsummary>Number of elements transferred.</paramsummary>
              </param>
            </defreturns>
            <defdescription>
              <para>
                Reads in <parameter>n</parameter> elements from the
                stream starting from the
                the stream's current position and places those
                elements into
                <parameter>sequence</parameter>.
                <parameter>Sequence</parameter> must be mutable to
                allow it to expand should the
                streamed in elements be larger than its original size.
                Handles end-of-stream 
                conditions just as <dname>read-element</dname> does.</para>
            </defdescription>
          </dylangenericdef>

          <dylangenericdef>
            <defname>discard-input</defname>
	    <defadjectives>open</defadjectives>
	    <defsummary>Discards the elements from the stream.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>stream</paramname>
		<paramtype>&lt;stream&gt;</paramtype>
              </param>
	    </defparameters>
	    &no-returns;
            <defdescription>
              <para>
                "Reads" in all the elements, and then discards them.
                The actual action depends on which method of this
                function does the work.  The default implementation
                does nothing, other implementations advance the
                stream's position to the end of the collection.
              </para>
            </defdescription>
          </dylangenericdef>

          <dylangenericdef>
            <defname>stream-input-available?</defname>
	    <defadjectives>open</defadjectives>
	    <defsummary>Checks the stream if it's available for reading.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>stream</paramname>
		<paramtype>&lt;stream&gt;</paramtype>
              </param>
	    </defparameters>
            <defreturns>
	      <param>
	        <paramname>input-available?</paramname>
		<paramtype>&lt;boolean&gt;</paramtype>
              </param>
            </defreturns>
            <defdescription>
              <para>
                Checks if the stream is available for reading.
              </para>
            </defdescription>
          </dylangenericdef>

	  <sect5 id="libs-streams-reg-general-fns-reading-handy">
	    <title>Convenience Reading Functions</title>
	    <para>
	       Conveniece functions for reading from streams.
	       These functions are implemented in terms of the more
	       primitive functions defined above.
	    </para>

            <dylanmethoddef>
              <defname>read-to</defname>
	      <defsummary>Reads in a group of elements from a stream up
	        to a marker element.
	      </defsummary>
	      <defparameters>
	        <param>
	          <paramname>stream</paramname>
		  <paramtype>&lt;stream&gt;</paramtype>
                </param>
	        <param>
	          <paramname>elemnt</paramname>
		  <paramsummary>The element to read up to.</paramsummary>
                </param>
	        <keyparam>
	          <paramname>on-end-of-stream</paramname>
		  <paramdefault>$not-supplied</paramdefault>
		  <paramsummary>Value returned if reading past the stream.
		  </paramsummary>
                </keyparam>
	        <keyparam>
	          <paramname>test</paramname>
		  <paramtype>&lt;function&gt;</paramtype>
		  <paramdefault>\==</paramdefault>
		  <paramsummary>Comparator for elemnt and the stream's contents.
		  </paramsummary>
                </keyparam>
              </defparameters>
              <defreturns>
                <param>
                  <paramname>sequence-or-eof</paramname>
                </param>
		<param>
		  <paramname>found?</paramname>
		  <paramtype>&lt;boolean&gt;</paramtype>
		</param>
              </defreturns>
              <defdescription>
                <para>
                  Reads in as many elements from the
		  stream starting from the
		  the stream's current position until it reaches
		  <parameter>elemnt</parameter>.  Returns the matching
		  sequence and &true; if <parameter>elemnt</parameter>
		  was in the stream.  If <dname>read-to</dname> does
		  not find <parameter>elemnt</parameter> (using the
		  function supplied to <dlit>test:</dlit>), it will
		  handle end-of-stream conditions as
		  <dname>read-element</dname>.</para>
              </defdescription>
            </dylanmethoddef>

            <dylanmethoddef>
              <defname>read-through</defname>
	      <defsummary>Reads in a group of elements from a stream up
	        to and including a marker element.
	      </defsummary>
	      <defparameters>
	        <param>
	          <paramname>stream</paramname>
		  <paramtype>&lt;stream&gt;</paramtype>
                </param>
	        <param>
	          <paramname>elemnt</paramname>
		  <paramsummary>The element to read up to.</paramsummary>
                </param>
	        <keyparam>
	          <paramname>on-end-of-stream</paramname>
		  <paramdefault>$not-supplied</paramdefault>
		  <paramsummary>Value returned if reading past the stream.
		  </paramsummary>
                </keyparam>
	        <keyparam>
	          <paramname>test</paramname>
		  <paramtype>&lt;function&gt;</paramtype>
		  <paramdefault>\==</paramdefault>
		  <paramsummary>Comparator for elemnt and the stream's contents.
		  </paramsummary>
                </keyparam>
              </defparameters>
              <defreturns>
                <param>
                  <paramname>sequence-or-eof</paramname>
                </param>
		<param>
		  <paramname>found?</paramname>
		  <paramtype>&lt;boolean&gt;</paramtype>
		</param>
              </defreturns>
              <defdescription>
                <para>
		  Just as <dname>read-to</dname>, but this function
		  also returns the marker element as part of the
		  sequence returned.
		</para>
              </defdescription>
            </dylanmethoddef>

	  </sect5>
	</sect4> 

	<sect4 id="libs-streams-reg-general-fns-writing">
	  <title>Writing Functions</title>
	  <para></para>
	</sect4> 

	<sect4 id="libs-streams-reg-general-fns-lines">
	  <title>Reading and Writing by Lines Functions</title>
	  <para></para>
	</sect4> 

        <sect4 id="libs-streams-reg-general-fns-querying">
         <title>Querying Functions</title>
         <dylangenericdef>
           <defname>stream-open?</defname>
           <defadjectives>open</defadjectives>
           <defsummary>Checks to see if a stream is open.</defsummary>
           <defparameters>
             <param>
               <paramname>stream</paramname>
               <paramtype>&lt;stream&gt;</paramtype>
             </param>
           </defparameters>
           <defreturns>
             <param>
               <paramname>open?</paramname>
               <paramtype>&lt;boolean&gt;</paramtype>
             </param>
           </defreturns>
           <defdescription>
             <para>
               If there's contents available for the stream, then it's open.
             </para>
           </defdescription>
         </dylangenericdef>
 
         <dylangenericdef>
           <defname>stream-element-type</defname>
           <defadjectives>open</defadjectives>
           <defsummary>Returns the type of elements streamed over.</defsummary>
           <defparameters>
             <param>
               <paramname>stream</paramname>
               <paramtype>&lt;stream&gt;</paramtype>
             </param>
           </defparameters>
           <defreturns>
             <param>
               <paramname>element-type</paramname>
               <paramtype>&lt;type&gt;</paramtype>
             </param>
           </defreturns>
           <defdescription>
             <para>
               For most streams, that are type-declarative (e.g. 
               <dclass>byte-string-stream</dclass>), this
               simply returns the underlying <parameter>element-type</parameter>.
               For generic <dclass>sequence</dclass>s, the method
               must have at least one element (the first) to return a type.
             </para>
           </defdescription>
         </dylangenericdef>
 
         <dylangenericdef>
           <defname>stream-at-end?</defname>
           <defadjectives>open</defadjectives>
           <defsummary>Sees if the stream is at the end.
           </defsummary>
           <defparameters>
             <param>
               <paramname>stream</paramname>
               <paramtype>&lt;stream&gt;</paramtype>
             </param>
           </defparameters>
           <defreturns>
             <param>
               <paramname>at-end?</paramname>
               <paramtype>&lt;boolean&gt;</paramtype>
             </param>
           </defreturns>
           <defdescription>
             <para>
               Checks to see if the stream is at the end of its contents.
             </para>
             <note><para>
               It is a bit faster to supply a value to the
               <dlit>on-end-of-stream</dlit> key for <dname>read</dname>
               or <dname>write</dname> than to use this function in a loop.
             </para></note>
           </defdescription>
         </dylangenericdef>
         </sect4>
 
         <sect4 id="libs-streams-general-fns-position">
           <title>Positioning Functions</title>
 
           <dylangenericdef>
             <defname>stream-position</defname>
             <defadjectives>open</defadjectives>
 	    <defsummary>Gives the position of a stream.</defsummary>
             <defparameters>
               <param>
                 <paramname>stream</paramname>
 		<paramtype>&lt;positionable-stream&gt;</paramtype>
               </param>
             </defparameters>
             <defreturns>
               <param>
                 <paramname>position</paramname>
 		<paramtype>type-union(&lt;stream-position&gt;, &lt;integer&gt;)
                 </paramtype>
               </param>
             </defreturns>
             <defdescription>
               <para>Safely returns the stream's position (even if it's locked).
               </para>
             </defdescription>
           </dylangenericdef>
 
           <dylangenericdef>
             <defname>stream-position-setter</defname>
             <defadjectives>open</defadjectives>
             <defsummary>Sets the position of a stream.</defsummary>
             <defparameters>
               <param>
                 <paramname>pos</paramname>
                 <paramtype>type-union(&lt;stream-position&gt;, &lt;integer&gt;,
 				      one-of(#"start", #"end"))
                 </paramtype>
               </param>
               <param>
                 <paramname>stream</paramname>
                 <paramtype>&lt;positionable-stream&gt;</paramtype>
               </param>
             </defparameters>
             <defreturns>
               <param>
                 <paramname>new-position</paramname>
                 <paramtype>type-union(&lt;stream-position&gt;, 
		 &lt;integer&gt;)
                 </paramtype>
               </param>
             </defreturns>
             <defdescription>
               <para>Sets the stream's position to a new absolute position.  
                 Allows <dlit>#"start"</dlit>,
                 <dlit>#"end"</dlit>, or a <dclass>stream-position</dclass>
 	        as the position-setter.
               </para>
             </defdescription>
           </dylangenericdef>
 
           <dylangenericdef>
             <defname>adjust-stream-position</defname>
             <defadjectives>open</defadjectives>
             <defsummary>Sets the relative position of a stream.</defsummary>
             <defparameters>
               <param>
                 <paramname>stream</paramname>
                 <paramtype>&lt;positionable-stream&gt;</paramtype>
               </param>
               <param>
                 <paramname>delta</paramname>
                 <paramtype>&lt;integer&gt;</paramtype>
                 <paramsummary>The distance to move.</paramsummary>
               </param>
               <keyparam>
                 <paramname>from</paramname>
                 <paramtype>one-of(#"current", #"start", #"end")</paramtype>
                 <paramsummary>The position from where to move.</paramsummary>
               </keyparam>
             </defparameters>
             <defreturns>
               <param>
                 <paramname>new-position</paramname>
                 <paramtype>type-union(&lt;stream-position&gt;, &lt;integer&gt;)
                 </paramtype>
                 <paramsummary>The new position in the stream.</paramsummary>
               </param>
             </defreturns>
             <defdescription>
               <para>Sets the stream's position to a new relative position,
                 either from the current position or from either end of the
                 stream.
               </para>
             </defdescription>
           </dylangenericdef>
 
           <dylangenericdef>
             <defname>stream-size</defname>
             <defadjectives>open</defadjectives>
             <defsummary>Returns the stream's size.</defsummary>
             <defparameters>
               <param>
                 <paramname>stream</paramname>
                 <paramtype>&lt;positionable-stream&gt;</paramtype>
              </param>
             </defparameters>
             <defreturns>
               <param>
                 <paramname>size</paramname>
                 <paramtype>&lt;integer&gt;</paramtype>
               </param>
             </defreturns>
             <defdescription>
               <para>Returns the size of the stream.
               </para>
             </defdescription>
           </dylangenericdef>
 
           <dylangenericdef>
             <defname>stream-contents</defname>
             <defadjectives>open</defadjectives>
             <defsummary>Returns the stream's contents.</defsummary>
             <defparameters>
               <param>
                 <paramname>stream</paramname>
                 <paramtype>&lt;positionable-stream&gt;</paramtype>
               </param>
               <keyparam>
                 <paramname>clear-contents?</paramname>
                 <paramtype>&lt;boolean&gt;</paramtype>
                 <paramsummary>If &true;, clear the stream after returning
                   the contents.</paramsummary>
               </keyparam>
             </defparameters>
             <defreturns>
               <param>
                 <paramname>contents</paramname>
                 <paramtype>&lt;sequence&gt;</paramtype>
               </param>
             </defreturns>
             <defdescription>
               <para>Returns the contents of the stream.
               </para>
             </defdescription>
           </dylangenericdef>
 
         </sect4>
         </sect3>

      </sect2>

      <sect2 id="libs-streams-ref-file">
        <title>File Stream Classes and Operations</title>
        <sect3 id="libs-streams-ref-file-class">
           <title>Class File-Stream</title>
        <dylanclassdef>
	  <dEFNAME>&lt;file-stream&gt;</dEFNAME>
	  <defadjectives>Open abstract</defadjectives>
	  <defsummary>
	    The class of streams over disk files.
	  </defsummary>
	  <defsupers>
            <defsuper>&lt;buffered-stream&gt;</defsuper>
            <defsuper>&lt;positionable-stream&gt;</defsuper>
          </defsupers>
          <definitkeywords>
            <keyparam>
              <paramname>locator</paramname>
              <paramtype>&lt;string&gt;</paramtype>
              <paramsummary>
                The file name.  If the <dlibrary>Locators</dlibrary>
                library is in use, locator should be an instance of
	        <dclass>locator</dclass> or a string that
	        can be coerced to one.
              </paramsummary>
            </keyparam>
            <keyparam>
	      <paramname>direction</paramname>
              <paramtype>
                one-of(#"input", #"output", #"input-output")
              </paramtype>
            </keyparam>
            <keyparam>
	      <paramname>if-exists</paramname>
              <paramtype>
                one-of(#f, #"new-version", #"overwrite", #"replace", #"append", #"truncate", #"signal")
              </paramtype>
              <paramsummary>
                An action to take if the file already exists.
              </paramsummary>
            </keyparam>
            <keyparam>
	      <paramname>if-does-not-exist</paramname>
              <paramtype>
                one-of(#f, #"signal", #"create")
              </paramtype>
              <paramsummary>
                An action to take if the file doesn't exists.
              </paramsummary>
            </keyparam>
            <keyparam>
	      <paramname>element-type</paramname>
              <paramtype>&lt;type&gt;</paramtype>
              <paramsummary>
                What kind of file (usually &lt;byte&gt; or &lt;byte-character&gt;).
              </paramsummary>
            </keyparam>
          </definitkeywords>
          <defdescription>
	    <PARA>When you instantiate this class, an
	    implementation-dependent, indirect instance of it is
	    created (from a call to <dname>type-for-file-stream</dname>). 
             The file being streamed over is opened
	    immediately upon creating the stream. </PARA>

          <PARA>File streams are intended only for accessing the
          contents of files. They are not intended to provide a
          general file handling facility of renaming, deleting,
          moving, parsing directory names and so on.  If you wish to do 
          these kinds of operations,
          use the <dlibrary>File-System</dlibrary> library instead.</PARA> 

	  <PARA>If an implementation checks file permissions when
	  creating and opening file streams, and it detects an attempt
	  to read a file for which the user has no read permission, or
	  to write a file for which the user has no write permission,
	  then an
	  <dclass>invalid-file-permissions-error</dclass>
	  condition is signalled at the time the file stream is
	  created.</PARA>

	  <PARA>Because creating a file stream always involves an
	  attempt to open the underlying file, the aforementioned
	  error conditions will occur during file stream instance
	  initialization.</PARA>

              <PARA>The <dlit>element-type</dlit> init-keyword
              specifies the type of the elements in the file named by
              locator. This allows file elements to be represented
              abstractly; for instance, contiguous elements could be
              treated as a single database record. This init-keyword
              defaults to something useful, potentially based on the
              properties of the file;
              <dclass>byte-character</dclass> and
              <dclass>unicode-character</dclass> are
              likely choices.</PARA>

	  <PARA>The optional <dkeyword>if-exists</dkeyword> init-keyword allows
	  you to specify an action to take if the file named by
	  <PARAMETER>locator</PARAMETER> already exists. The options
	  are:</PARA>

	  <itemizedlist>
	      <LISTITEM>
		<PARA>&false; -- No action. This is the 
                default when the stream's
		direction is <dlit>#"input"</dlit> or
		<dlit>#"input-output"</dlit>.</PARA>
	      </LISTITEM>
	      <LISTITEM>
		<PARA><dlit>#"new-version"</dlit> -- If the underlying 
                file system supports file
		versioning, a new version of the file is created. This
		is the default when the stream's direction is
		<dlit>#"output"</dlit>.</PARA>

		<PARA>If the file system does not support file
		versioning, the implementation should substitute one
		of the other <dlit>if-exists:</dlit> behaviors;
		the <dlit>#"replace"</dlit> behavior is a good
		choice. </PARA>
	      </LISTITEM>
	      <LISTITEM>
		<PARA><dlit>#"overwrite"</dlit> -- Set the stream's 
                position to the beginning of
		the file, but preserve the current contents of the
		file. This is useful when the direction is
		<dlit>#"input-output"</dlit> and you want to
		overwrite an existing file.</PARA>
	      </LISTITEM>
	      <LISTITEM>
		<PARA><dlit>#"replace"</dlit> -- Delete or rename the 
                existing file and create a new file.</PARA>
	      </LISTITEM>
	      <LISTITEM>
		<PARA><dlit>#"append"</dlit> -- Set the stream's 
                initial position to the end of
		the existing file so that all new output occurs at the
		end of the file.</PARA>
	      </LISTITEM>
	      <LISTITEM>
		<PARA><dlit>#"truncate"</dlit> -- If the file exists, 
                it is truncated, setting the
		size of the file to 0. If the file does not exist,
		create a new file.</PARA>
	      </LISTITEM>
	      <LISTITEM>
		<PARA><dlit>#"signal"</dlit> -- Signal a
		<dclass>file-exists-error</dclass>
		condition. </PARA>
	      </LISTITEM>
	  </itemizedlist>

	  <PARA>The optional <dlit>if-does-not-exist:</dlit> init-keyword
	  allows you to specify an action to take if the file named by
	  <PARAMETER>locator</PARAMETER> does not exist. The options
	  are:</PARA>

	  <itemizedlist>
	      <LISTITEM>
		<PARA>&false; -- No action.</PARA>
	      </LISTITEM>
	      <LISTITEM>
		<PARA><dlit>#"signal"</dlit> -- Signal a
		<dclass>file-does-not-exist-error</dclass>
		condition. This is the default when the stream's
		direction is <dlit>#"input"</dlit>.</PARA>
	      </LISTITEM>
	      <LISTITEM>
		<PARA><dlit>#"create"</dlit> -- Create a new zero-length 
                file. This is the
		default when the stream's direction is
		<dlit>#"output"</dlit> or
		<dlit>#"input-output"</dlit>.</PARA>
	      </LISTITEM>
	  </itemizedlist>
          </defdescription>
        </dylanclassdef>

        <para>There are some implementation and portability notes dealing
          with file streams, particularly dealing with the <dlit>element-type:</dlit>
          keyword.</para>

          <NOTE>
            <TITLE>Implementation Note</TITLE>

            <PARA>Ideally, element-type could be any valid Dylan type
            such as <dlit>limited(&lt;integer&gt;, min: 0, max:
            255)</dlit> or
            <dclass>unicode-character</dclass>. This
            approach may make it possible to implement a potentially
            inefficient but general set of file streams. Unfortunately
            the current language definition does not include adequate
            support for this approach, so we specify instead an
            interim minimum set of three element types. The element
            types are for the time being exported from the 
            <dmodule>streams</dmodule>
            module of the <dlibrary>Streams</dlibrary> library.</PARA>
          </NOTE>

          <PARA>The three possible element types are: </PARA>  
          <itemizedlist>
              <LISTITEM>
                <PARA><dclass>byte-character</dclass> -- The 
                  file is accessed as a sequence of 8-bit
                  characters.</PARA>
              </LISTITEM>
              <LISTITEM>
                <PARA><dclass>unicode-character</dclass> -- The 
                  file is accessed as a sequence of 16-bit Unicode
                  characters.</PARA>
              </LISTITEM>
              <LISTITEM>
                <PARA><dclass>byte</dclass> -- The file is 
                  accessed as a sequence of unsigned 8-bit
                  integers.</PARA>
              </LISTITEM>
          </itemizedlist>

          <NOTE>
            <TITLE>Portability Note</TITLE>

            <PARA>Portable code can count on the existence of these
            three element types, but implementations are free to
            provide more. </PARA>
          </NOTE>
	</sect3>
	<sect3 id="libs-streams-ref-file-fns">
            <title>File Stream Functions</title>
            <para>All the operations described in 
	     <xref linkend="libs-streams-ref-general-fns"> work with file streams.
               The following functions are specific to file streams.</para>
	
	<dylangenericdef>
	      <dEFNAME>type-for-file-stream</dEFNAME>
	  <defadjectives>open</defadjectives>
	      <defsummary>Returns the kind of file-stream class to
	      instantiate for a given file.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>locator</paramname>
	      <paramtype>type-union(&lt;locator&gt;, &lt;string&gt;)</paramtype>
	      <paramsummary>The file over which to stream</paramsummary>
	    </param>
	    <param>
	      <paramname>element-type</paramname>
	      <paramtype>false-or(&lt;type&gt;)</paramtype>
	      <paramsummary>The kind of file</paramsummary>
	    </param>
	    <param>
	      <paramname>encoding</paramname>
	      <paramtype>false-or(&lt;type&gt;)</paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>type</paramname>
	      <paramtype>&lt;type&gt;</paramtype>
	      <paramsummary>The file-stream type.</paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	      <PARA>The method for <dname>make</dname> on
	      <dclass>file-stream</dclass> calls this
	      function to determine the class of which it should
	      create an instance.</PARA>
	  </defdescription>
	</dylangenericdef>

             <dylanmacrodef>
               <defname>with-open-file</defname>
               <defadjectives>Statement</defadjectives>
 	      <defsummary>Works on an open file.</defsummary>
               <defparameters>
                 <varparam>
                   <variablename>stream</variablename>
                   <bindsto>name</bindsto>
                 </varparam>
                 <restparam>
                   <paramname>parameters</paramname>
                   <paramsummary>Arguments for <dname>make</dname> to open
                     the file.</paramsummary>
                 </restparam>
               </defparameters>
 	      <defdescription>
                 <para>
 		  Opens a file named <parameter>name</parameter>, giving the 
                   variable <parameter>stream</parameter> to
                   <parameter>body</parameter> to perform the stream operations.
                   It then closes the file when <parameter>body</parameter>
                   finishes.
                 </para>
                 <note><para>
 		  Only the <parameter>stream</parameter> variable is visible
 		  to <parameter>body</parameter>.  
 		  <parameter>Body</parameter> sees neither
 		  <parameter>name</parameter> nor 
 		  <parameter>parameters</parameter>.
                 </para></note>
                 <para>
 		  For example, the below code snippet looks for someone with
                   Dylan in their resume:
                 </para>
                 <programlisting>
let line = "";
let dylan-experience = #f;
 
with-open-file(file = "resume.txt")
  while(line & ~ dylan-experience)
    dylan-experience := regexp-position(line, "dylan");
    line := read-line(file, on-end-of-stream: #f);
  end while;
end;
 
format-out(if(dylan-experience) 
            "Hire this person now!\n" 
           else 
            "Try someone else\n"
           end if);</programlisting>
 
 	      </defdescription>
           </dylanmacrodef>

          </sect3>
	</sect2>

    </SECT1>
  </CHAPTER>

  <chapter id="libs-standard-io">
    <title> The Standard-IO Library </title>
     <sect1 id="libs-standard-io-standard-io">
      <title> The Standard-IO Library </title>
      <para>
        The <dmodule> standard-IO </dmodule> module of the
        <dlibrary> standard-IO </dlibrary> library exports
        three names for the standard input, output, and error
        streams.
      </para>
  
      <dylanconstantdef>
        <defname> *standard-error* </defname>
        <defsummary>
          The <dclass>stream</dclass> instance corresponding
          to the standard error.
        </defsummary>
        <deftype>
          &lt;stream&gt;
        </deftype>
        <defdescription>
          <para>
            The standard error <dclass>stream</dclass>.
            This usually represents the terminal; however most UNIX-like
            operating systems permit the standard error stream to be
            redirected at the command line.
          </para>
        </defdescription>
      </dylanconstantdef>
  
      <dylanconstantdef>
        <defname> *standard-input* </defname>
        <defsummary>
          The <dclass>stream</dclass> instance corresponding
          to the standard input.
        </defsummary>
        <deftype>
          &lt;stream&gt;
        </deftype>
        <defdescription>
          <para>
            The standard input <dclass>stream</dclass>.
            Usually, this stream reads from the terminal for its data;
            however most UNIX-like operating systems permit the standard
            input stream to be redirected at the command line.
          </para>
        </defdescription>
      </dylanconstantdef>
  
      <dylanconstantdef>
        <defname> *standard-output* </defname>
        <defsummary>
          The <dclass>stream</dclass> instance corresponding
          to the standard output.
        </defsummary>
        <deftype>
          &lt;stream&gt;
        </deftype>
        <defdescription>
          <para>
            The standard output <dclass>stream</dclass>.
            This usually represents the terminal (just like <dname>
            *standard-error* </dname>); however most UNIX-like operating
            systems permit the standard output stream to be redirected
            at the command line.
          </para>
        </defdescription>
      </dylanconstantdef>
    </sect1>
  </chapter>

  <chapter id="libs-format">
    <title>The Format Library</title>
    <para>
      The Format library provides a way to control output to a stream.
    </para>

    <sect1 id="libs-format-format">
      <title> The Format Module </title>
  
      <dylangenericdef>
        <defname> format </defname>
        <defsummary> Format a string and write it to a stream.  </defsummary>
        <defparameters>
          <param>
            <paramname> stream </paramname>
            <paramtype>&lt;stream&gt;</paramtype>
          </param>
          <param>
            <paramname> control-string </paramname>
            <paramtype>&lt;string&gt;</paramtype>
          </param>
          <restparam>
            <paramname> args </paramname>
            <paramsummary>
              The objects to substitute for the format fields.
            </paramsummary>
          </restparam>
        </defparameters>
	&no-returns;
        <defdescription>
          <para>
            The <dname>format</dname> function takes a control string,
            formats according to the format directives embedded in the string,
            and then writes the result to the <dname>stream</dname> argument.
          </para>
          <para>
            The format codes accepted by <dname>format</dname> are
            described in the format directives section. 

<!-- Manuals?  We no need no STINKING manuals! 
old text: on page 113 in Chapter 7 of the Dylan Reference
            Manual, in the section "Condition Messages." -->
	    
          </para>
        </defdescription>
      </dylangenericdef>
      
      <dylanmethoddef>
        <defname>format</defname>
        <defsummary> Format a string and write it to a stream.  </defsummary>
        <defparameters>
          <param>
            <paramname> stream </paramname>
            <paramtype>&lt;stream&gt;</paramtype>
          </param>
          <param>
            <paramname> control-string </paramname>
            <paramtype>&lt;string&gt;</paramtype>
          </param>
          <restparam>
            <paramname>args</paramname>
            <paramsummary>
              The objects to substitute for the format fields.
            </paramsummary>
          </restparam>
        </defparameters>
	&no-returns;
        <defdescription>
          <para>
            The default <dname>format</dname> method, specialized on
            the <dclass>stream</dclass> class.
          </para>
        </defdescription>
      </dylanmethoddef>
      
      <dylanfunctiondef>
        <defname>format-to-string</defname>
        <defsummary>
          Process a format-string and return the result as another string.
        </defsummary>
        <defparameters>
          <param>
            <paramname> control-string </paramname>
            <paramtype>&lt;string&gt;</paramtype>
          </param>
          <restparam>
            <paramname> args </paramname>
            <paramsummary>
              The objects to substitute for the format fields.
            </paramsummary>
          </restparam>
        </defparameters>
        <defreturns>
          <param>
            <paramname> result </paramname>
            <paramtype>&lt;string&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
            This function effectively calls <dname>format</dname> and
            returns the <dname>result</dname> as a string.
          </para>
        </defdescription>
      </dylanfunctiondef>      
      
      <dylangenericdef>
        <defname> print-message </defname>
        <defadjectives>
          Open
        </defadjectives>
        <defsummary>
          This method is called to format objects for the <dlit>"%s"</dlit>
          and <dlit>"%c"</dlit> format operators, in a form suitable for
          human readers.
        </defsummary>
        <defparameters>
          <param>
            <paramname>object</paramname>
            <paramtype>&lt;object&gt;</paramtype>
          </param>
          <param>
            <paramname>stream</paramname>
            <paramtype>&lt;stream&gt;</paramtype>
          </param>
        </defparameters>
	&no-returns;
        <defdescription>
          <para>
            Prints <dname>object</dname> to <dname>stream</dname>. This
            generic function is intended to define the human-readable
            printing behavior of a Dylan object, as opposed to their
            representation as literal syntax. Calling this function on
	    <dclass>condition</dclass> should result in
	    a error message, rather than the name of the instance and
	    its class, for example. (Contrast this behavior with the 
	    <dname> print </dname> function in the
	    <dlibrary>Print</dlibrary> library.)
          </para>
          <para>
            Predefined methods exist for the 
            <dname> &lt;string&gt; </dname>, 
            <dname> &lt;character&gt; </dname>, 
            <dname> &lt;condition&gt; </dname>, and 
            <dname> &lt;symbol&gt; </dname>  classes.
          </para>
        </defdescription>
      </dylangenericdef>
    </sect1>

    <sect1 id="libs-format-directives">
    <title>Format Directives</title>
    <para>
      The format directives are described below:
    </para>

    <para>
      Directive -- Argument Type -- Textual Format
    </para>
    <itemizedlist>
      <listitem>
        <para>
          %d -- <dclass>integer</dclass> --
          decimal number
        </para>
      </listitem>
      <listitem>
        <para>
          %b -- <dclass>integer</dclass> --
          binary number
        </para>
      </listitem>
      <listitem>
        <para>
          %o -- <dclass>integer</dclass> --
          octal number
        </para>
      </listitem>
      <listitem>
        <para>
          %x -- <dclass>integer</dclass> --
          hexadecimal number
        </para>
      </listitem>
      <listitem>
        <para>
          %c -- <dclass>character</dclass> --
          character (with no quotes)
        </para>
      </listitem>
      <listitem>
        <para>
          %s -- <dclass>string</dclass> --
          string (with no quotes)
        </para>
      </listitem>
      <listitem>
        <para>
          %s -- <dclass>condition</dclass> --
          condition message (with no quotes)
        </para>
      </listitem>
      <listitem>
        <para>
          %= -- <dclass>object</dclass> --
          unspecified, but works with any object
        </para>
      </listitem>
      <listitem>
        <para>
          %% -- none -- literal %
        </para>
      </listitem>
      <listitem>
        <para>
          %m -- <dclass>function</dclass> --
          a function that accepts the stream as an argument and
          performs user-defined operations on the stream
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The last format directive (%m) is specific to
      GwydionDylan.  See the below examples for
      using some of the format directives.
    </para>
    <sect2 id="libs-format-simple-example">
      <title>Simple Example</title>
      <para>
        Here we use three format directives to print the
        following message:
      </para>
      <programlisting>
Hello, my name is Doug Auclair, and I'm 33 years old.
      </programlisting>
      <para>
        The code to generate the above message is:
      </para>
      <programlisting>
format(*standard-output*, "Hello, my name is %s, and I'm %d years old.%c",
       "Doug Auclair", 33, '\n');
      </programlisting>
      <para>
        Note: sending the new-line character (<dlit>'\n'</dlit>) works as expected
        on supported platforms, but some systems that require a <dlit>"\r\n"</dlit>
        or a <dlit>"\n\r"</dlit> pair for a <dname>new-line</dname> command may have problems.
        The preferred way to write the above code is:
      </para>
      <programlisting>
format(*standard-output*, "Hello, my name is %s, and I'm %d years old.\n",
       "Doug Auclair", 33);
      </programlisting>
    </sect2>
    
    <sect2 id="libs-format-example-using-m">
      <title>Examples Using the %m Directive</title>
      <para>
        Below are two examples that use the %m directive (and others)
        to format messages for display.
      </para>
      
      <sect3 id="libs-format-example-using-m-simple">
        <title>Simple Example Using the %m Directive</title>
	<para>
	  Instead of feeding the (in some cases, troublesome) '\n'
	  character to the %c directive, let us explicitly use the
	  <dname>new-line</dname> (a function in the
	  <dlibrary>Streams</dlibrary> library) in concert with the %m
	  directive, like this:
	</para>
	<programlisting>
format(*standard-output*, "Hello, my name is %s, and I'm %d years old.%m",
       "Doug Auclair", 33, new-line);
        </programlisting>
	<para>
	  The above code produces the same output as the simple
	  example given previously.
	</para>
	<para>
	  Interestingly, Dylan automatically
	  converts <dlit>'\n'</dlit> characters in the control string to calls to
	  <dname>new-line</dname>.   (So, neither <dlit>"%m"</dlit> => <dname>new-line</dname>
	  nor <dlit>"%c"</dlit> => <dlit>'\n'</dlit> mappings are necessary ... Dylan takes care
	  of that).
	</para>
      </sect3>
      
      <sect3 id="libs-format-example-using-m-complex">
        <title>Complex Example Using the %m Directive</title>
        <para>
          Here we generate almost the same message, this time with a
	  little more information (the current time in Washington D.C.)
	  using the <dlit>"%m"</dlit> format directive.  The new message is:
	</para>
	<programlisting>
Hello, my name is Doug Auclair, and as of
now, November 17, 2000 09:28 PM, I'm 33 years old.
        </programlisting>
        <para>
          To get the above message, we must first create a function that
	  manipulates a <dclass>decoded-time</dclass>
	  (See <xref linkend="libs-time-time"> and <xref
	  linkend="libs-time-timeio">) as we desire
	  for the output:
	</para>
	<programlisting>
define function human-readable-time(stream :: &lt;stream&gt;,  
                                    time :: &lt;decoded-time&gt;)
 => ()
    format-time(stream, "%B %d, %Y %H:%M %p", time);
end function human-readable-time;
        </programlisting>
	<para>
          Then we use that function as an argument to the %m directive
	  to produce the message:
	</para>
	<programlisting>
format(*standard-output*, "Hello, my name is %s, and as of\n"
                          "now, %m, I'm %d years old\n",
       "Doug Auclair", 
       rcurry(human-readable-time, get-current-time(timezone: 5 * 3600)),
       33);
        </programlisting>
	<para>
          There are several things of note in the above example.
	</para>
	<itemizedlist>
          <listitem>
	    <para>
	      First, a short-hand for <dname>format(*standard-output*,
	      ...</dname> is the <dname>format-out</dname> function
	      found in <xref linkend="libs-format-out-fn">.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Second, two strings placed side-by-side (no commas) are
	      concatenated, so
	    </para>
	    <programlisting>
format(*standard-output*, "%s " "was " "here.\n", "Doug");
            </programlisting>
	    <para>
	      is the same as
	    </para>
	    <programlisting>
format(*standard-output*, "%s was here.\n", "Doug");
            </programlisting>
	  </listitem>
	  <listitem>
	    <para>
              Third, <dname>rcurry</dname> is a function that takes a
	      function and various arguments to create a new function.  A
	      description of it is available in the &drm; (page 349).
	      In this case, <dname>rcurry</dname> takes the
	      function we created
	      (<dname>human-readable-time</dname>) and the
	      result of <dname>get-current-time</dname> (a
	      function in the <dmodule>Time</dmodule> module, that,
	      here, sets the timezone to Z+5 (hours), or Eastern
	      Standard Time) as an argument that creates a new
	      function that expects a
	      <dclass>stream</dclass> instance to do its
	      work. 
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Fourth, note that in the control string I use <dlit>'\n'</dlit>
	      characters.  This is the preferred, and simplest, way to
	      request a new-line.
	    </para>
	  </listitem>
        </itemizedlist>
        <para>
          With the above points in mind, one can use the %m directive to
	  integrate complex stream manipulation with the
	  <dname>format</dname> function.
	</para>
      </sect3>
    </sect2>
  </sect1>
	    
  </chapter>

  <CHAPTER ID="libs-format-out">
    <TITLE>The Format-Out Library</TITLE>

    <PARA>
      The <dlibrary>Format-Out</dlibrary> library is designed to
      provide a simple interface to the <dlibrary>Format</dlibrary>
      library. It exports the module <dmodule>Format-Out</dmodule> and
      re-exports the <dmodule>Format</dmodule> and
      <dmodule>Standard-IO</dmodule> modules from the
      <dlibrary>Format</dlibrary> and <dlibrary>Standard-IO</dlibrary>
      libraries respectively.
    </PARA>

    <sect1 id="libs-format-out-fn">
      <title>The Format-Out Module</title>
      <para>
        The Format-Out module
	exports one function <dname>format-out</dname>.
      </para>
 
      <dylanmethoddef>
        <defname>format-out</defname>
	<defsummary>
	  Formats arguments to <dlit>*standard-output*</dlit>.
	</defsummary>
	<defparameters>
	  <param>
	    <paramname>control-string</paramname>
	    <paramtype>&lt;string&gt;</paramtype>
	  </param>
	  <restparam>
	    <paramname>args</paramname>
            <paramsummary>
              The objects to substitute for the format fields.
            </paramsummary>
          </restparam>
        </defparameters>
	&no-returns;
        <defdescription>
          <para>Performs</para>
	<PROGRAMLISTING>
apply(format, *standard-output*, control-string, args);</PROGRAMLISTING>
        </defdescription>
      </dylanmethoddef>
    </sect1>
  </CHAPTER>

  <CHAPTER ID="libs-print">
    <docinfo>
	<title>Print Library</title>
	<date>November 18, 2000</date>
	<author>&person.auclair;</author>
    </docinfo>
    <TITLE>The Print Library</TITLE>
    <PARA>
      The <dlibrary>Print</dlibrary> library was designed by the
      Gwydion Project at Carnegie Mellon University. This library
      provides an interface that outputs an object in Dylan literal
      syntax if the object can be represented as a Dylan literal, and
      otherwise, outputs the object in an implementation-dependent
      manner. There are essentially two functions,
      <dname>print</dname> and
      <dname>print-object</dname>. The <dname>print</dname>
      function accepts keyword arguments that form a print request,
      controlling features such as circular printing, how deep within a
      data structure to print, how many elements in long sequences to
      print before using an ellipsis notation, whether pretty printing
      is desired, and so on. Users extend
      <dname>print</dname>'s ability to print various objects
      by adding methods to the <dname>print-object</dname>
      function. The <dname>print</dname> function handles most of
      the overhead to satisfy special print requests, outputting any
      special notations required, and it only calls
      <dname>print-object</dname> when it is necessary to print
      objects. Users should always call the <dname>print</dname>
      function to output objects, especially recursively from within
      <dname>print-object</dname> methods to output an object's
      components. Users should never call
      <dname>print-object</dname> directly.
    </PARA>

    <sect1 id="libs-print-print">
      <title>Print Module</title>
      <para>
        The <dmodule>Print</dmodule> module provides ways to print
        objects.  It also provides printing properties (depth,
        circular, etc), and inspection of those properties.
      </para>
      <dylanmethoddef>
        <defname>print</defname>
	<defsummary>Prints an object on a stream</defsummary>
	<defparameters>
          <param>
            <paramname>object</paramname>
          </param>
          <param>
            <paramname>stream</paramname>
            <paramtype>&lt;stream&gt;</paramtype>
          </param>
	  <keyparam>
	    <paramname>level</paramname>
	    <paramtype>&lt;integer-or-false-or-not-supplied&gt;</paramtype>
	    <paramdefault>$not-supplied</paramdefault>
	    <paramsummary>
	      Holds the maximum depth to which
	      the user wants recursive printing to go.
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>length</paramname>
	    <paramtype>&lt;integer-or-false-or-not-supplied&gt;</paramtype>
	    <paramdefault>$not-supplied</paramdefault>
	    <paramsummary>
	      Holds the maximum number of elements the user wants a
	      sequence to be printed.  This does not apply to some
	      sequences, such as strings. 
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>circle?</paramname>
	    <paramtype>&lt;boolean-or-not-supplied&gt;</paramtype>
	    <paramdefault>$not-supplied</paramdefault>
	    <paramsummary>
	      Defines print behavior when printing a circular list
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>pretty?</paramname>
	    <paramtype>&lt;boolean-or-not-supplied&gt;</paramtype>
	    <paramdefault>$not-supplied</paramdefault>
	    <paramsummary>
	      Whether the user wants pretty printing.
	    </paramsummary>
	  </keyparam>
        </defparameters>
	&no-returns;
        <defdescription>
          <para>
	    Prints <dlit>object</dlit> to <dlit>stream</dlit>
	    according to the print request 
	    formed by the keyed arguments. A first call to
	    <dname>print</dname> creates a printing stream to
	    represent the print request, and recursive calls to
	    <dname>print</dname> on this printing stream process the
	    keyed arguments differently (see below). There are inspection
	    functions for querying the print request (see their
	    descriptions below). When <dname>print</dname> actually
	    prints an object, it calls
	    <dname>print-object</dname>. Though the inspection
	    functions for querying the print request allow you to inspect
	    any parameter of the print request,
	    <dname>print-object</dname> methods should only need to
	    call <dname>print-length</dname>. All other aspects of
	    the print request are handled by
	    <dname>print</dname>. There is one exception which is
	    described in the <dmodule>PPrint</dmodule> module
	    (pretty-printing).
	  </para>
	  <para>
	    <dlit>Level</dlit> controls how deep into a nested data
	    structure to print. The value &false; indicates that there
	    is no limit. The default, <dname>*default-level*</dname>,
	    has no effect on recursive calls to
	    <dname>print</dname>. Recursive calls to
	    <dname>print</dname> may change the value of
	    <dname>print-level</dname> explicitly, but
	    <dname>print</dname> always uses a value to ensure
	    the print request formed by the first call to
	    <dname>print</dname> is never exceeded. For example,
	    if a first call to <dname>print</dname> set the
	    <dlit>level</dlit> to 5, and while at a depth of 3, a
	    recursive call specified a <dlit>level</dlit> of 4, the
	    recursive call would only descend 2 more levels, not 4.
	  </para>
	  <para>
	    <dlit>Length</dlit> controls how many elements of a
	    sequence to print before printing ellipsis notation
	    (<dlit>...</dlit>). The 
	    value &false; indicates that there is no limit. The
	    <dname>print-length</dname> control can be interpreted
	    loosely by some <dname>print-object</dname> methods
	    to control how many elements of any kind of object to
	    print; for example, the default
	    <dclass>object</dclass> method might regard
	    <dname>print-length</dname> to determine how many
	    slot-name/value pairs to print. The default,
	    <dname>*default-length*</dname>, has no effect on
	    recursive calls to <dname>print</dname>. Recursive
	    calls to <dname>print</dname> may change the value
	    of <dname>print-length</dname> explicitly, but they may only
	    decrease the value, never increase it.
	  </para>
	  <para>
	    <dlit>Circle?</dlit> indicates whether printing should
	    check all subcomponent references to make sure the printing
	    process does not infinitely recurse through a data
	    structure. Circular printing also tags objects that occur more
	    than once when they are first printed, and later occurrences
	    are printed as a reference to the previously emitted tag. The
	    default, <dname>*default-circle?*</dname>, has no effect on
	    recursive calls to <dname>print</dname>. If
	    <dname>print-circle?</dname> is already &true;, then it remains
	    &true; throughout all recursive calls. If
	    <dname>print-circle?</dname> is &false;, then recursive calls to
	    <dname>print</dname> can change the value to &true;;
	    however, when printing exits the dynamic scope of the call
	    that changed the value to &true;, the value reverts to
	    &false;. If the original call to
	    <dname>print</dname> specifies <dlit>circle?</dlit>
	    as &false;, and dynamically distinct recursive calls turn
	    circular printing on and off, all output generated while
	    circular printing was on shares the same tagging space;
	    that is, if <dlit>#1#</dlit> is printed twice, once from
	    each of two distinct recursive calls to
	    <dname>print</dname>, then each <dlit>#1#</dlit> is
	    guaranteed to signify the same <dname>\==</dname>
	    object.  
	  </para>
	  <para>
	    <dlit>Pretty?</dlit> indicates whether printing should
	    attempt to insert line breaks and indentation to format
	    objects according to how programmers tend to find it easier to
	    read data. The default, <dname>*default-pretty?*</dname>,
	    has no effect on recursive calls to
	    <dname>print</dname>. If
	    <dname>print-pretty?</dname> is already &true;, then it
	    remains &true; throughout all recursive calls. If
	    <dname>print-pretty?</dname> is &false;, then recursive
	    calls to <dname>print</dname> can change the value
	    to &true;; however, when printing exits the dynamic scope
	    of the call that changed the value to &true;, the value
	    reverts to &false;.
          </para>
        </defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>print-object</defname>
	<defsummary>The default way to print objects</defsummary>
	<defparameters>
	  <param>
	    <paramname>object</paramname>
	  </param>
	  <param>
            <paramname>stream</paramname>
            <paramtype>&lt;stream&gt;</paramtype>
          </param>
        </defparameters>
	&no-returns;
        <defdescription>
	  <para>
	    Users extend <dname>print</dname>'s ability to print
	    various objects by adding methods to the
	    <dname>print-object</dname> function.  When
	    <dname>print</dname> actually prints an object, it calls
	    <dname>print-object</dname>. Users should never call
	    <dname>print-object</dname>
	    directly. 
	  </para>
          <para>
	    Provides the printed object representation for
	    <dname>print</dname> and for the "%=" format
	    directive (see <xref linkend="libs-format-directives">).
	    Default <dname>print-object</dname> methods exist
	    for instances of <dclass>object</dclass>,
	    <dclass>character</dclass>,
	    <dclass>string</dclass>,
	    <dclass>list</dclass>,
	    <dclass>vector</dclass>,
	    <dclass>sequence</dclass>,
	    <dclass>array</dclass>,
	    <dclass>table</dclass>,
	    <dclass>range</dclass>,
	    <dclass>function</dclass>,
	    <dclass>singleton</dclass>,
	    <dclass>limited-integer</dclass>,
	    <dclass>union</dclass>,
	    <dclass>symbol</dclass>,
	    <dclass>general-integer</dclass>, 
	    <dclass>integer</dclass>, 
	    <dclass>ratio</dclass>,
	    <dclass>single-float</dclass>,
	    <dclass>double-float</dclass>,
	    <dclass>extended-float</dclass>, 
	    <dclass>class</dclass>, and for &true; and
	    &false;.
	  </para>
	  <para>
	    Users may choose to modify the printed representation in
	    two ways:  override the <dname>print-object</dname>
	    method for that instance's type, or provide a printing
	    function to the <dlit>"%m"</dlit> directive for
	    <dname>format</dname> or
	    <dname>format-out</dname>.
	  </para>
        </defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>print-to-string</defname>
	<defsummary>
	  Creates a string that contains a printed object representation 
	</defsummary>
	<defparameters>
          <param>
            <paramname>object</paramname>
          </param>
	  <keyparam>
	    <paramname>level</paramname>
	    <paramtype>&lt;integer-or-false-or-not-supplied&gt;</paramtype>
	    <paramdefault>$not-supplied</paramdefault>
	    <paramsummary>
	      Holds the maximum depth to which
	      the user wants recursive printing to go.
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>length</paramname>
	    <paramtype>&lt;integer-or-false-or-not-supplied&gt;</paramtype>
	    <paramdefault>$not-supplied</paramdefault>
	    <paramsummary>
	      Holds the maximum number of elements the user wants a
	      sequence to be printed.  This does not apply to some
	      sequences, such as strings. 
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>circle?</paramname>
	    <paramtype>&lt;boolean-or-not-supplied&gt;</paramtype>
	    <paramdefault>$not-supplied</paramdefault>
	    <paramsummary>
	      Defines print behavior when printing a circular list
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>pretty?</paramname>
	    <paramtype>&lt;boolean-or-not-supplied&gt;</paramtype>
	    <paramdefault>$not-supplied</paramdefault>
	    <paramsummary>
	      Whether the user wants pretty printing.
	    </paramsummary>
	  </keyparam>
        </defparameters>
        <defreturns>
	  <param>
	    <paramname>result</paramname>
	    <paramtype>&lt;byte-string&gt;</paramtype>
	  </param>
        </defreturns>
        <defdescription>
          <para>
	    Calls <dname>print</dname> to produce output
	    according to the print request formed by the keyed arguments
	    and returns the output as a string. 
	  </para>
        </defdescription>
      </dylanmethoddef>

      <para>
        The above <dname>print</dname> functions use or set the
        below exported variables to accomplish their work (&false;
        (the default value of all these variables) indicates there is
        no bounds for the variable):
      </para>

      <dylanvariabledef>
        <defname>*default-level*</defname>
	<defsummary>
	  Gives how far down recursively to print
	</defsummary>
	<deftype>false-or(&lt;integer&gt;)</deftype>
	<defdescription>
	  <para>
	    If a number is given, <dname>print</dname> prints a
	    <dlit>#</dlit> when it reached the level.
	  </para>
	</defdescription>
      </dylanvariabledef>

      <dylanvariabledef>
        <defname>*default-length*</defname>
	<defsummary>
	  How many elements to print of a sequence
	</defsummary>
	<deftype>false-or(&lt;integer&gt;)</deftype>
	<defdescription>
	  <para>
	    If a number is given, <dname>print</dname> prints a
	    <dlit>...</dlit> to indicate that it reached the maximum
	    number of printable elements.
	  </para>
	</defdescription>
      </dylanvariabledef>

      <dylanvariabledef>
        <defname>*default-circle?*</defname>
	<defsummary>
	  What to do for circular lists
	</defsummary>
	<deftype>&lt;boolean&gt;</deftype>
	<defdescription>
	  <para>
	    If on, prints identical objects as, e.g.: <dlit>#1#</dlit>	    
	  </para>
	</defdescription>
      </dylanvariabledef>

      <dylanvariabledef>
        <defname>*default-pretty?*</defname>
	<defsummary>
	  Formats outputted object
	</defsummary>
	<deftype>&lt;boolean&gt;</deftype>
	<defdescription>
	  <para>
	    If on, prints object indented with proper line breaks,
	    according to the formatting specifications given to
	    <dname>pprint-logical-block</dname>. 
	  </para>
	</defdescription>
      </dylanvariabledef>    

      <para>
        The below functions give printing information on
        <dclass>stream</dclass>s. It seems, however,
        that these functions are neither used nor implemented, as they
        all give &false; or <dlit>0</dlit> as their response, no matter the
        <dclass>stream</dclass>.
      </para>
      
      <dylanmethoddef>
        <defname>print-length</defname>
	<defsummary>Always returns &false;</defsummary>
	<defparameters>
	  <param>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	  </param>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>length</paramname>
	    <paramtype>false-or(&lt;integer&gt;)</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    Returns the current value for the print request. See the
	    <dname>print</dname> function for details.
	  </para>
	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>print-level</defname>
	<defsummary>Always returns &false;</defsummary>
	<defparameters>
	  <param>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	  </param>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>level</paramname>
	    <paramtype>false-or(&lt;integer&gt;)</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    Returns the current value for the print request. See the
	    <dname>print</dname> function for details. Users
	    should have little use for this function because
	    <dname>print</dname> takes care to call
	    <dname>print-object</dname> only when the print
	    level has not been exhausted. 
	  </para>
	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>print-depth</defname>
	<defsummary>Always returns <dlit>0</dlit></defsummary>
	<defparameters>
	  <param>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	  </param>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>depth</paramname>
	    <paramtype>&lt;integer&gt;</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    Returns the current depth to which printing has descended
	    into the object on which print was originally called. 
	    <dname>Print</dname> takes care to call
	    <dname>print-object</dname> only when the print
	    depth has not been exhausted. 
	  </para>
	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>print-pretty?</defname>
	<defsummary>Always returns &false;</defsummary>
	<defparameters>
	  <param>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	  </param>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>pretty?</paramname>
	    <paramtype>#f</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    Returns whether pretty printing is on. Users should have
	    little use for this function (see <xref
	    linkend="libs-print-pprint">).
	  </para>
	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>print-circle?</defname>
	<defsummary>Always returns &false;</defsummary>
	<defparameters>
	  <param>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	  </param>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>circle?</paramname>
	    <paramtype>#f</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    Returns whether circular printing is on. Users should have
	    little use for this function because
	    <dname>print</dname> takes care to detect
	    circularities, tag multiply referenced objects, and emit
	    tags rather than descending into objects to repeatedly
	    print them.
	  </para>
	</defdescription>
      </dylanmethoddef>
    </sect1>
    
    <sect1 id="libs-print-pprint">
      <title>PPrint Module</title>
      <para>
        The <dlibrary>Print</dlibrary> library implements most of the
	pretty printing technology described by Richard C. Waters in
	Common Lisp The Language, second edition. The interface is
	slightly different because Mindy does not have macros. This
	section only summarizes the pretty printing functionality to
	provide a quick reference for users of the
	<dlibrary>Print</dlibrary> library, and readers should refer
	to the Common Lisp manual for more details.  
      </para>
      <para>
        When writing <dname>print-object</dname> methods, users
	can ignore whether pretty printing is in effect. If you write
	your <dname>print-object</dname> method using pretty
	printing functions, then when pretty printing is in effect,
	the output will be pretty printed. When pretty printing is not
	in effect, your method will produce output as though you had
	not written it to use pretty printing. All
	<dname>print-object</dname> methods that are written to
	do pretty printing must call the pretty printing functions
	within the dynamic scope of a call to
	<dname>pprint-logical-block</dname>; otherwise, the
	pretty printing functions are no-ops.
      </para>

      <dylanvariabledef>
        <defname>*default-line-length*</defname>
	<defsummary>The length of a single line</defsummary>
	<deftype>&lt;integer&gt;</deftype>
	<defdescription>
	  <para>
	    This is the line length used by the pretty printer to
	    determine how much output will fit on a single line. 
	    It defaults to 80. 
	  </para>
	</defdescription>
      </dylanvariabledef>

      <dylanvariabledef>
        <defname>*print-miser-width*</defname>
	<defsummary>Controls miser mode for pretty printing</defsummary>
	<deftype>false-or(&lt;integer&gt;)</deftype>
	<defdescription>
	  <para>
	    Whenever a logical block (see
	    <dname>pprint-logical-block</dname>) begins in a
	    column of output that is greater than
	    <dname>*default-line-length*</dname> -
	    <dname>*print-miser-width*</dname>, then pretty printing
	    is in miser mode. The value must be an integer or &false;
	    (the default). &false; indicates that the pretty printer
	    should never enter miser mode.
	  </para>
	</defdescription>
      </dylanvariabledef>

      <dylanclassdef>
        <defname>&lt;pretty-stream&gt;</defname>
	<defadjectives>sealed</defadjectives>
	<defsummary>Stream used for pretty printing.</defsummary>
	<defsupers>
	  <defsuper>&lt;buffered-stream&gt;</defsuper>
	</defsupers>
	<definitkeywords>
	  <keyparam>
	    <paramname>target</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	    <paramsummary>
	      The stream where the output is finally going
	      to go.
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>line-length</paramname>
	    <paramtype>&lt;column&gt;</paramtype>
	    <paramdefault>*default-line-length*</paramdefault>
	    <paramsummary> 
	      The line length for this stream (0 minimum).
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>column</paramname>
	    <paramtype>&lt;column&gt;</paramtype>
	    <paramdefault>0</paramdefault>
	    <paramsummary> 
	      The column the first character in the buffer will appear
	      in.  Normally zero, but if we end up with a very long
	      line with no breaks in it we might have to output part of
	      it.  Then this will no longer be zero. 
	    </paramsummary>
	  </keyparam>
	</definitkeywords>
	<defdescription>
	  <para>
	    This is a working class for pretty-printing objects.  Use
	    an instance of this class when doing a great deal of
	    pretty printing.
	  </para>
	</defdescription>
      </dylanclassdef>

      <dylangenericdef>
        <defname>pprint-logical-block</defname>
	<defsummary>
	  Start a logical block, creating a pretty-stream if
	  necessary.
	</defsummary>
	<defparameters>
	  <param>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	  </param>
	  <keyparam>
	    <paramname>column</paramname>
	    <paramtype>&lt;integer&gt;</paramtype>
	  </keyparam>
	  <keyparam>
	    <paramname>prefix</paramname>
	    <paramtype>&lt;byte-string&gt;</paramtype>
	  </keyparam>
	  <keyparam>
	    <paramname>per-line-prefix</paramname>
	    <paramtype>&lt;byte-string&gt;</paramtype>
	  </keyparam>
	  <keyparam>
	    <paramname>body</paramname>
	    <paramtype>&lt;function&gt;</paramtype>
	  </keyparam>
	  <keyparam>
	    <paramname>suffix</paramname>
	    <paramtype>&lt;byte-string&gt;</paramtype>
	  </keyparam>
	</defparameters>
	&no-returns;
	<defdescription>
	  <para>
	    This function groups printing into a logical block. The
	    logical block provides boundaries for new levels of
	    indentation, affects <dlit>#"linear"</dlit> newlines, and
	    so on. <dlit>Prefix</dlit> is a string to print at the
	    beginning of the logical block. The blocks indentation is
	    automatically set to be one character position greater
	    than the column in which <dlit>prefix</dlit>
	    ends. Alternatively, <dlit>per-line-prefix</dlit> is a
	    string to print on every line of the logical block. This
	    function signals an error if it is called with both
	    <dlit>prefix</dlit> and <dlit>per-line-prefix</dlit>
	    supplied as non-&false;. <dlit>Suffix</dlit> is a string
	    to print at the end of the logical
	    block. <dlit>Column</dlit> advises the pretty printer as
	    to the current column of the output stream (defaults to
	    zero). The <dlit>column</dlit> argument may be ignored
	    entirely by some methods, and it may be ignored in some
	    cases by methods that can better determine the stream's
	    current output column. 
	  </para>
	  <para>
	    <dlit>Body</dlit> must be a
	    <dclass>function</dclass> that can take one
	    argument, and this argument is a
	    <dclass>stream</dclass>. The
	    <dlit>body</dlit> function should use the
	    <dlit>stream</dlit> argument passed to it; the
	    <dlit>body</dlit> function should not close over the
	    <dlit>stream</dlit> argument to
	    <dname>pprint-logical-block</dname>.
	    <dname>Pprint-logical-block</dname> wraps
	    <dlit>stream</dlit> with a pretty printing stream when
	    <dlit>stream</dlit> is any other kind of stream. If
	    <dlit>stream</dlit> is already a pretty printing stream,
	    then the <dlit>body</dlit> function is called on
	    <dlit>stream</dlit>.
	  </para>
	  <para>
	    All <dname>print-object</dname> methods that are
	    written to do pretty printing must call the other pretty
	    printing functions within the dynamic scope of a call to
	    <dname>pprint-logical-block</dname>; otherwise, the
	    pretty printing functions are no-ops.
	  </para>
	</defdescription>
      </dylangenericdef>

      <dylanmethoddef>
        <defname>pprint-newline</defname>
	<defsummary>
	  Output a conditional newline of some kind.  If
	  called on a regular stream, ignore it.
	</defsummary>
	<defparameters>
	  <param>
	    <paramname>kind</paramname>
	    <paramtype>&lt;pretty-newline-kind&gt;</paramtype>
	  </param>
	  <param>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	  </param>
	</defparameters>
	&no-returns;
	<defdescription>
	  <para>
	    This function announces a conditional newline to the
	    pretty printer. The pretty printer emits a newline
	    depending on the <dlit>kind</dlit> and the state of the
	    pretty printer's current line buffer. The kind argument
	    has roughly the following meanings:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para>
	        <dlit>#"fill"</dlit>: Emit a newline if the current
	        <dlit>section</dlit> of output does not fit on one
	        line.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        <dlit>#"linear"</dlit>: Emit a newline if any
	        <dlit>#"linear"</dlit> newline in the current section
	        needs to be emitted.  That is, if a current section of
	        output cannot fit on one line, and any one of the
	        <dlit>#"linear"</dlit> newlines in the section needs
	        to be emitted, then emit them all.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        <dlit>#"miser"</dlit>: Emit a newline as if it were a
	        <dlit>#"linear"</dlit> newline, but only when <dlit>miser
	        mode</dlit> is in effect. Miser style is in effect when a
	        logical block starts past a particular column of
	        output.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        <dlit>#"mandatory"</dlit>: Emit a newline
	        always. Establish that any containing sections cannot
	        be printed on a single line so that
	        <dlit>#"linear"</dlit> and <dlit>#"miser"</dlit>
	        newlines will be emitted as appropriate.
	      </para>
	    </listitem>
	  </itemizedlist>
	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>pprint-indent</defname>
	<defsummary>
	  Change the indentation.  If called on a regular stream, just
	  ignore it.
	</defsummary>
	<defparameters>
	  <param>
	    <paramname>relative-to</paramname>
	    <paramtype>&lt;indentation-kind&gt;</paramtype>
	  </param>
	  <param>
	    <paramname>n</paramname>
	    <paramtype>&lt;integer&gt;</paramtype>
	  </param>
	  <param>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	  </param>
	</defparameters>
	&no-returns;
	<defdescription>
	  <para>
	    This function specifies the indentation to use within the
	    current logical block. When <dlit>relative-to</dlit> is
	    <dlit>#"block"</dlit>, then
	    <dname>pprint-indent</dname> sets the indentation to
	    the column of the first character of the logical block
	    plus <dlit>n</dlit>. When <dlit>relative-to</dlit> is
	    <dlit>#"current"</dlit>, then
	    <dname>pprint-indent</dname> sets the indentation to
	    the current column plus <dlit>n</dlit>.
	  </para>
	</defdescription>
      </dylanmethoddef>


      <dylanmethoddef>
        <defname>pprint-tab</defname>
	<defsummary>
	  Output a tab.  If called on a regular stream, ignore it.
	</defsummary>
	<defparameters>
	  <param>
	    <paramname>kind</paramname>
	    <paramtype>&lt;tab-kind&gt;</paramtype>
	  </param>
	  <param>
	    <paramname>colnum</paramname>
	    <paramtype>&lt;integer&gt;</paramtype>
	  </param>
	  <param>
	    <paramname>colinc</paramname>
	    <paramtype>&lt;integer&gt;</paramtype>
	  </param>
	  <param>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	  </param>
	</defparameters>
	&no-returns;
	<defdescription>
	  <para>
	    This function announces a tab to the pretty
	    printer. <dlit>Colnum</dlit> and <dlit>colinc</dlit> have
	    meaning based on the value of <dlit>kind</dlit>: 
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para>
	        <dlit>#"line"</dlit>: Tab to output column
	        <dlit>colnum</dlit>. If the output is already at or
	        beyond <dlit>colnum</dlit>, then add
	        <dlit>colinc</dlit> to <dlit>colnum</dlit> until
	        printing can continue at a column beyond the end of
	        the output already on the line. 
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        <dlit>#"line-relative"</dlit>: Output
	        <dlit>colnum</dlit> spaces. Then output enough spaces
	        to tab to a column that is a multiple of
	        <dlit>colinc</dlit> from the beginning of the line.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        <dlit>#"section"</dlit>: This is similar to
	        <dlit>#"line"</dlit>, but column counting is relative
	        to the beginning of the current section rather than
	        the beginning of the line.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        <dlit>#"section-relative"</dlit>: This is similar to
	        <dlit>#"line-relative"</dlit>, but column counting is
	        relative to the beginning of the current section
	        rather than the beginning of the line.
	      </para>
	    </listitem>
	  </itemizedlist>
	</defdescription>
      </dylanmethoddef>

    </sect1>
  </CHAPTER>

  <CHAPTER ID="libs-collection-extensions">
    <docinfo>
      <title>Collection Extentions</title>
	<date>November 18, 2000</date>
	<author>&person.auclair;</author>
    </docinfo>
    <TITLE>The Collection-Extensions Library</TITLE>
    <sect1 id="libs-collection-extensions-introduction">
	<title>Introduction</title>
	<PARA>
	  The various modules in this library contain a few new types
	  and operations which are compatible with the collection
	  types specified in the &drm;, but which are not part of that
	  specification.  
	</para>
	<para>
	  It is to be expected that more collection types will appear
	  in time, and they will likely be added to this library. This
	  may also result in reorganizations which could force
	  incompatible changes to the existing modules. We hope to
	  minimize such imcompatibilities and, when forced to them,
	  will include sufficient information to facilitate conversion
	  of existing code. 
	</para> 
	<para>
	  Collection-extensions exports these modules: 
	</para>
	<itemizedlist>
	  <listitem>
	    <para>
	      <dmodule>self-organizing-list</dmodule>
	      Provides "self-organizing lists". These explicit key
	      collections provide roughly the semantics of hash
	      tables, but use a probabilistic implementation which
	      provides O(n) worst case performance but can provide
	      very fast constant time access in the best case. 
	    </para> 
	  </listitem>
	  <listitem>
	    <para><dmodule>subseq</dmodule>
	    Provides "subsequences", which represent an aliased
	    reference to some part of an existing sequence. These are
	    analogous to slices (in Ada or Perl) or displaced arrays
	    (in Common Lisp). Subsequences are themselves subclasses
	    of <dclass>sequence</dclass>, and can
	    therefore be passed any
	    <dclass>collection</dclass> or
	    <dclass>sequence</dclass> operation. 
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <dmodule>vector-search</dmodule>
	    Provides a small assortment of specialized operations for
	    searching and modifying
	    <dclass>vector</dclass>s. These operations are
	    analogous to existing collection operations but provide
	    keywords and efficiency improvements which are meaningful
	    only within the more limited domain.  
	  </PARA>
	</listitem>
      </itemizedlist>
      <para>
        The Collections-Extensions Library also has some additional
        modules added by the GwydionDylan Maintainers.  These modules
        are: 
      </para>
      <itemizedlist>
        <listitem>
	  <para>
	    <dmodule>heap</dmodule> was supposed to implement a
	    priority queue, but because of conflicts with
	    <dclass>deque</dclass> methods,
	    <dmodule>heap</dmodule> is currently empty. 
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <dmodule>sequence-diff</dmodule> implements the Unix diff
	    utility algorithm
	  </para> 
	</listitem>
	<listitem>
	  <para>
	    <dmodule>Sequence-Utilities</dmodule> provides useful
	    methods on collections, written by Matthias Hlzl.
	  </para> 
	</listitem>
      </itemizedlist>
    </sect1>
    <sect1 id="libs-collection-extensions-organized-list">
	<title>Module self-organizing-list</title>
	<para>
	  The "Self Organizing List" is a poor man's hash
	  table. More precisely,
	  <dclass>self-organizing-list</dclass> is a
	  subclass of
	  <dclass>mutable-explicit-key-collection</dclass>
	  and <dclass>stretchy-collection</dclass> for
	  which addition and retrieval are both linear in the worst
	  case, but which use a probabilistic strategy which yields
	  nearly constant time in the best case.  
	</para>
	<para>
	  Because they have a very low overhead, self-organizing lists
	  may provide better peformance than hash tables in cases
	  where references have a high degree of temporal
	  locality. They may also be useful in situations where it is
	  difficult to create a proper hash function.  
	</para>
	<para>
	  Instantiate
	  <dclass>self-organizing-list</dclass>s with  
	</para>
<programlisting>
make(&lt;self-organizing-list&gt;, test: test)
</programlisting>
        <para>
	  <dlit>Test</dlit> is expected to be an equality function. In
	  particular, it is expected to satisfy the identity and
	  transitivity requirements as described in the &drm;. If not
	  specified, <dlit>test</dlit> defaults to
	  <dname>\==</dname>.  
	</para>
    </sect1>
    <sect1 id="libs-collection-extensions-subseq">
	<title>Module subseq</title>
	<para>
	  <dclass>Subsequence</dclass> is a new subclass
	  of <dclass>sequence</dclass>. A subsequence
	  represents an aliased reference to some part of an existing
	  sequence. Although they may be created by
	  <dname>make</dname> (with required keywords
	  <dlit>source:</dlit>, <dlit>start:</dlit> and
	  <dlit>end:</dlit>) on one of the instantiable subclasses,
	  they are more often created by calls of the form 
	</para> 
<programlisting>
subsequence(sequence, start: 0, end: 3)
</programlisting>
        <para>
	  where <dlit>start:</dlit> and <dlit>end:</dlit> are optional
	  keywords which default to the beginning and end,
	  respectively, of the source sequence. No other new
	  operations are defined for subsequences, since all necessary
	  operations are inherited from
	  <dclass>sequence</dclass>.  
	</para>
	<para>
	  Because subsequences are aliased references into other
	  sequences, several properties must be remembered:  
	</para>
	<itemizedlist>
	  <listitem>
	    <para>
	      The contents of a subsequence are undefined after any
	      destructive operation upon the source sequence.  
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Destructive operations upon subsequences may be
	      reflected in the source. The results of
	      <dname>reverse!</dname> and
	      <dname>sort!</dname> should be expected to affect
	      the source sequence for vector subsequences.  
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  If the source sequences are instances of
	  <dclass>vector</dclass> or
	  <dclass>string</dclass>, then the implementation
	  will use subclasses of
	  <dclass>subsequence</dclass> which are also
	  subclasses of <dclass>vector</dclass> or
	  <dclass>string</dclass>.  
	</para>
	<para>
	  Efficiency notes: 
	</para>
	<itemizedlist>
	  <listitem>
	    <para>
	      The implementation tries to insure that subsequences of
	      subsequences can be accessed as efficiently as the
	      original subsequence. (For example, the result of  
	    </para>
<programlisting>
subsequence(subsequence(source, start: 1), start: 2)
</programlisting>
            <para>
	      would produce a subsequence identical to the one produced by 
	    </para>
<programlisting>
subsequence(source, start: 3)
</programlisting>
          </listitem>
	  <listitem>
	    <para>
	      Vector subsequences, like all other vectors, implement
	      constant time element access.  
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Non-vector subsequences may take non-constant time to
	      create, but will provide constant-time access to the
	      first element. This should produce the best performance
	      provided some element of the subsequence is accessed at
	      least once.  
	    </para>
	  </listitem>
	</itemizedlist>
    </sect1>
    <sect1 id="libs-collection-extensions-vector-search">
      <title>Module vector-search</title>
      <para>
	The vector-search module provides basic search and replace
	capabilities upon restricted subsets of
	<dclass>sequence</dclass> -- primarily
	<dclass>vector</dclass>. Exploiting the known
	properties of these types yields substantially better
	performance than can be achieved for sequences in general.  
      </para>

	<dylanmethoddef>
	  <defname>find-first-key</defname>
	  <defsummary>Find the index of first element of a &lt;vector&gt;
	  </defsummary>
        <defparameters>
          <param>
            <paramname>seq</paramname>
            <paramtype>&lt;vector&gt;</paramtype>
          </param>
          <param>
            <paramname>pred?</paramname>
	    <paramsummary>
	      A <dclass>function</dclass> that returns &true;
	      for a matching condition.
	    </paramsummary> 
          </param>
          <keyparam>
            <paramname>start</paramname>
		<paramdefault>0</paramdefault>
            <paramsummary>From which element to start the search
            </paramsummary>
          </keyparam>
          <keyparam>
            <paramname>end</paramname>
            <paramsummary>Where to end the search
            </paramsummary>
          </keyparam>
          <keyparam>
            <paramname>failure</paramname>
            <paramsummary>Returned if no match found
            </paramsummary>
          </keyparam>
        </defparameters>
	&no-returns;
        <defdescription>
          <para>
	    Find the index of first element (after <dlit>start</dlit>
	    but before <dlit>end</dlit>) of a vector which satisfies
	    the given predicate.  If no matching element is found,
	    return <dlit>failure</dlit>.  The defaults for
	    <dlit>start</dlit>, <dlit>end</dlit> and
	    <dlit>failure</dlit> are, respectively,  0, size(vector),
	    and &false;.  This function is like
	    <dname>find-key</dname>, but accepts
	    <dlit>start:</dlit> and <dlit>end:</dlit> rather than
	    <dlit>skip:</dlit>. 
	  </para>
        </defdescription>
      </dylanmethoddef>

	<dylanmethoddef>
	  <defname>find-last-key</defname>
	  <defsummary>
	    This is like find-first-key, but goes backward from end.
	  </defsummary>
        <defparameters>
          <param>
            <paramname>seq</paramname>
            <paramtype>&lt;vector&gt;</paramtype>
          </param>
          <param>
            <paramname>pred?</paramname>
	    <paramsummary>
	      A &lt;function&gt; that returns true for a matching
	      condition
	    </paramsummary> 
          </param>
          <keyparam>
            <paramname>start</paramname>
		<paramdefault>0</paramdefault>
            <paramsummary>From which element to start the search
            </paramsummary>
          </keyparam>
          <keyparam>
            <paramname>end</paramname>
            <paramsummary>Where to end the search
            </paramsummary>
          </keyparam>
          <keyparam>
            <paramname>failure</paramname>
            <paramsummary>Returned if no match found
            </paramsummary>
          </keyparam>
        </defparameters>
	&no-returns;
        <defdescription>
          <para>
	    See the description for <dname>find-first-key</dname>.
	  </para> 
        </defdescription>
      </dylanmethoddef>

    </sect1>

    <sect1 id="libs-collection-extensions-utils">
      <title>Module Sequence-Utilities</title>
      <para>
        <dmodule>Sequence-Utilities</dmodule>, written by Matthias
        Hlzl,  provides common or oft-used operations performed on
        <dclass>sequence</dclass>s.  The whole module is
        rather Lispy in flavor, and has the feel of an elegant hack by
        the way functions use predicate functions to manipulate lists.
      </para>

      <sect2 id="libs-collection-extensions-utils-predicates">
        <title>Predicate Functions</title>
	<para>
          We start off with a group of generic functions that give
	  boolean responses to type information requests (e.g. "Are you
	  a <dclass>list</dclass>?").
	</para>
      
        <dylangenericdef>
          <defname>pair?</defname>
	  <defsummary>
	    Check whether this sequence is a pair.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>arg</paramname>
	      <paramtype>&lt;object&gt;</paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>ans</paramname>
	      <paramtype>&lt;boolean&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      This generic function has two specializers, one that takes
	      instances of <dclass>pair</dclass> (and
	      subclasses of it) which returns &true; and one that takes
	      anything else which returns &false;.
	    </para>
	  </defdescription>
        </dylangenericdef>

        <dylangenericdef>
          <defname>null?</defname>
	  <defsummary>
	    Check whether this sequence is the empty list.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>arg</paramname>
	      <paramtype>&lt;object&gt;</paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>ans</paramname>
	      <paramtype>&lt;boolean&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      To my mind, this generic function's name is a bit
	      misleading:  this returns &true; if the instance is an
	      <dclass>empty-list</dclass>. 
	    </para>
	  </defdescription>
        </dylangenericdef>

        <dylangenericdef>
          <defname>list?</defname>
	  <defsummary>
	    Check whether this sequence is a list.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>arg</paramname>
	      <paramtype>&lt;object&gt;</paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>ans</paramname>
	      <paramtype>&lt;boolean&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      Returns &true; if the instance is a
	      <dclass>list</dclass>; &false; otherwise.
	    </para>
	  </defdescription>
        </dylangenericdef>
      </sect2>

      <sect2 id="libs-collection-extensions-utils-create">
        <title>Creational Functions</title>

	<para>
	  This section and its subsections describe the functions that
	  create sequences.
	</para>

	<sect3 id="libs-collection-extensions-utils-create-seq">
	  <title>Sequence Creational Functions using Sequences</title>
	  <para>
            This set of functions provides ways to create sequences
	    from other sequences.
	  </para>

          <dylanfunctiondef>
            <defname>xpair</defname>
	    <defsummary>
	      Occasionally useful as a value to be passed to a fold or
	      other higher-order procedure.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>list</paramname>
	        <paramtype>&lt;list&gt;</paramtype>
	      </param>
	      <param>
	        <paramname>elt</paramname>
	        <paramsummary>
	          The element to add to the list
	        </paramsummary>
	      </param>
	    </defparameters>
	    <defreturns>
	      <param>
	        <paramname>new-list</paramname>
	        <paramtype>&lt;list&gt;</paramtype>
	      </param>
	    </defreturns>
	    <defdescription>
	      <para>
	        <dname>Xpair</dname> puts <dlit>elt</dlit> at the
	        head of <dlit>list</dlit>.
	      </para>
	    </defdescription>
          </dylanfunctiondef>

          <dylanfunctiondef>
            <defname>list*</defname>
	    <defsummary>
	      Like <dname>list</dname>, but cons the first
	      elements onto the last element of <dlit>rest</dlit>.
	    </defsummary>
	    <defparameters>
	      <restparam>
	        <paramname>rest</paramname>
	      </restparam>
	    </defparameters>
	    <defreturns>
	      <param>
	        <paramname>new-list</paramname>
	        <paramtype>&lt;list&gt;</paramtype>
	      </param>
	    </defreturns>
	    <defdescription>
	      <para>
	        I find description by example best here:
	      </para>
	      <programlisting>
list*(1, 2, 3, 4, 5)    => #(1, 2, 3, 4 . 5)
list*(1, 2, #(3, 4), 5) => #(1, 2, #(3, 4) . 5)
list*(1, 2, 3, #(4, 5)) => #(1, 2, 3, 4, 5)
              </programlisting>	 
	    </defdescription>
          </dylanfunctiondef>

        <dylangenericdef>
          <defname>reverse-append</defname>
	  <defsummary>
	    Prepend a reversed sequence to another sequence.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>reversed-head</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	      <paramsummary>
	        A reversed sequence to be prepended before
		<dlit>tail</dlit>. 
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>tail</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>new-sequence</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <programlisting>
reverse-append(#[5, 4, 3, 2, 1], #[6, 7, 8]) => #[1, 2, 3, 4, 5, 6, 7, 8]
	    </programlisting>
	  </defdescription>
        </dylangenericdef>

	</sect3>


	<sect3 id="libs-collection-extensions-utils-create-fn">
	  <title>Higher-Order Sequence Creational Functions</title>
	  <para>
	    The next set of functions creates
	    <dclass>sequence</dclass>s from functions.
          </para>

          <dylanfunctiondef>
            <defname>tabulate</defname>
	    <defsummary>
    	      Make a sequence by performing a function on the index.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>length</paramname>
	        <paramtype>&lt;integer&gt;</paramtype>
	      </param>
	      <param>
	        <paramname>func</paramname>
	        <paramtype>&lt;function&gt;</paramtype>
	        <paramsummary>
	          <dlit>Func</dlit> takes one argument: the index (an
	          <dclass>integer</dclass>).
	        </paramsummary>
	      </param>
	      <keyparam>
	        <paramname>type</paramname>
	        <paramdefault>&lt;list&gt;</paramdefault>
	      </keyparam>
	    </defparameters>
	    <defreturns>
	      <param>
	        <paramname>list</paramname>
	        <paramtype>&lt;mutable-sequence&gt;</paramtype>
	      </param>
	    </defreturns>
	    <defdescription>
	      <para>
	        Make a sequence of type <dlit>type</dlit> whose i-th
	        element is <dlit>func</dlit>(i) for 0 &lt;= i &lt;
	        <dlit>length</dlit>.  <dlit>Type</dlit> must be a subtype
	        of <dclass>mutable-sequence</dclass>.
	      </para>
	      <para>
	        For example, I want a vector of the annual worth of an
	        account of 10000 USD earning 10 percent annually.
	        The below code creates that vector:
	      </para>
	      <programlisting>
tabulate(10, method(x) 10000 * exp(x * .1) end, type: &lt;vector&gt;)
              </programlisting>
	      <para>
	        Or, to create a list of factorials, one could write this:
	      </para>
	      <programlisting>
define function factorial(x :: limited(&lt;integer&gt;, min: 0)) => (y :: &lt;integer&gt;)
  if(x == 0)
    1;
  else
    reduce1(\*, tabulate(x, curry(\+, 1)));
  end if;
end function factorial;

tabulate(6, factorial);
              </programlisting>
	    </defdescription>
          </dylanfunctiondef>
	</sect3>
      </sect2>

      <sect2 id="libs-collection-extensions-utils-slice">
        <title>Sequence Slicing</title>
	<para>
	  This section describes functions that return parts of
	  sequences.
	</para>

          <dylangenericdef>
            <defname>take</defname>
	    <defsummary>
	      Returns part of a sequence.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>collection</paramname>
	      </param>
	      <param>
	        <paramname>k</paramname>
		<paramtype>&lt;integer&gt;</paramtype>
	        <paramsummary>
		  Determines which part of the sequence to return.
	        </paramsummary>
	      </param>
	    </defparameters>
	    <defreturns>
	      <param>
	        <paramname>seq</paramname>
	      </param>
	    </defreturns>
	    <defdescription>
	      <para>
	        if <dlit>k</dlit> &gt; 0 return a new sequence
		consisting of the first <dlit>k</dlit> elements of
		<dlit>collection</dlit>, otherwise return a new
		sequence consisting of the last <dlit>k</dlit>
		elements of <dlit>collection</dlit>. 
	      </para>
	      <para>For example:</para>
	      <programlisting>
take(#(0, 5, 10, 15, 20, 25, 30), 5)  => #(0, 5, 10, 15, 20, 25)
take(#(0, 3,  6,  9, 12, 15, 18), -3) => #(12, 15, 18)
              </programlisting>
	    </defdescription>
          </dylangenericdef>

          <dylangenericdef>
            <defname>drop</defname>
	    <defsummary>
	      Returns part of a sequence.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>collection</paramname>
	      </param>
	      <param>
	        <paramname>k</paramname>
		<paramtype>&lt;integer&gt;</paramtype>
	        <paramsummary>
		  Determines which part of the sequence to return.
	        </paramsummary>
	      </param>
	    </defparameters>
	    <defreturns>
	      <param>
	        <paramname>seq</paramname>
	      </param>
	    </defreturns>
	    <defdescription>
	      <para>
	        if <dlit>k</dlit> &gt; 0 return a new sequence
		consisting of all but the first <dlit>k</dlit> elements of
		<dlit>collection</dlit>, otherwise return a new
		sequence consisting of all but the last <dlit>k</dlit>
		elements of <dlit>collection</dlit>. 
	      </para>
	      <para>For example:</para>
	      <programlisting>
drop(#(0, 5, 10, 15, 20, 25, 30), 5)  => #(25, 30)
drop(#(0, 3,  6,  9, 12, 15, 18), -3) => #(0, 3, 6, 9)
              </programlisting>
	    </defdescription>
          </dylangenericdef>

          <dylanfunctiondef>
            <defname>last-pair</defname>
	    <defsummary>
	       Return the last pair in a non-empty list.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>lst</paramname>
		<paramtype>&lt;pair&gt;</paramtype>
	      </param>
	    </defparameters>
	    <defreturns>
	      <param>
	        <paramname>last-pair</paramname>
	        <paramtype>&lt;pair&gt;</paramtype>
	      </param>
	    </defreturns>
	    <defdescription>
	      <para>
	        I find description by example best here, as well:
	      </para>
	      <programlisting>
last-pair(1, 2, 3, 4, 5)    => #(5)
last-pair(1, 2, 3, #(4, 5)) => #(#(4, 5))
last-pair(1, 2, 3, 4 . 5) => fails
              </programlisting>
	      <para>
	        The last example fails because last-pair expects the
	        elements of the list to be pairable ... in this case 5
	        is not.
	      </para>
	    </defdescription>
          </dylanfunctiondef>
	  
	  <dylanfunctiondef>
	    <defname>heads</defname>
	    <defsummary>
	      A list of all the heads of members of a list.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>lists</paramname>
		<paramtype>&lt;list&gt;</paramtype>
		<paramsummary>A list of lists</paramsummary>
	      </param>
	    </defparameters>
	    <defreturns>
	      <param>
	        <paramname>new-list</paramname>
		<paramtype>&lt;list&gt;</paramtype>
	      </param>
	    </defreturns>
	    <defdescription>
	      <para>
	        In a list of lists, this function returns a list of
	        the first elements of each of the lists
	      </para>
	      <programlisting>
heads(#(#(1, 5, 10), #(2, 4, 6), #(3, 6, 9))) => #(1, 2, 3)
	      </programlisting>
	    </defdescription>
	  </dylanfunctiondef>

	  <dylanfunctiondef>
	    <defname>tails</defname>
	    <defsummary>
	      A list of all the tails of members of a list.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>lists</paramname>
		<paramtype>&lt;list&gt;</paramtype>
		<paramsummary>A list of lists</paramsummary>
	      </param>
	    </defparameters>
	    <defreturns>
	      <param>
	        <paramname>new-list</paramname>
		<paramtype>&lt;list&gt;</paramtype>
	      </param>
	    </defreturns>
	    <defdescription>
	      <para>
	        In a list of lists, this function returns a list of
	        the all but first elements of each of the lists
	      </para>
	      <programlisting>
tails(#(#(1, 5, 10), #(2, 4, 6), #(3, 6, 9))) => #(#(5, 10), #(4, 6), #(6, 9))
	      </programlisting>
	    </defdescription>
	  </dylanfunctiondef>
      </sect2>

      <sect2 id="libs-collection-extensions-utils-find">
        <title>Finding Sequence Elements</title>
	<para>
	  These functions inspect elements of a sequence and return
	  information on them.
	</para>
	
	<dylanmethoddef>
	  <defname>satisfies</defname>
	  <defsummary>Find an element, return its index</defsummary>
	  <defparameters>
	    <param>
	      <paramname>pred</paramname>
	      <paramtype>&lt;function&gt;</paramtype>
	      <paramsummary>The test function to find the
	      element.</paramsummary>
	    </param>
	    <param>
	      <paramname>seq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <keyparam>
	      <paramname>failure</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        The value returned if a matching element is not found.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>index</paramname>
	      <paramsummary>
	        The index of the found element.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      Locates an element in <dlit>seq</dlit> that returns
	      a value (i.e. not &false;) from <dlit>pred</dlit>, and
	      returns the index. 
	      Note, the index is not necessarily an integer
	      ... <dclass>table</dclass> can use
	      non-integer indices.
	    </para>
	  </defdescription>
	</dylanmethoddef>

	
	<dylanmethoddef>
	  <defname>index</defname>
	  <defsummary>Find an element, return its index</defsummary>
	  <defparameters>
	    <param>
	      <paramname>elt</paramname>
	      <paramsummary>The sought element.</paramsummary>
	    </param>
	    <param>
	      <paramname>seq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <keyparam>
	      <paramname>test</paramname>
	      <paramdefault>\=</paramdefault>
	      <paramsummary>The test function to find the
	      element.</paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>failure</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        The value returned if a matching element is not found.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>index</paramname>
	      <paramsummary>
	        The index of the found element.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      Very much like the <dname>satisfies</dname>
	      function.  This allows the user to specify the element
	      sought, and assumes the <dlit>test</dlit> is
	      <dname>\=</dname> by default.
	    </para>
	  </defdescription>
	</dylanmethoddef>

	<dylanmethoddef>
	  <defname>find</defname>
	  <defsummary>Find an element</defsummary>
	  <defparameters>
	    <param>
	      <paramname>pred</paramname>
	      <paramtype>&lt;function&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>seq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <keyparam>
	      <paramname>failure</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        The value returned if a matching element is not found.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>obj</paramname>
	      <paramsummary>
	        The found element.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      The <dname>find</dname> function locates and
	      returns an object in a sequence when that object matches
	      the predicate function passed in as <dlit>pred</dlit>.
	    </para>
	  </defdescription>
	</dylanmethoddef>

	<dylanmethoddef>
	  <defname>find-tail</defname>
	  <defsummary>
	    Gives the rest of a list from a found element.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>pred</paramname>
	      <paramtype>&lt;function&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>seq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <keyparam>
	      <paramname>failure</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        The value returned if a matching element is not found.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>result</paramname>
	      <paramsummary>
	        The found list.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      The <dname>find-tail</dname> function locates an
	      object in a sequence when that object matches 
	      the predicate function passed in as <dlit>pred</dlit>.
	      When that element is found, it, and the rest of the
	      sequence, is returned as the <dlit>result</dlit>.
	    </para>
	  </defdescription>
	</dylanmethoddef>

	<dylanmethoddef>
	  <defname>precedes?</defname>
	  <defsummary>
	    Verifies that one element comes before another
	    in a sequence.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>elt-1</paramname>
	      <paramsummary>The preceding element.</paramsummary>
	    </param>
	    <param>
	      <paramname>elt-2</paramname>
	      <paramsummary>The following element.</paramsummary>
	    </param>
	    <param>
	      <paramname>seq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <keyparam>
	      <paramname>test</paramname>
	      <paramdefault>\=</paramdefault>
	      <paramsummary>
	        The test function to find the elements.
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>not-found</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        The value returned if either element not found.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>precedes?</paramname>
	      <paramtype>&lt;boolean&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      Ensures <dlit>elt-2</dlit> follows <dlit>elt-1</dlit>,
	      in <dlit>seq</dlit>, if so, returns &true;.
	    </para>
	  </defdescription>
	</dylanmethoddef>
      </sect2>

      <sect2 id="libs-collection-extensions-utils-map">
        <title>Mapping and Reducing Functions</title>
	<para>
	  These higher-order functions require an understanding of the
	  mapping and reducing functions found in the &drm; described
	  on pages 327 and on.  What they do is to perform an
	  operation on a sequence to obtain a result.
	</para>

	<dylanfunctiondef>
	  <defname>foldr</defname>
	  <defsummary>
	    Rebuilds a list by applying a function over it.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>cons</paramname>
	      <paramtype>&lt;function&gt;</paramtype>
	      <paramsummary>
	        A function that takes two arguments and returns a
	        <dclass>pair</dclass>.
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>nil</paramname>
	      <paramsummary>
	        Value returned if the list is empty (in
		most cases, this should be <dlit>#()</dlit>).
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>lst</paramname>
	      <paramtype>&lt;list&gt;</paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>result</paramname>
	      <paramtype>&lt;list&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      This function
	      rebuilds a list by recursively applying a function over
	      the list.  For example, to copy a list, one would write:
	    </para>
	    <programlisting>
foldr(pair, #(), #(1, 2, 3, 4, 5)) => #(1, 2, 3, 4, 5)
	    </programlisting>
	    <para>
	      Exercise: what is the result when you replace
	      <dname>pair</dname> with
	      <dname>list</dname>?
	    </para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>foldl</defname>
	  <defsummary>
	    Rebuilds a list by applying a function over it.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>cons</paramname>
	      <paramtype>&lt;function&gt;</paramtype>
	      <paramsummary>
	        A function that takes two arguments and returns a
	        <dclass>pair</dclass>.
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>nil</paramname>
	      <paramsummary>
	        Value returned if the list is empty (in
		most cases, this should be <dlit>#()</dlit>).
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>lst</paramname>
	      <paramtype>&lt;list&gt;</paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>result</paramname>
	      <paramtype>&lt;list&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      <dname>Foldr</dname> in reverse.  This function
	      rebuilds a list by recursively applying a function over
	      the list.  For example:
	    </para>
	    <programlisting>
foldl(method(x, y) pair(factorial(x), y) end, #f, #(1, 2, 3, 4, 5))
 => #(120, 24, 6, 2, 1 . #f)
	    </programlisting>
	    <para>
	      Note: the ugly dotted pair at the end is what occurs when
	      <dlit>nil</dlit> is not <dlit>#()</dlit>.
	    </para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanmethoddef>
	  <defname>concatenate-map</defname>
	  <defsummary>
	    Concatenates sequences then maps a function over them.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>func</paramname>
	      <paramtype>&lt;function&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>seq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <restparam>
	      <paramname>seqs</paramname>
	    </restparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>new-sequence</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      Concatenates <dlit>seq</dlit> and all members of
	      <dlit>seqs</dlit> together and maps <dlit>func</dlit>
	      over the resulting list.  The order of function
	      applications is unspecified. 
            </para>
	  </defdescription>
	</dylanmethoddef>

	<dylanmethoddef>
	  <defname>choose-map</defname>
	  <defsummary>
	    Maps a function over a sequence, then chooses selected elements.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>pred</paramname>
	      <paramtype>&lt;function&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>func</paramname>
	      <paramtype>&lt;function&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>seq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <restparam>
	      <paramname>seqs</paramname>
	    </restparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>new-sequence</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      Map <dlit>func</dlit> across <dlit>lst</dlit> and save
	      up all the results that satisfy <dlit>pred</dlit>.
            </para>
	  </defdescription>
	</dylanmethoddef>

        <dylanfunctiondef>
         <defname>pair-do</defname>
         <defsummary>
           Like do, except that it takes multiple argument lists
         </defsummary>
         <defparameters>
           <param>
             <paramname>func</paramname>
             <paramtype>&lt;function&gt;</paramtype>
             <paramsummary>
               A function that takes 1 or more instances of
               <dclass>list</dclass> as arguments.
             </paramsummary>
           </param>
           <param>
             <paramname>lst</paramname>
             <paramtype>&lt;list&gt;</paramtype>
             <paramsummary>
               A list of values that will be used as the first
               argument to <dname>func</dname>.
             </paramsummary>
           </param>
           <restparam>
             <paramname>lists</paramname>
             <paramtype>&lt;list&gt;</paramtype>
             <paramsummary>
               Each argument should be a <dclass>list</dclass>.
             </paramsummary>
           </restparam>
         </defparameters>
         <defreturns>
           <param>
             <paramname>false</paramname>
             <paramtype>&lt;boolean&gt;</paramtype>
             <paramsummary><dlit>#f</dlit></paramsummary>
           </param>
         </defreturns>
         <defdescription>
           <para>
             This function takes a n-ary function, and n instances
             of <dclass>list</dclass> as arguments. It then
             applies <dname>func</dname> to all of the lists, and
             then recursively applies <dname>func</dname> to all of
             the sublists of the lists. Contrast this with the
             <dname>do</dname> function, which is applied to each
             set of elements of the arguments rather to sublists.
           </para>
         </defdescription>
       </dylanfunctiondef>

       <dylanfunctiondef>
         <defname>pair-foldl</defname>
         <defsummary>
           This function is like <dname>foldl</dname>, but works on
sublists.
         </defsummary>
         <defparameters>
           <param>
             <paramname>cons</paramname>
             <paramtype>&lt;function&gt;</paramtype>
             <paramsummary>
               This argument is a function that can take two objects
               as arguments and returns a new object.
	     </paramsummary>
           </param>
           <param>
             <paramname>nil</paramname>
           </param>
           <param>
             <paramname>lst</paramname>
             <paramtype>&lt;list&gt;</paramtype>
           </param>
         </defparameters>
         <defreturns>
           <param>
             <paramname>obj</paramname>
           </param>
         </defreturns>
         <defdescription>
           <para>
             This function is similar to <dname>foldl</dname>, except
             that it operates on sublists instead of elements. That is,
             its recursion scheme is as follows: if <dname>lst</dname>
             is <dlit>#(e1, e2, ..., en)</dlit>, then this function
             returns
           </para>
           <para>
             <dlit>
      cons(#(en), cons(..., cons(#(e2,...en), cons(#(e1,...,en), nil)
...)))
             </dlit>
           </para>
         </defdescription>
       </dylanfunctiondef>

       <dylanfunctiondef>
         <defname>pair-foldr</defname>
         <defsummary>
           This function is like <dname>foldr</dname>, but works on
sublists.
         </defsummary>
         <defparameters>
           <param>
             <paramname>cons</paramname>
             <paramtype>&lt;function&gt;</paramtype>
             <paramsummary>
               This argument is a function that can take two objects
               as arguments and returns a new object.
	     </paramsummary>
           </param>
           <param>
             <paramname>nil</paramname>
           </param>
           <param>
             <paramname>lst</paramname>
             <paramtype>&lt;list&gt;</paramtype>
           </param>
         </defparameters>
         <defreturns>
           <param>
             <paramname>obj</paramname>
           </param>
         </defreturns>
         <defdescription>
           <para>
             This function is similar to <dname>foldr</dname>, except
             that it operates on sublists instead of elements. That is,
             its recursion scheme is as follows: if <dname>lst</dname>
             is <dlit>#(e1, e2, ..., en)</dlit>, then this function
             returns
           </para>
           <para>
             <dlit>
      cons(#(e1, ..., en), cons(#(e2,...en), cons(..., cons(#(en), nil)
...)))
             </dlit>
           </para>
         </defdescription>
       </dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>partition</defname>
	  <defsummary>
	    Returns two lists: one that satisfies a predicate, and one
	    that doesn't.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>pred</paramname>
	      <paramtype>&lt;function&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>seq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>winners</paramname>
	      <paramtype>&lt;list&gt;</paramtype>
	      <paramsummary>
	        The list of elements that satisfy the predicate.
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>losers</paramname>
	      <paramtype>&lt;list&gt;</paramtype>
	      <paramsummary>
	        The list of elements that do not.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      This is very much like <dname>choose</dname> found
	      in the &drm; (page 333), except this function also returns the
	      elements that did not match the predicate.
            </para>
	  </defdescription>
	</dylanfunctiondef>


       <dylanfunctiondef>
         <defname>unfold</defname>
         <defsummary>
           This function is dual to <dname>fold</dname>; instead of
           taking some functions and a list and producing a value,
           it takes a value and some functions and produces a list.
         </defsummary>
         <defparameters>
           <param>
             <paramname>pred</paramname>
             <paramtype>&lt;function&gt;</paramtype>
             <paramsummary>
               This function takes a seed value and returns &true;
               to terminate the sequence of recursive calls building
               the list.
             </paramsummary>
           </param>
           <param>
             <paramname>f</paramname>
             <paramtype>&lt;function&gt;</paramtype>
             <paramsummary>
               This function takes a seed value and produces a list
               element.
             </paramsummary>
           </param>
           <param>
             <paramname>g</paramname>
             <paramtype>&lt;function&gt;</paramtype>
             <paramsummary>
               This function takes a seed value and returns a new
               seed value.
             </paramsummary>
           </param>
           <param>
             <paramname>seed</paramname>
             <paramsummary>The initial seed value.</paramsummary>
           </param>
         </defparameters>
         <defreturns>
           <param>
             <paramname>new-list</paramname>
             <paramtype>&lt;list&gt;</paramtype>
           </param>
         </defreturns>
         <defdescription>
           <para>
             This function will return <dlit>#()</dlit> if
             <dlit>pred(seed)</dlit> is true. Otherwise it
             builds a pair of the form
             <dlit>
               pair(f(seed), unfold(pred, f, g, g(seed) ))
             </dlit>.
           </para>
           <para>
             Thus, this function will always return a proper
             list, if it terminates at all.
           </para>
         </defdescription>
       </dylanfunctiondef>

       <dylanfunctiondef>
         <defname>unfold/tail</defname>
         <defsummary>
           This function is similar to <dname>unfold</dname>, except
           that it can also be used to build an improper list.
         </defsummary>
         <defparameters>
           <param>
             <paramname>pred</paramname>
             <paramtype>&lt;function&gt;</paramtype>
             <paramsummary>
               This function takes a seed value and returns &true;
	       to terminate the sequence of recursive calls building
               the list.
             </paramsummary>
           </param>
           <param>
             <paramname>f</paramname>
             <paramtype>&lt;function&gt;</paramtype>
             <paramsummary>
               This function takes a seed value and produces a list
               element.
             </paramsummary>
           </param>
           <param>
             <paramname>g</paramname>
             <paramtype>&lt;function&gt;</paramtype>
             <paramsummary>
               This function takes a seed value and returns a new
               seed value.
             </paramsummary>
           </param>
           <param>
             <paramname>e</paramname>
             <paramtype>&lt;function&gt;</paramtype>
             <paramsummary>
               When <dname>pred</dname> returns &true;
               this function is called on the seed to return the
               value of the tail of the last pair of the list.
             </paramsummary>
           </param>
           <param>
             <paramname>seed</paramname>
             <paramsummary>The initial seed value.</paramsummary>
           </param>
         </defparameters>
         <defreturns>
           <param>
             <paramname>new-list</paramname>
             <paramtype>&lt;list&gt;</paramtype>
           </param>
         </defreturns>
         <defdescription>
           <para>
             This function will return <dlit>e(seed)</dlit> if
             <dlit>pred(seed)</dlit> is true. Otherwise it
             builds a pair of the form
             <dlit>
               pair(f(seed), unfold(pred, f, g, g(seed) ))
             </dlit>.
           </para>
           <para>
             If <dname>e</dname> always returns <dlit>#()</dlit>
             then <dname>unfold/tail</dname> has the same
             behavior as <dname>unfold</dname>.
           </para>
         </defdescription>
       </dylanfunctiondef>

      </sect2>

      <sect2 id="libs-collection-extensions-utils-assoc">
        <title>Associative Lists</title>
	<para>
	  Those familiar with Lisp will feel at home here.
	  Associative lists are <dclass>list</dclass>s
	  that contain <dclass>pair</dclass>s of entries
	  (in a <dlit>#(key, value)</dlit> format).  Much like
	  <dclass>table</dclass>s, one make look up the
	  key to obtain the value information.
	</para>
	
	<dylanfunctiondef>
	  <defname>assoc</defname>
	  <defsummary>Looks up a value given a key</defsummary>
	  <defparameters>
	    <param>
	      <paramname>elt</paramname>
	      <paramsummary>
	        The key element to find the value element
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>seq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <keyparam>
	      <paramname>key</paramname>
	      <paramdefault>head</paramdefault>
	      <paramsummary>
	        The function used to obtain the key element in the
	        associative list.
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>test</paramname>
	      <paramdefault>\=</paramdefault>
	      <paramsummary>
	        The function used to compare.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>found</paramname>
	      <paramsummary>
	        The value element from the found key.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      Find the tuple associated with <dlit>key</dlit> in the
	      association sequence <dlit>seq</dlit>.
	    </para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>apair</defname>
	  <defsummary>Adds an association to a sequence.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>key</paramname>
	      <paramsummary>
	        The key element of the association.
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>datum</paramname>
	      <paramsummary>
	        The value element of the association.
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>aseq</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <keyparam>
	      <paramname>cons</paramname>
	      <paramdefault>pair</paramdefault>
	      <paramsummary>
	        The function used to create the association from the
	        key and datum parameters.
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>add</paramname>
	      <paramdefault>xpair</paramdefault>
	      <paramsummary>
	        The function used to add the association onto the sequence.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>new-aseq</paramname>
	      <paramsummary>
	        The new associative list.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      Cons a new pair <dlit>#(key, datum)</dlit> on the head
	      of <dlit>aseq</dlit>.
	    </para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>alist-copy</defname>
	  <defsummary>Copies an associative list.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>alist</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <keyparam>
	      <paramname>key</paramname>
	      <paramdefault>head</paramdefault>
	      <paramsummary>
	        The function used to obtain the key element from the
	        association. 
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>datum</paramname>
	      <paramdefault>tail</paramdefault>
	      <paramsummary>
	        The function used to obtain the value element.
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>cons</paramname>
	      <paramdefault>pair</paramdefault>
	      <paramsummary>
	        The function used to create the association from the
	        key and datum parameters.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>new-aseq</paramname>
	      <paramsummary>
	        The new associative list.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      Copy an "associative list", actually any sequence that
	      can act like an associative list.
	    </para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>alist-delete</defname>
	  <defsummary>
	    Deletes associations from the associative list.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>elt</paramname>
	      <paramsummary>
	        The key element of the association to be removed.
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>alist</paramname>
	      <paramtype>&lt;sequence&gt;</paramtype>
	    </param>
	    <keyparam>
	      <paramname>key</paramname>
	      <paramdefault>head</paramdefault>
	      <paramsummary>
	        The function used to obtain the key element from the
	        association. 
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>test</paramname>
	      <paramdefault>\=</paramdefault>
	      <paramsummary>
	        The function used to compare keys.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>new-alist</paramname>
	      <paramsummary>
	        The new associative list.
	      </paramsummary>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      Delete all members keyed by <dlit>elt</dlit> from
	      <dlit>alist</dlit>.
	    </para>
	  </defdescription>
	</dylanfunctiondef>

      </sect2>

      <sect2 id="libs-collection-extensions-utils-todo">
        <title>Functions Not Yet Described</title>
	<para>
	  The following bindings (all of which are functions) have not
	  yet been described.  I will add these descriptions as time
	  and understanding permit.  For now, you must rely on the
	  best documentation available ... the source code in
	  src/common/coll-ext/sequence-utils.dylan.
	</para>
	<itemizedlist>
	  <listitem><para><dname>reduce-l</dname></para></listitem>
	  <listitem><para><dname>reduce-r</dname></para></listitem>
	</itemizedlist>
      </sect2>
    </sect1>
      
  </CHAPTER>

  <chapter id="libs-table-extensions">
    <title> The table-extensions Library </title>
    <sect1 id="libs-table-extensions-table-extensions">
      <title> The table-extensions Module </title>
  
      <para>
  	This library contains a number of useful additional table classes,
  	and a number of functions that could be useful in constructing
  	your own table classes.
      </para>
  
      <dylanclassdef>
  	<defname> &lt;case-insensitive-string-table&gt; </defname>
  	<defadjectives>
  	  sealed
  	  instantiable
  	</defadjectives>
  	<defsummary>
  	  Implements a <dname> &lt;table&gt; </dname> class, keyed by
  	  strings keyed without regard for case.
  	</defsummary>
  	<defsupers>
  	  <defsuper>
  	    &lt;value-table&gt;
  	  </defsuper>
  	</defsupers>
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
  	    <dname> &lt;case-insensitive-string-table&gt; </dname>
  	    implements a <dname> &lt;table&gt; </dname> class whose
  	    keys are instances of <dname> &lt;string&gt; </dname>.
  	    However, instead of using <dname> \= </dname> for the
  	    equivalence relation, strings which are the same modulo case are
  	    considered equivalent.
  	  </para>
  	  <para>
  	    Note that the case-insensitivity is true in general only for 
  	    English strings -- non-English characters have their case 
  	    "normalized" by subtracting the difference in integer code
  	    for the character 'a' and 'A'. This works only for ASCII
  	    and Unicode, and only for English. 
  	  </para>
  	</defdescription>
      </dylanclassdef>
      
      <dylanclassdef>
  	<defname> &lt;equal-table&gt; </defname>
  	<defadjectives>
  	  sealed
  	  instantiable
  	</defadjectives>
  	<defsummary>
  	  Implements a class which compares keys using <dname> \= </dname>.
  	</defsummary>
  	<defsupers>
  	  <defsuper>
  	    &lt;table&gt;
  	  </defsuper>
  	</defsupers>
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
  	    <dname> &lt;equal-table&gt; </dname> implements a
  	    <dname> &lt;table&gt; </dname> class whose keys are
  	    compared with <dname> \= </dname> rather than <dname>
  	    \== </dname>. So for example, two instances of <dname>
  	    list </dname> that don't have object identity, but did
  	    contain references to the same object, would be considered
  	    equivalent keys by <dname> &lt;equal-table&gt; </dname>.
  	  </para>
  	</defdescription>
      </dylanclassdef>
      
      <dylanclassdef>
  	<defname> &lt;hash-state&gt; </defname>
  	<defsummary>
  	  The type of hash states. 
  	</defsummary>
  	<defsupers>
  	</defsupers>
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
  	    <dname> &lt;hash-state&gt; </dname> is the type of the
  	    hash state returned as the second value of hash functions.
  	    For example, <dlit>$permanent-hash-state</dlit> is of type
  	    <dname> &lt;hash-state&gt; </dname>.
  	  </para>
  	</defdescription>
      </dylanclassdef>
      
      <dylanclassdef>
  	<defname> &lt;string-table&gt; </defname>
  	<defadjectives>
  	  sealed
  	  instantiable
  	</defadjectives>
  	<defsummary>
  	  A <dname> &lt;table&gt; </dname> class keyed by strings.
  	</defsummary>
  	<defsupers>
  	  <defsuper>
  	    &lt;value-table&gt;
  	  </defsuper>
  	</defsupers>
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
  	    This class implements a <dname> &lt;table&gt; </dname>
  	    class that is keyed by <dname> \= </dname> equal 
  	     <dname> &lt;string&gt; </dname> instances.
  	  </para>
  	</defdescription>
      </dylanclassdef>
      
      <dylanclassdef>
  	<defname>&lt;value-table&gt;</defname>
  	<defadjectives>
  	  open
  	  abstract
  	</defadjectives>
  	<defsummary>
  	  Intended as the abstract superclass of user-defined tables.
  	</defsummary>
  	<defsupers>
  	  <defsuper>
  	    &lt;table&gt;
  	  </defsuper>
  	</defsupers>
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
  	    This class is intended to be an abstract superclass of
  	    <dname> &lt;table&gt; </dname> classes that have
  	    user-defined key comparison and hash functions. (NB: The hash
  	    functions cannot involve physical addresses.)
  	  </para>
  	</defdescription>
      </dylanclassdef>
      
      <dylangenericdef>
  	<defname> case-insensitive-equal </defname>
  	<defsummary>
  	  Tests whether two objects (usually strings) are the same modulo
  	  case.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> object-1 </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> object-2 </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Tests whether two objects have the same string value modulo case.
  	    Comparisons to non- <dname> &lt;string&gt; </dname> or 
  	    <dname> &lt;character&gt; </dname> instances return
  	    <dlit>#f</dlit>.
  	  </para>
  	</defdescription>
      </dylangenericdef>
      
      <dylanmethoddef>
  	<defname> case-insensitive-equal </defname>
  	<defsummary>
  	  Least-specific method testing whether two objects are the same
  	  modulo case.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> object-1 </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> object-2 </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Since at least one of the arguments is not a <dname>
  	    &lt;character&gt; </dname> or <dname> &lt;string&gt;
  	    </dname>, this method always returns &false;.
  	  </para>
  	</defdescription>
      </dylanmethoddef>
      
      <dylanmethoddef>
  	<defname> case-insensitive-equal </defname>
  	<defsummary>
  	  Method testing whether two characters are the same modulo case.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> object-1 </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> object-2 </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    This method returns &true; if either the two arguments are the
  	    same character, or if they are alphabetic characters that are
  	    the same character modulo case. (This only works for English
  	    characters in general.)
  	  </para>
  	</defdescription>
      </dylanmethoddef>
      
      <dylanmethoddef>
  	<defname> case-insensitive-equal </defname>
  	<defsummary>
  	  Method testing whether two strings are the same modulo case.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> object-1 </paramname>
  	    <paramtype> &lt;string&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> object-2 </paramname>
  	    <paramtype> &lt;string&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    This method returns &true; if the two arguments are the same
  	    size, and each component character returns &true; with a 
  	    <dname>case-insensitive-equal</dname>. 
  	  </para>
  	</defdescription>
      </dylanmethoddef>
      
      <dylanfunctiondef>
  	<defname>case-insensitive-string-hash</defname>
  	<defsummary>
  	  The default hash function for case-insensitive strings.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> s </paramname>
  	    <paramtype> &lt;string&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> initial-state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> hash-state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    This is a convenient hash function for case-insensitive
  	    strings. It is returned as the <dname>table-protocol</dname>
  	    method's second value for
  	    <dname> &lt;case-insensitive-string-table&gt; </dname>.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
      
      <dylanfunctiondef>
  	<defname> collection-hash </defname>
  	<defsummary>
  	  A function for building hash functions that test collection
  	  equivalence.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> key-hash </paramname>
  	    <paramtype> &lt;function&gt; </paramtype>
  	    <paramsummary>
  	      Computes hash ids for the keys. It takes an object and a
  	      <dclass>hash-state</dclass> as an argument, and
  	      returns a hash id and a hash state.
  	    </paramsummary>
  	  </param>
  	  <param>
  	    <paramname> element-hash </paramname>
  	    <paramtype> &lt;function&gt; </paramtype>
  	    <paramsummary>
  	      Computes hash ids for the elements. It takes an object and a
  	      <dclass>hash-state</dclass> as an argument, and
  	      returns a hash id and a hash state.
  	    </paramsummary>
  	  </param>
  	  <param>
  	    <paramname> col </paramname>
  	    <paramtype> &lt;collection&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> initial-state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	  <keyparam>
  	    <paramname> ordered </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	    <paramsummary>
  	      Whether or not to do an ordered merge of the key/element hash
  	      codes. The default is <dlit>#f</dlit>.
  	    </paramsummary>
  	  </keyparam>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	    <paramsummary> The hash id. </paramsummary>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Two collections will yield the same hash id, if each of their
  	    keys/element pairs hash to the same value. It's safe to set
  	    the <dlit>ordered:</dlit> keyword argument to <dlit>#t</dlit>
  	    only if the collection has a natural iteration order.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  	  
      <dylangenericdef>
  	<defname> equal-hash </defname>
  	<defsummary>
  	  Computes hash ids for objects such that two objects that are
  	  <dname> \= </dname> equal have the same hash id.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> thing </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Methods on <dname> equal-hash </dname> should return hash
  	    ids such that the	id for two <dname> \= </dname> equal 
  	    objects are the same.
  	  </para>
  	  <para>
  	    There is a default method is defined on all instances of 
  	    &lt;object&gt;, and it returns a valid hash id in all cases. 
  	    However, performance *will* suck horribly (algorithmically, even) 
  	    if you don't define better methods for your own objects that will 
  	    live in <dname> &lt;equal-table&gt; </dname> instances.
  	  </para>
  	  <para>
  	    Good methods for <dname>equal-hash</dname> are defined for
  	    &lt;integer&gt;, &lt;float&gt;, &lt;symbol&gt;, &lt;type&gt;,
  	    &lt;function&gt;, &lt;boolean&gt;, &lt;condition&gt;, and
  	    &lt;collection&gt;. (Note that &lt;collection&gt; is a supertype
  	    of &lt;string&gt;.)
  	  </para>
  	</defdescription>
      </dylangenericdef>
      
      <dylanfunctiondef>
  	<defname> remove-all-keys! </defname>
  	<defsummary>
  	  Remove all keys from a table.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> coll </paramname>
  	    <paramtype> &lt;mutable-explicit-key-collection&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> coll </paramname>
  	    <paramtype> &lt;mutable-explicit-key-collection&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    This function iterates through all the keys and calls
  	    <dname> remove-key! </dname> on each one.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
      
      <dylanfunctiondef>
  	<defname> sequence-hash </defname>
  	<defsummary>
  	  Like <dname> collection-hash </dname>, only a more
  	  efficient version just for sequences.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> element-hash </paramname>
  	    <paramtype> &lt;function&gt; </paramtype>
  	    <paramsummary>
  	      Computes hash ids for the elements. It takes an object and a
  	      <dclass>hash-state</dclass> as an argument, and
  	      returns a hash id and a hash state.
  	    </paramsummary>
  	  </param>
  	  <param>
  	    <paramname> seq </paramname>
  	    <paramtype> &lt;sequence&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> initial-state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname>state</paramname>
  	    <paramtype>&lt;hash-state&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    This is similar to an <dname>equal-hash</dname>, except
  	    that it hashes things with <dkeyword>ordered</dkeyword>
	    &true; and ignores the sequence keys. USE WITH CAUTION:
	    This isn't a proper equal-hash because two collections of
	    different types but identical key/element pairs won't
	    generate the same hash id, even though the two collections
	    are <dname>\=</dname>.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
      
      
      <dylanfunctiondef>
  	<defname> string-hash </defname>
  	<defsummary>
  	  A convenient function for hashing strings
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> s </paramname>
  	    <paramtype> &lt;string&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> initial-state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    A convenient method for hashing strings. Used by
  	    <dname> &lt;string-table&gt; </dname>.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
      
  	  
      <dylangenericdef>
  	<defname> value-hash </defname>
  	<defsummary>
  	  Computes hash ids for objects such that two objects that are
  	  <dname> \= </dname> equal have the same hash id.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> thing </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Methods on <dname>equal-hash</dname> should return hash
  	    ids such that the id for two <dname>\=</dname> equal 
  	    objects are the same.
  	  </para>
  	  <para>
  	    There is a default method is defined on all instances of 
  	    &obj;, and it returns a valid hash id in all cases. 
  	    However, performance <em>*will*</em> suck horribly
	    (algorithmically, even) if you don't define better methods
	    for your own objects that will live in
	    <dclass>equal-table</dclass> instances. 
  	  </para>
  	  <para>
  	    Good methods for <dname>equal-hash</dname> are defined for
  	    <dclass>integer</dclass>, <dclass>float</dclass>,
	    <dclass>symbol</dclass>, <dclass>type</dclass>, 
  	    <dclass>function</dclass>, <dclass>boolean</dclass>,
	    <dclass>condition</dclass>, and 
  	    <dclass>collection</dclass>. (Note that
	    <dclass>collection</dclass> is a supertype of
	    <dclass>string</dclass>.)
  	  </para>
  	</defdescription>
      </dylangenericdef>
  
  <!-- 
       We need to add documentation for value-hash and values-hash, but
       I don't understand it well enough to describe yet. 
   -->
  
    </sect1>
  </chapter>          

  <chapter id="libs-string-extensions">
    <title> The string-extensions Library </title>
   
    <sect1 id="libs-string-extensions-character-type">
      <title>Module character-type</title>
  
      <para>
  	This module contains a set of methods for testing various
  	properties of <dclass>character</dclass> this
  	will work 100% correctly only with ASCII English characters.
  	Fixing this so it handles Unicode better would be a good way
  	of covering yourself with glory, hint hint.
      </para>

      <dylancharfndef name="alphabetic?" condition="in [a-zA-Z]"
       elaboration="alphabetic">
      <dylancharfndef name="digit?" condition="a numeric digit [0-9]"
       elaboration="a digit">
      <dylancharfndef name="alphanumeric?" condition="alphabetic or a digit"
       elaboration="alphanumeric">
      <dylancharfndef name="whitespace?" condition="whitespace"
       elaboration="whitespace (space, tab, linefeed, or newline)">
      <dylancharfndef name="lowercase?" condition="in [a-z]"
       elaboration="lowercase (in [a-z])">
      <dylancharfndef name="hex-digit?" condition="a hexadecimal digit"
       elaboration="a hexadecimal digit; that is, if it is in [0-9],
       [a-f] or [A-F]">
      <dylancharfndef name="graphic?" condition="a graphic character"
       elaboration="a printing, non-whitespace character">
      <dylancharfndef name="printable?" condition="printable"
       elaboration="a printing character">
      <dylancharfndef name="punctuation?" condition="punctuation"
       elaboration="a graphic, non-alphanumeric character">
      <dylancharfndef name="control?" condition="not printable"
       elaboration="a control character">
      <dylancharfndef name="byte-character?" 
       condition="an ASCII character.  Could be flaky"
       elaboration="a byte-character (which is if
  	    the integer value of the character returns less than
  	    256.  I don't know enough about Unicode and character set
  	    encodings to say what this means)">
      <dylancharfndef name="uppercase?" condition="uppercase"
       elaboration="in [A-Z]">
    </sect1>
  
    <sect1 id="libs-string-extensions-string-conversions">
      <title>The string-conversions Module</title>
      <para>
  	This module contains some handy functions to convert numbers
  	to strings and vice-versa, as well some
	<dclass>character</dclass> to <dclass>string</dclass>
	conversions. [Note: It might be a good idea to 
  	try making <dname>string-to-integer</dname> and
  	<dname>integer-to-string</dname> methods on
  	<dname>as</dname>, which is the usual generic for type
  	coercions. Ask about this on the GD mailing list.]
      </para>
  
      <dylanfunctiondef>
  	<defname>as</defname>
  	<defsummary>
  	  Convert a character to a string.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname>class</paramname>
  	    <paramtype>singleton(&lt;string&gt;)</paramtype> 
  	  </param>
  	  <param>
  	    <paramname>character</paramname>
  	    <paramtype>&lt;character&gt;</paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>string</paramname>
  	    <paramtype>&lt;string&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
 	    <dlit>as(&lt;string&gt;, character)</dlit> returns a
  	    fresh instance of <dclass>string</dclass>
  	    of size 1, whose only element is the character.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname>digit-to-integer</defname>
  	<defsummary>
  	  Convert a character to the integer it denotes.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname>character</paramname>
  	    <paramtype>&lt;character&gt;</paramtype>
  	    <paramsummary>
  	      An error is signalled character it is not alphanumeric.
  	    </paramsummary>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>integer</paramname>
  	    <paramtype>&lt;integer&gt;</paramtype>
  	    <paramsummary>Between 0 and 35, inclusive.</paramsummary>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    <dname>Digit-to-integer</dname> converts an
  	    alphanumeric character to an integer. '0' through '9'
  	    convert to 0 to 9, and 'a' through 'z' convert to 10 to
  	    35. An error is signalled if the character is not in this
  	    range.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname>integer-to-digit</defname>
  	<defsummary>
  	  Convert an integer to the corresponding digit.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname>digit</paramname>
  	    <paramtype>&lt;integer&gt;</paramtype>
  	  </param>
  	  <keyparam>
  	    <paramname>base</paramname>
  	    <paramtype>&lt;integer&gt;</paramtype>
  	    <paramsummary>
  	      Between 2 and 35, inclusive, representing the radix of
  	      the digit to return. The default base is 10.
  	    </paramsummary>
  	  </keyparam>
  	  <keyparam>
  	    <paramname>uppercase</paramname>
  	    <paramtype>&lt;boolean&gt;</paramtype>
  	    <paramsummary>
  	      For &true; returns uppercase letters for digits
  	      greater than 10, and lowercase for &false;. The
  	      default is &false;.
  	    </paramsummary>
  	  </keyparam>
  	</defparameters>
  	<defreturns>
	  <param>
	    <paramname>digit</paramname>
	    <paramtype>&lt;character&gt;</paramtype>
	    <paramsummary>The returned digit is an alphanumeric
	    character.</paramsummary> 
	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    <dname>Integer-to-digit</dname> converts an
  	    integer to the corresponding digit in the specified
  	    base. If the integer is outside the range a single digit
  	    in the specified base can represent, an error is
  	    signalled. Digits for values of 10 or higher are
  	    represented with the letters 'a' through 'z', with 'a' for
  	    10 and 'z' for 35.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname>integer-to-string</defname>
  	<defsummary>
  	  Converts an integer to a string value. 
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname>num</paramname>
  	    <paramtype>&lt;integer&gt;</paramtype>
  	  </param>
  	  <keyparam>
  	    <paramname>base</paramname>
  	    <paramtype>&lt;integer&gt;</paramtype>
	    <paramdefault>10</paramdefault>
  	    <paramsummary>
  	      <dkeyword>Base</dkeyword> should be between 2 and 36, inclusive,
  	      and is the radix of the string representation.  An error
	      will be signalled for radixes not in this range. 
  	    </paramsummary>
  	  </keyparam>
  	  <keyparam>
  	    <paramname>uppercase</paramname>
  	    <paramtype>&lt;boolean&gt;</paramtype>
  	    <paramsummary>
  	      If it is &true;, then uppercase letters will be
  	      used to represent digits higher than 9, and lowercase
  	      will be used if &false;.
  	    </paramsummary>
  	  </keyparam>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>number</paramname>
  	    <paramtype>&lt;string&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    <dname>Integer-to-string</dname> converts an
  	    integer to a string. String representations for radixes
  	    above 10 use the letters 'a' through 'z' for the digits
  	    from 10 to 35. So hexadecimal numbers would use [0-9] and
  	    [a-f], and base 20 would use [0-9] and [a-j], and base 36
  	    would use all the alphanumeric characters.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname>string-to-integer</defname>
  	<defsummary>
  	  Read a sequence of characters as an integer.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname>string</paramname>
  	    <paramtype>&lt;sequence&gt;</paramtype>
  	    <paramsummary>
  	      Any <dclass>sequence</dclass> of
  	      <dclass>character</dclass> objects are
  	      acceptable. This is typically but not necessarily a
  	      <dclass>string</dclass>.
  	    </paramsummary>
  	  </param>
  	  <keyparam>
  	    <paramname>base</paramname>
  	    <paramtype>&lt;integer&gt;</paramtype>
	    <paramdefault>10</paramdefault>
  	    <paramsummary>
  	      Between 2 and 36, inclusive, denoting the base to read
  	      integers in. An error is signalled if base is not in
  	      this range.
  	    </paramsummary>
  	  </keyparam>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>integer</paramname>
  	    <paramtype>&lt;integer&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    <dname>String-to-integer</dname> converts a sequence
  	    of <dclass>character</dclass> objects to an
  	    integer. The characters are the digits of the string
  	    representation, and must lie between '0' and 'z', with a
  	    maximum depending on the base. For example, octal (base 8)
  	    digits must be in [0-7], decimal digits must be in [0-9],
  	    and hexadecimal digits must be in [0-9] or [a-f]. An error
  	    is signalled if this constraint is violated. (Start
  	    negative integers with a '-', so "-36" would become -36.)
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
    </sect1>
  
    <sect1 id="libs-string-extensions-string-hacking">
      <title>The string-hacking Module</title>
      <para>
  	This module contains some random, possibly-useful functions
  	to munge strings. 
      </para>
    </sect1>
  
    <sect1 id="libs-string-extensions-substring-search">
      <title>The substring-search Module</title>
      <para>
  	This module contains some functions to do fast Boyer-Moore
  	searching on strings.
      </para>
    </sect1>
  </chapter>
  
  <CHAPTER ID="libs-regexp">
    <DOCINFO>
      <TITLE>Regular-Expression Library</TITLE>
      <DATE>November 29, 2000</DATE>
      <AUTHOR>&person.auclair;</AUTHOR>
    </DOCINFO>

    <TITLE>The Regular-Expressions Library</TITLE>

    <PARA>
      The Regular-expressions library exports the
      <dmodule>Regular-expressions</dmodule> 
      module, which contains various functions that deal with regular
      expressions (abbreviated to "regexps").  The module is
      based on Perl (version 4), and has the same semantics unless
      otherwise noted.  The syntax for Perl-style regular expressions
      can be found in &perl.regexp;.

<!-- on page 103 of Programming Perl by Larry Wall and
      Randal L. Schwartz. -->
      There are some differences in the way
      <dmodule>String-extensions</dmodule> handles
      regular expressions. The biggest difference is that regular
      expressions in Dylan are case insensitive by default.  Also,
      when given an unparsable regexp,
      <dmodule>String-extensions</dmodule> will produce
      undefined behavior while Perl would give an error message. 
    </PARA>
    <para>
      A regular expression that is grammatically correct may still be
      illegal if it contains an infinitely quantified sub-regexp that
      may match the empty string. That is, if R is a regexp that can
      match the empty string, then any regexp containing R*, R+, and
      R{n,} is illegal. In this case, the Regular-expressions library
      will signal an <dclass>illegal-regexp</dclass>
      error when the 
      regexp is parsed. Note: Perl also has this restriction, although
      it isn't mentioned in &perl.regexp;.
    </para>
    <para>
      In previous versions of the
      <dlibrary>regular-expressions</dlibrary> library, each basic
      function had a companion function that would pre-compute some
      information needed to use the regular expression. By using the
      companion function, one could avoid recomputing the same
      information. In the present version, the regular-expressions
      library caches this information, so the companion functions are
      no longer necessary and should be considered obsolete. However,
      they have been kept for backwards compatibility. 
    </para>
    <para>
      Companion functions differ in details, but they all essentially
      return curried versions of their corresponding basic
      function. For example, the following two pieces of code yield
      the same result: 
    </para>
    <programlisting>
regexp-position("This is a string", "is");
    </programlisting>
    <para>or</para>
    <programlisting>
let is-finder = make-regexp-positioner("is");
is-finder("This is a string");
    </programlisting>
    <para>
      Both pieces of code should have roughly the same performance,
      even if the code is inside a loop.  The first is the preferred
      method of using regexps.
    </para>
    <sect1 id="libs-regexp-module">
      <title>Regular-expressions Module</title>

      <sect2 id="libs-regexp-module-make-foo">
        <title>Make-Foo vs. Foo Functions</title>
	<para>
          There are quite a few make-fooer functions hanging around.  Now
	  that <dname>regexp-position</dname> does caching, these
	  are basically useless, but we've kept them around for
	  backwards compatibility.  Unfortunately, internally most of
	  the functions are implemented in terms of
	  <dname>make-regexp-positioner</dname>.  To minimize the
	  amount of rewriting, I've liberally applied seals and inline
	  declarations so that
	  <dname>make-regexp-positioner</dname> won't clobber all
	  type information.  The downside, of course, is that
	  everything's sealed, but hey, no one ever subclassed [ed:
	  specialized?] <dname>regexp-position</dname> anyway.
	</para>
      </sect2>
      <sect2 id="libs-regexp-module-caching">
        <title>Caching</title>
	<para>
	  Parsing a regexp is not cheap, so we cache the parsed
	  regexps and only parse a string if we haven't seen it
	  before.  Because in practice almost all regexp strings are
	  string literals, we're free to choose
	  <dname>\==</dname> or <dname>\=</dname>
	  depending on whatever's fastest.  However, because a string
	  is parsed differently depending on whether the search is
	  case sensitive or not, we also have to keep track of that
	  information as well.  (The case dependent parse boils down
	  to the parse creating a
	  <dclass>character-set</dclass>, which must be
	  either case sensitive or case insensitive).
	</para>
	<note>
	  <para>
	    Currently, only <dname>regexp-position</dname> uses
	    this cache, because the other functions are still using
	    <dname>make-regexp-positioner</dname>.  With caching,
	    that <dname>make-regexp-whatever</dname> stuff should
	    probably go. 
	  </para>
	</note>
      </sect2>
      <sect2 id="libs-regexp-module-names">
        <title>Exported Names</title>

	<dylanfunctiondef>
          <defname>regexp-position</defname>
	  <defsummary>The index of a regexp in a string</defsummary>
	  <defparameters>
	    <param>
	      <paramname>big</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	      <paramsummary>The string to parse.</paramsummary>
	    </param>
	    <param>
	      <paramname>regexp</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	    </param>
	    <keyparam>
	      <paramname>start</paramname>
	      <paramdefault>0</paramdefault>
	      <paramsummary>Where to start parsing the string.</paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>end</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        If defined, where to stop parsing the string.
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>case-sensitive</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>Match case in regexp while parsing.</paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>regexp-start</paramname>
	      <paramtype>false-or(&lt;integer&gt;)</paramtype>
	      <paramsummary>If defined, the index of the match.</paramsummary>
	    </param>
	    <restparam>
	      <paramname>marks</paramname>
	      <paramtype>false-or(&lt;integer&gt;)</paramtype>
	      <paramsummary>
	        The position of the end of the matche in the string
	        (see below).
              </paramsummary>
	    </restparam>
	  </defreturns>
	  <defdescription>
	    <para>
	      Find the position of a regular expression inside a string.
	      If the regexp is not found, return &false;, otherwise
	      return a variable number of marks.
	    </para>
	    <para>
	      This function returns the index of the start of the
	      regular expression in the <dname>big-string</dname>, or
	      &false; if the regular expression is not found.  As a
	      second value, it returns the index of the end of the regular
	      expression in the <dname>big-string </dname> (assuming it
	      was found; otherwise there is no second value). These
	      values are called marks, and they come in pairs, a
	      start-mark and an end-mark. If there are groups in the
	      regular expression, <dname>regexp-position</dname>
	      will return an additional pair of marks (a start and an end) for
	      each group.  If the group is matched, these marks will
	      be integers; if the group is not matched, the marks will
	      be &false;. So 
	    </para>
	    <programlisting>
regexp-position("This is a string", "is");
	    </programlisting>
	    <para>
	      returns <dlit>values(2, 4)</dlit> and
	    </para>
	    <programlisting>
regexp-position("This is a string", "(is)(.*)ing");
	    </programlisting>
	    <para>
	      returns <dlit>values(2, 16, 2, 4, 4, 13)</dlit>, while
	    </para>
	    <programlisting>
regexp-position("This is a string", "(not found)(.*)ing");
	    </programlisting>
	    <para>
	      returns &false;.  Marks are always given relative to the
	      start of <dname>big-string</dname>, not relative to the
	      <dlit>start:</dlit> keyword. 
	    </para>
	  </defdescription>
        </dylanfunctiondef>

	<dylanfunctiondef>
          <defname>regexp-replace</defname>
	  <defsummary>Replace information in a string.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>input</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	      <paramsummary>
	        The string to parse and replace pieces of.
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>regexp</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	    </param>
	    <param>
	      <paramname>new-substring</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	      <paramsummary>
	        The replacement string.
	      </paramsummary>
	    </param>
	    <keyparam>
	      <paramname>count</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        If supplied, number of substitutions to make.
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>case-sensitive</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>Match case in regexp while parsing.</paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>start</paramname>
	      <paramdefault>0</paramdefault>
	      <paramsummary>Where to start parsing the string.</paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>end</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        If defined, where to stop parsing the string.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>changed-string</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      This replaces all occurrences of <dname>regexp</dname> in
	      <dname>input</dname> with <dname>new-substring</dname>.
	      If <dlit>count:</dlit> 
	      is specified, it replaces only the first <dname>count</dname>
	      occurrences of <dname>regexp</dname>.  (This is different from
	      Perl, which replaces only the first occurrence unless /g
	      is specified) <dname>New-substring</dname> can contain
	      backreferences to the <dname>regexp</dname>.  For instance, 
	    </para>
	    <programlisting>
regexp-replace("The rain in Spain and some other text",
               "the (.*) in (\\w*\\b)", "\\2 has its \\1")
	    </programlisting>
	    <para>
	      returns "Spain has its rain and some other
	      text".  If the subgroup referred to by the
	      backreference was not matched, the reference is
	      interpreted as the null string.  For instance, 
	    </para>
	    <programlisting>
regexp-replace("Hi there", "Hi there(, Bert)?",
               "What do you think\\1?")
	    </programlisting>
	    <para>
	      returns "What do you think?" because ", Bert" wasn't found. 
	    </para>
	  </defdescription>
        </dylanfunctiondef>

	<dylanmethoddef>
          <defname>translate</defname>
	  <defsummary>
	    Equivalent to Perl's tr.  Does a character by character
	    translation.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>input</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	      <paramsummary>
	        The string to translate.
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>from-set</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	      <paramsummary>
	        String specification of a character set.
	      </paramsummary>
	    </param>
	    <param>
	      <paramname>to-set</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	      <paramsummary>
	        Another character set.
	      </paramsummary>
	    </param>
	    <keyparam>
	      <paramname>delete</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        If &true;, any characters in the
	        <dlit>from-string</dlit> that 
	        don't have matching characters in the
	        <dlit>to-string</dlit> are deleted.
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>start</paramname>
	      <paramdefault>0</paramdefault>
	      <paramsummary>Where to start parsing the string.</paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>end</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        If defined, where to stop parsing the string.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>output</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      This is equivalent to Perl's tr/// construct.
	      <dname>From-string</dname> is a string specification of a
	      character set, and <dname>to-string</dname> is another
	      character set.  <dname>Translate</dname> converts
	      <dname>input</dname> character by character, according
	      to the sets.  For instance, 
	    </para>
	    <programlisting>
translate("any string", "a-z", "A-Z")
	    </programlisting>
	    <para>
	      will convert "any string" to all uppercase: "ANY
	      STRING".
	    </para>
	    <para>
	      Like Perl, character ranges are not allowed to be
	      "backwards".  The following is not legal: 
	    </para>
	    <programlisting>
translate("any string", "a-z", "z-a")
	    </programlisting>
	    <para>
	      (This restriction may be removed in future releases)
	      Unlike Perl's tr///, <dname>translate</dname> doesn't
	      return the number of characters translated. 
	    </para>
	    <para>
	      If <dlit>delete:</dlit> is &true;, any characters in the
	      <dname>from-string</dname> that don't have matching
	      characters in the <dname>to-string</dname> are deleted.
	      The following will remove all vowels from a string and
	      convert periods to commas: 
	    </para>
	    <programlisting>
translate("any string", ".aeiou", ",", delete: #t)
	    </programlisting>
	    <para>
	      <dlit>Delete:</dlit> is &false; by default.  If
	      <dlit>delete:</dlit> is &false; and there aren't enough
	      characters in the <dname>to-string</dname>, the last
	      character in the <dname>to-string</dname> is reused as
	      many times as necessary.  The following converts several
	      punctuation characters into spaces:
	    </para>
	    <programlisting>
translate("any string", ",./:;[]{}()", " ");
	    </programlisting>
	    <para>
	      <dlit>Start:</dlit> and <dlit>end:</dlit> indicate which
	      part of <dname>input</dname> to translate.  They
	      default to the entire string.
	    </para>
	    <note>
	      <para>
	        <dname>Translate</dname> is always case
		sensitive.
	      </para>
	    </note>
	  </defdescription>
        </dylanmethoddef>

	<dylanfunctiondef>
          <defname>split</defname>
	  <defsummary>
	    Breaks up a string along boundary characters.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>pattern</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	      <paramsummary>The regexp to split on.</paramsummary>
	    </param>
	    <param>
	      <paramname>input</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	      <paramsummary>
	        The string to parse and replace pieces of.
	      </paramsummary>
	    </param>
	    <keyparam>
	      <paramname>count</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        If supplied, maximum number of strings to return.
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>remove-empty-items</paramname>
	      <paramdefault>#t</paramdefault>
	      <paramsummary>
	        Magically skips empty items when &true;.
	      </paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>start</paramname>
	      <paramdefault>0</paramdefault>
	      <paramsummary>Where to start parsing the string.</paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>end</paramname>
	      <paramdefault>#f</paramdefault>
	      <paramsummary>
	        If defined, where to stop parsing the string.
	      </paramsummary>
	    </keyparam>
	  </defparameters>
	  <defreturns>
	    <restparam>
	      <paramname>whole-bunch-of-strings</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	    </restparam>
	  </defreturns>
	  <defdescription>
	    <para>
	      This is like Perl's split function.  It searches
	      <dname>input</dname> from occurrences of
	      <dname>pattern</dname>, and returns substrings that were
	      delimited by that regexp.  For instance, 
	    </para>
	    <programlisting>
split("-", "long-dylan-identifier")
	    </programlisting>
	    <para>
	      returns <dlit>values("long", "dylan",
	      "identifier")</dlit>.  Note that what matched the
	      regexp is left out.  <dname>Remove-empty-items</dname>, which
	      defaults to true, magically skips over empty items, so
	      that 
	    </para>
	    <programlisting>
split("-", "long--with--multiple-dashes")
	    </programlisting>
	    <para>
	      returns <dlit>values("long", "with", "multiple",
	      "dashes")</dlit>.   <dname>Count</dname>
	      is the maximum number of strings to return.  If there
	      are <dname>n</dname> strings and <dname>count</dname> is
	      specified, the 
	      first <dname>count</dname> - 1 strings are returned as usual,
	      and the <dname>count</dname>th string is the remainder,
	      unsplit.  So 
	    </para>
	    <programlisting>
split("-", "really-long-dylan-identifier", count: 3)
	    </programlisting>
	    <para>
	      returns <dlit>values("really", "long",
	      "dylan-identifier")</dlit>.  If
	      <dname>remove-empty-items</dname> is &true;, empty items
	      aren't counted. 
	    </para>
	    <para>
	      <dlit>Start:</dlit> and <dlit>end:</dlit> indicate what
	      part of <dname>input</dname> should be looked at for
	      delimiters.  They 
	      default to the entire string.  For instance, 
	    </para>
	    <programlisting>
split("-", "really-long-dylan-identifier", start: 8)
	    </programlisting>
	    <para>
	      returns <dlit>values("really-long", "dylan",
	      "identifier")</dlit>.
	    </para>
	    <note>
	      <para>
	        Unlike Perl, empty regular expressions are never legal
	        regular expressions, so there is no way to split a
	        string into a bunch of single character strings. Of
	        course, in Dylan this is not a useful thing to do (as
	        one can get each character of the string by iteration
	        or by indexing), so this is not really a problem.
	      </para>
	    </note>
	  </defdescription>
        </dylanfunctiondef>

	<dylanfunctiondef>
          <defname>join</defname>
	  <defsummary>
	    Does the opposite of split.
	  </defsummary>
	  <defparameters>
	    <param>
	      <paramname>delimiter</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	    </param>
	    <restparam>
	      <paramname>strings</paramname>
	    </restparam>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>big-string</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>
	      This is like Perl's join function.  This is not really
	      any more efficient than
	      <dname>concatenate-as</dname>, but it's more 
	      convenient.
	    </para>
	    <programlisting>
join(":", word1, word2, word3)
	    </programlisting>
	    <para>is equivalent to</para>
	    <programlisting>
concatenate(word1, ":", word2, ":", word3)
	    </programlisting>
	    <para>
	      (and no more efficient).
	    </para>
	  </defdescription>
        </dylanfunctiondef>

	<dylanclassdef>
	  <defname>&lt;illegal-regexp&gt;</defname>
	  <defadjectives>sealed</defadjectives>
	  <defsummary>
	    Signaled when a function receives an illegal regular expression.
	  </defsummary>
	  <defsupers><defsuper>&lt;error&gt;</defsuper></defsupers>
	  <definitkeywords>
	    <keyparam>
	      <paramname>regexp</paramname>
	      <paramtype>&lt;string&gt;</paramtype>
	      <paramsummary>The regexp that caused the error</paramsummary>
	    </keyparam>
  	  </definitkeywords>
  	  <defdescription>
  	    <para>
	      Signaled when a function receives an illegal regular expression.
  	    </para>
  	  </defdescription>
        </dylanclassdef>

	  <sect3 id="libs-regexp-module-names-deprecated">
	    <title>Deprecated Functions</title>
	    <para>
	      These functions still work, but are deprecated.  Use the
	      foo functions (described above) instead of these
	      make-foo functions. 
	    </para>

	    <dylanfunctiondef>
              <defname>make-regexp-positioner</defname>
	      <defsummary>
	        [Deprecated] Creates a function that finds the index of a
		regexp in a string.
	      </defsummary>
	      <defparameters>
	        <param>
		  <paramname>regexp</paramname>
		  <paramtype>&lt;string&gt;</paramtype>
	        </param>
		<keyparam>
		  <paramname>byte-character-only</paramname>
		  <paramdefault>#f</paramdefault>
		  <paramsummary>Ignored.</paramsummary>
	        </keyparam>
		<keyparam>
		  <paramname>needs-marks</paramname>
		  <paramdefault>#f</paramdefault>
		  <paramsummary>Ignored.</paramsummary>
		</keyparam>
		<keyparam>
		  <paramname>maximum-compile</paramname>
		  <paramdefault>#f</paramdefault>
		  <paramsummary>Ignored.</paramsummary>
	        </keyparam>
		<keyparam>
		  <paramname>case-sensitive</paramname>
		  <paramdefault>#f</paramdefault>
		  <paramsummary>
		    Match case in regexp while parsing.
		  </paramsummary>
	        </keyparam>
	      </defparameters>
	      <defreturns>
	        <param>
		  <paramname>regexp-positioner</paramname>
		  <paramtype>&lt;function&gt;</paramtype>
		  <paramsummary>
		    The function to execute a match on a string.
	          </paramsummary>
	        </param>
	      </defreturns>
	      <defdescription>
	        <para>
	          Once upon a time, this was how you interfaced to the NFA
		  stuff (<dlit>maximum-compile:</dlit> &true;).  That's
		  gone.  Now it's just here for backwards compatibility.
		  All keywords except <dlit>case-sensitive</dlit> are now
		  ignored. 
	        </para>
	      </defdescription>
            </dylanfunctiondef>

	    <dylanfunctiondef>
	      <defname>make-regexp-replacer</defname>
	      <defsummary>
	        [Deprecated] Creates a function that replaces
	        information in a string.
	      </defsummary>
	      <defparameters>
		<param>
		  <paramname>regexp</paramname>
		  <paramtype>&lt;string&gt;</paramtype>
		</param>
		<keyparam>
		  <paramname>replace-with</paramname>
		  <paramsummary>
		    The replacement string.
	          </paramsummary>
	        </keyparam>
		<keyparam>
		  <paramname>case-sensitive</paramname>
		  <paramdefault>#f</paramdefault>
		  <paramsummary>
		    Match case in regexp while parsing.
		  </paramsummary>
	        </keyparam>
	      </defparameters>
	      <defreturns>
	        <param>
		  <paramname>replacer</paramname>
		  <paramtype>&lt;function&gt;</paramtype>
		  <paramsummary>
		    The function that does the replacement.
		  </paramsummary>
		</param>
	      </defreturns>
	      <defdescription>
	        <para>
		  This returns an anonymous replacer function that is
		  either
		</para>
		<programlisting>
method (big-string, #key count, start, end)
		</programlisting>
		<para>or</para>
		<programlisting>
method (big-string, replace-string, #key count, start, end)
		</programlisting>
		<para>
		  The first form is returned if the
		  <dlit>replace-with:</dlit> keyword isn't supplied,
		  otherwise the second form is returned. 
		</para>
	      </defdescription>
            </dylanfunctiondef>

	    <dylanmethoddef>
	      <defname>make-translator</defname>
	      <defsummary>
	        [Deprecated] Creates a function that translates a string.
	      </defsummary>
	      <defparameters>
	        <param>
		  <paramname>from-set</paramname>
		  <paramtype>&lt;string&gt;</paramtype>
		  <paramsummary>
		    String specification of a character set.
		  </paramsummary>
		</param>
		<param>
		  <paramname>to-set</paramname>
		  <paramtype>&lt;string&gt;</paramtype>
		  <paramsummary>
		    Another character set.
	          </paramsummary>
	        </param>
		<keyparam>
		  <paramname>delete</paramname>
		  <paramdefault>#f</paramdefault>
		  <paramsummary>
		    If &true;, delete <dlit>from-set</dlit> characters
		    not in <dlit>to-set</dlit>.
		  </paramsummary>
	        </keyparam>
	      </defparameters>
	      <defreturns>
	        <param>
		  <paramname>translator</paramname>
		  <paramtype>&lt;function&gt;</paramtype>
		  <paramsummary>
		    The function that does the translation.
		  </paramsummary>
		</param>
	      </defreturns>
	      <defdescription>
	        <para>
		  This returns an anonymous translation function.
		</para>
	      </defdescription>
            </dylanmethoddef>

	    <dylanfunctiondef>
	      <defname>make-splitter</defname>
	      <defsummary>
	        [Deprecated] Creates a function that splits a string.
	      </defsummary>
	      <defparameters>
		<param>
		  <paramname>pattern</paramname>
		  <paramtype>&lt;string&gt;</paramtype>
		  <paramsummary>The regexp to split on.</paramsummary>
		</param>
	      </defparameters>
	      <defreturns>
	        <param>
		  <paramname>splitter</paramname>
		  <paramtype>&lt;function&gt;</paramtype>
		  <paramsummary>
		    (If you're Brit, don't smile.) The function that
		    does the split on the string.
		  </paramsummary>
		</param>
	      </defreturns>
	      <defdescription>
	        <para>
		  This returns an anonymous splitter function.
		</para>
	      </defdescription>
            </dylanfunctiondef>

	 </sect3>
	
      </sect2>
      
    </sect1>
    <sect1 id="libs-regexp-bugs">
      <title>Known Bugs</title>
      <para>
        The regular expression parser does a very poor job with
        syntactically invalid regular expressions. Depending on the
        expression, the parser may signal an error, improperly parse
        it, or simply crash.
      </para>
      <para>
        A regular expression that matches a large enough substring can
        produce a stack overflow. This can happen much more easily
        under d2c than under Mindy -- as few as two dozen lines of 80
        column text under d2c for Windows.
      </para>
      <note>
        <para>
	  As the <dlibrary>regular-expressions</dlibrary> library is
	  used to create d2c, it appears to be stable enough for most
	  Dylan tasks -- even under Cygnus on Windows.
	</para>
      </note>
    </sect1>
  </CHAPTER>

  <CHAPTER ID="libs-transcendental">

    <DOCINFO>
      <TITLE>Transcendental Library</TITLE>
      <DATE>November 11, 2000</DATE>
      <AUTHORGROUP>
	<AUTHOR>&person.auclair;</AUTHOR>
      </AUTHORGROUP>
    </DOCINFO>

    <TITLE>The Transcendental Library</TITLE>
    <para>
      The Transcendental library contains functions on numbers.  It
      includes commonly used numbers, such as pi and e, and the
      transcendental functions, including sine, cosine, and tangent,
      and their inverse (arc) and hyperbolic counterparts.  Also
      included are the logarithmic family of functions (the various
      log functions and exp), and the square-root and power (^) functions.
    </para>

    <sect1 id="libs-transcendental-sincostan">
    <title>Sine, Cosine, and Tangent</title>
    <para>
      To understand the transcendental functions (particularly, sine,
      cosine, and tangent, and their friends), one must know about the
      relationships for a right triangle.  The discussion will use the
      below reference figure:
    </para>
    <FIGURE id="libs-transcendental-sincostan-tri-1">
      <TITLE>A right triangle</TITLE>
      <GRAPHIC fileref="tri.png"></GRAPHIC>
    </FIGURE>
    <para>
      Sine, cosine, and tangent are used when you know an angle and a
      length of one of the sides of a right triangle, and you want to
      know the length of another side.  For these functions, the angle
      (theta) is in radians, not degrees.  Using the reference diagram
      above, for sine, you work with the hypotenuse (AC) and the height
      (AB), for cosine, you work with the hypotenuse (AC) and the base
      length (BC), and for tangent, you work with the base and the height.
    </para>

    <dylangenericdef>
      <defname>sin</defname>
      <defsummary>Returns the sine of a real number.</defsummary>
      <defparameters>
        <param>
	  <paramname>x</paramname>
	  <paramtype> &lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
        <param>
	  <paramname>y</paramname>
	  <paramtype> &lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
  	<para>
	  Returns the sine of a real number.  Using the above right
	  triangle in <xref linkend="libs-transcendental-sincostan-tri-1">, 
          the sine of theta is AB / AC.  For example, say AC
	  is 12 meters and theta is <dlit>$double-pi</dlit> / 6 (30 degrees).  
	  You solve
	  for AB by multiplying AC and sine theta.  AB = 12 * 
	  <dname>sin</dname>(
	  <dlit>$double-pi</dlit> /
	  6.0) => 6 meters.
  	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>cos</defname>
      <defsummary>Returns the cosine of a real number.</defsummary>
      <defparameters>
        <param>
	  <paramname>x</paramname>
	  <paramtype> &lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
        <param>
	  <paramname>y</paramname>
	  <paramtype> &lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
  	<para>
	  Returns the cosine of a real number.  The cosine of theta is
	  BC / AC.  Problem:  Given theta is <dlit>$double-pi</dlit> / 4 
	  and BC is
	  7 meters, what length is AC?  What is theta in degrees?
	  (see the entry for <dlit>$double-pi</dlit> for help)
  	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>tan</defname>
      <defsummary>Returns the tangent of a real number.</defsummary>
      <defparameters>
        <param>
	  <paramname>x</paramname>
	  <paramtype> &lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
        <param>
	  <paramname>y</paramname>
	  <paramtype> &lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
  	<para>
	  Returns the tangent of a real number.  The tangent of theta
	  is AB / BC.  The canonical exercise for tangent is to compute
          the height of a building.  Let's say you want to know how high
          your chimney is.  You are standing 25 meters from the building,
          and the chimney is 4 hands above the ground (where a hand is
          equivalent to 12 degrees).  How tall is your chimney?
  	</para>
      </defdescription>
    </dylangenericdef>
  </sect1>

  <sect1 id="libs-transcendental-pi">
    <title>The pi Constants</title>
    <para>
      So, perhaps you are used to thinking in degrees, not radians.
      How do you convert between the two when you use the above
      functions?  That's as easy as pi!  If you have the angle in
      degrees and one of side lengths, first multiple that angle by
      pi / 180.0 (either <dlit>$double-pi</dlit> or <dlit>$single-pi</dlit>) 
      to get radians, and
      then use that resulting theta in the appropriate 
      function. 
    </para>
    <para>
      There are several engrossing exercises for computing pi, and
      several novel approaches.  The most widely-known approach is to
      compute the value of the series 4 - 4/3 + 4/5 - 4/7 ... (which
      takes a very large number of terms to get close to Chuck Moore's
      find (see below)).  Another is to use the Fibonacci numbers
      (see <ulink url=
	"http://www.ee.surrey.ac.uk/Personal/R.Knott/Fibonacci/fibpi.html">
	this article on computing pi using arc-tangents</ulink>)
      which become usable in about ten terms.
    </para>

    <dylanconstantdef>
      <defname>$double-pi</defname>
      <defsummary>
        The approximation of pi for double-precision floating-point
        arithmetic.
      </defsummary>
      <deftype>&lt;double-float&gt;</deftype>
      <defdescription>
        <para>
	  The value here is 3.14159265358979323846.  Chuck Moore, the
	  inventor of the programming language Forth, chose instead to
	  use 355 / 113 as pi (which is accurate to 3e-7), as
	  computers at the time processed floating point operations
	  too slowly for use in real-time applications.
	</para>
      </defdescription>
    </dylanconstantdef>

    <dylanconstantdef>
      <defname>$single-pi</defname>
      <defsummary>
        The approximation of pi for single-precision floating-point
        arithmetic.
      </defsummary>
      <deftype>&lt;single-float&gt;</deftype>
      <defdescription>
        <para>
	  This pi is a truncated value of <dlit>$double-pi</dlit>.
	</para>
      </defdescription>
    </dylanconstantdef>
  </sect1>

  <sect1 id="libs-transcendental-arc">
    <title>The Inverse (Arc) Functions</title>

    <para>
      The next question that comes up is if you have two sides of the
      right triangle, and you need to know the angle.  The arc
      functions of sine, cosine and tangent resolve this issue.  Let's
      use the same reference diagram for the following discussion.
    </para>
    <FIGURE id="libs-transcendental-arc-tri-1">
      <TITLE>A right triangle</TITLE>
      <GRAPHIC fileref="tri.png"></GRAPHIC>
    </FIGURE>
    <para>
      The
      arc sine function (<dname>asin</dname>, also known as the 
      inverse sine) gives
      theta (the angle in radians) from the height (AB) over the
      hypotenuse (AC).  The other arc functions, <dname>acos</dname>, 
      and <dname>atan</dname>,
      behave as their more-familiar counterparts.  So, the arc-cosine gives
      theta from the base (BC) and the hypotenuse (AC); the arc-tangent,
      from the height(AB) and the base (BC).  Again, to convert
      from radians to degrees, multiple the result by 180 / pi.
    </para>

    <dylangenericdef>
      <defname>asin</defname>
      <defsummary>Returns the arc-sine of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Given the hypotenuse (AC) and the height (AB), the arc-sine
	  gives theta in the diagram:  the angle in radians.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>acos</defname>
      <defsummary>Returns the arc-cosine of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Given the hypotenuse (AC) and the base (BC), the arc-cosine
	  gives theta in <xref linkend="libs-transcendental-arc-tri-1">:  
          the angle in radians.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>atan</defname>
      <defsummary>Returns the arc-tangent of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Given the height (AB) over the base (BC), the arc-tangent
	  gives theta in the diagram:  the angle in radians.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>atan2</defname>
      <defsummary>Returns the arc-tangent of a pair of real numbers</defsummary>
      <defparameters>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>z</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Given the height (AB) as <parameter>y</parameter> and the base (BC) 
          as <parameter>x</parameter>, 
	  the arc-tangent gives theta as <parameter>z</parameter>:  the angle 
          in radians.
	</para>
      </defdescription>
    </dylangenericdef>

    </sect1>

    <sect1 id="libs-transcendental-h">
    <title>The Hyperbolic Functions</title>
    
    <dylangenericdef>
      <defname>sinh</defname>
      <defsummary>Returns the hyperbolic sine of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Returns the hyperbolic sine of a real number.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>cosh</defname>
      <defsummary>Returns the hyperbolic cosine of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Returns the hyperbolic cosine of a real number.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>tanh</defname>
      <defsummary>Returns the hyperbolic tangent of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Returns the hyperbolic tangent of a real number.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>asinh</defname>
      <defsummary>Returns the hyperbolic arc-sine of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Returns the hyperbolic arc-sine of a real number.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>acosh</defname>
      <defsummary>Returns the hyperbolic arc-cosine of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Returns the hyperbolic arc-cosine of a real number.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>atanh</defname>
      <defsummary>Returns the hyperbolic arc-tangent of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Returns the hyperbolic arc-tangent of a real number.
	</para>
      </defdescription>
    </dylangenericdef>

    </sect1>

    <sect1 id="libs-transcendental-e">
    <title>The e Constants</title>
    <para>
      I will leave aside the temptation to find mathematical similarities
      between pi and e, with the exception of stating that both can use
      the Fibonacci numbers to find close approximations of their values.
      e finds use for logarithmic and exponential calculations.
    </para>
      

    <dylanconstantdef>
      <defname>$double-e</defname>
      <defsummary>
        The approximation of e for double-precision arithmetic.
      </defsummary>
      <deftype>&lt;double-float&gt;</deftype>
      <defdescription>
        <para>
	  The value here is 2.7182818284590452354.  To compute your
	  own approximation, use the Fibonacci numbers (1, 1, 2, 3, 5,
	  8, 13, 21, ...).  e = F(n) / F(n-1); where the larger n is,
	  the more accurate e is.
	</para>
      </defdescription>
    </dylanconstantdef>

    <dylanconstantdef>
      <defname>$single-e</defname>
      <defsummary>
        The approximation of e for single-precision arithmetic.
      </defsummary>
      <deftype>&lt;single-float&gt;</deftype>
      <defdescription>
        <para>
	  This e is a truncated value of <dlit>$double-e</dlit>.
	</para>
      </defdescription>
    </dylanconstantdef>

    </sect1>

    <sect1 id="libs-transcendental-log">
    <title>The Logarithmic Functions</title>
    <para>
      The logarithmic family of functions (<dname>log</dname> in its
      various forms and <dname>exp</dname>) use e as their foundation.
    </para>

      <dylangenericdef>
	<defname>log</defname>
	<defsummary>Returns the exponent of a number</defsummary>
	<defparameters>
	  <param>
	    <paramname>x</paramname>
	    <paramtype>&lt;real&gt;</paramtype>
	  </param>
	  <keyparam>
	    <paramname>base</paramname>
	    <paramtype>&lt;real&gt;</paramtype>
	    <paramsummary>
		The number to which the exponent is applied to get x.  The
		default is <dlit>$double-e</dlit>
	    </paramsummary>
	  </keyparam>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>y</paramname>
	    <paramtype>&lt;float&gt;</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    The <dname>log</dname> function scales large numbers, so
	    that (e.g.) data points with a very large spread can be viewed
            together.  <dname>log</dname> assumes <dlit>$double-e</dlit>
	    as the base, but you may change that by supplying a different
	    value.  For example,
	  </para>
	  <programlisting>
log(100000, base: 10) => 5.0
	  </programlisting>
	</defdescription>
      </dylangenericdef>

      <dylangenericdef>
	<defname>exp</defname>
	<defsummary>Returns the e raised to a number</defsummary>
        <defparameters>
    	  <param>
	    <paramname>x</paramname>
	    <paramtype>&lt;real&gt;</paramtype>
	  </param>
        </defparameters>
	<defreturns>
	  <param>
	    <paramname>y</paramname>
	    <paramtype>&lt;float&gt;</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    <dname>exp</dname> returns e raised to the number supplied.
	    You may be wondering what purpose this function serves, given
	    <constant>$double-e</constant> and <dname>\^</dname>.  
	    Actually, <dname>exp</dname> is a favorite function of mine,
	    because it is used in the compounding interest formula, which is:
	    T = Pert (The resulting Total money is Principal multiplied by e 
	    to the rt power (rate times time)).  So, 10000 USD will be over
	    33000 USD if held for twelve years in an account earning 10 
	    percent, as shown by the result of:
          </para>
          <programlisting>
10000 * exp(12 * 0.1)</programlisting>
          <para>How many years will it take to make 1000000 USD if you
	    start investing 10000 USD at 21 percent and add 500 USD per month?
	  </para>
	</defdescription>
      </dylangenericdef>
    </sect1>

  </CHAPTER>

  <CHAPTER ID="libs-time">
    <DOCINFO>
      <TITLE>Time Library</TITLE>
      <DATE>November 15, 2000</DATE>
      <AUTHORGROUP>
	<AUTHOR>&person.auclair;</AUTHOR>
      </AUTHORGROUP>
    </DOCINFO>

    <TITLE>The Time Library</TITLE>

    <PARA>
      Time is a library of routines for working with time and dates.
    </PARA>

    <sect1 id="libs-time-time">
      <title>The Time Module</title>
      <para>
        This module contains the basic time classes, encoding and
        decoding helper classes, functions to
        convert between times, and functions to get the current time. 
      </para>

      <dylanconstantdef>
        <defname>&lt;universal-time&gt;</defname>
	<defsummary>
	  A simple
	  <dclass>general-integer</dclass> representation
	  of the number of seconds since 00:00:00 1 January 1970,
	  UTC. 
	</defsummary>
	<deftype>&lt;integer&gt; or &lt;extended-integer&gt;</deftype>
	<defdescription>
	  <para>
	    Using <dclass>extended-integer</dclass>s
	    guarantees that you can represent any date after 1 Jan
	    1970.  Using <dclass>integer</dclass>s will
	    break for dates after a certain date (depending on
	    <constant>$maximum-integer</constant>) and can sometimes
	    cause unpredictable behavior. 
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanconstantdef>
        <defname>&lt;seconds&gt;</defname>
	<defsummary>
	  An <dclass>integer</dclass> between 0 and 59
	  inclusive.
	</defsummary>
	<deftype>limited(&lt;integer&gt;, min: 0, max: 59)</deftype>
	<defdescription>
	  <para>
	    Ensures the seconds slot of
	    <dclass>decoded-time</dclass> is valid.
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanconstantdef>
        <defname>&lt;minutes&gt;</defname>
	<defsummary>
	  An <dclass>integer</dclass> between 0 and 59
	  inclusive.
	</defsummary>
	<deftype>limited(&lt;integer&gt;, min: 0, max: 59)</deftype>
	<defdescription>
	  <para>
	    Ensures the minutes slot of
	    <dclass>decoded-time</dclass> is valid.
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanconstantdef>
        <defname>&lt;hours&gt;</defname>
	<defsummary>
	  An <dclass>integer</dclass> between 0 and 23
	  inclusive.
	</defsummary>
	<deftype>limited(&lt;integer&gt;, min: 0, max: 23)</deftype>
	<defdescription>
	  <para>
	    Ensures the hours slot of
	    <dclass>decoded-time</dclass> is valid.
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanconstantdef>
        <defname>&lt;day-of-week&gt;</defname>
	<defsummary>
	  An <dclass>integer</dclass> between 0 and 6
	  inclusive.
	</defsummary>
	<deftype>limited(&lt;integer&gt;, min: 0, max: 6)</deftype>
	<defdescription>
	  <para>
	    Ensures the day-of-week slot of
	    <dclass>decoded-time</dclass> is valid.  The
	    first day of the week (or 0) is Monday.
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanconstantdef>
        <defname>&lt;day-of-month&gt;</defname>
	<defsummary>
	  An <dclass>integer</dclass> between 1 and 31
	  inclusive.
	</defsummary>
	<deftype>limited(&lt;integer&gt;, min: 1, max: 31)</deftype>
	<defdescription>
	  <para>
	    Ensures the day-of-month slot of
	    <dclass>decoded-time</dclass> is valid.
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanconstantdef>
        <defname>&lt;month&gt;</defname>
	<defsummary>
	  An <dclass>integer</dclass> between 1 and 12
	  inclusive.
	</defsummary>
	<deftype>limited(&lt;integer&gt;, min: 1, max: 12)</deftype>
	<defdescription>
	  <para>
	    Ensures the month slot of
	    <dclass>decoded-time</dclass> is valid.
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanconstantdef>
        <defname>&lt;timezone&gt;</defname>
	<defsummary>
	  An <dclass>integer</dclass> between -86400 and
	  86400 inclusive.
	</defsummary>
	<deftype>limited(&lt;integer&gt;, min: -86400, max: 86400)</deftype>
	<defdescription>
	  <para>
	    Ensures the timezone slot of
	    <dclass>decoded-time</dclass> is valid.  A
	    <dclass>timezone</dclass> is the seconds
	    west of UTC.
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanconstantdef>
        <defname>&lt;year&gt;</defname>
	<defsummary>
	  A named <dclass>integer</dclass>
	</defsummary>
	<deftype>&lt;integer&gt;</deftype>
	<defdescription>
	  <para>
	    Since every other slot in
	    <dclass>decoded-time</dclass> has a named
	    type, we didn't want the year slot to be lonely.
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanclassdef>
        <defname>&lt;decoded-time&gt;</defname>
	<defadjectives>sealed</defadjectives>
	<defsummary>
	  Decoded time is for representing absolute times in
	  a nice human readable way. 
	</defsummary>
	&obj-super;
  	<definitkeywords>
	  <keyparam>
	    <paramname>seconds</paramname>
	    <paramtype>&lt;seconds></paramtype>
	    <paramdefault>#f</paramdefault>
	    <paramsummary>0 to 59</paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>minutes</paramname>
	    <paramtype>&lt;minutes></paramtype>
	    <paramdefault>#f</paramdefault>
	    <paramsummary>0 to 59</paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>hours</paramname>
	    <paramtype>&lt;hours></paramtype>
	    <paramdefault>#f</paramdefault>
	    <paramsummary>0 to 23</paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>day-of-week</paramname>
	    <paramtype>&lt;day-of-week></paramtype>
	    <paramdefault>#f</paramdefault>
	    <paramsummary>0 to 6</paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>day-of-month</paramname>
	    <paramtype>&lt;day-of-month></paramtype>
	    <paramdefault>#f</paramdefault>
	    <paramsummary>1 to 31</paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>month</paramname>
	    <paramtype>&lt;month></paramtype>
	    <paramdefault>#f</paramdefault>
	    <paramsummary>1 to 12</paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>year</paramname>
	    <paramtype>&lt;year></paramtype>
	    <paramdefault>#f</paramdefault>
	    <paramsummary>
	      Year can be any integer (even negative ones); however,
	      <dclass>decoded-time</dclass> starts from 1970.
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>daylight-savings-time?</paramname>
	    <paramtype>&lt;boolean></paramtype>
	    <paramdefault>(uninitialized)</paramdefault>
	    <paramsummary>
	      Is this decoded time adjusted for daylight savings time
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>timezone</paramname>
	    <paramtype>&lt;timezone></paramtype>
	    <paramdefault>#f</paramdefault>
	    <paramsummary>
	      -86400 to 86400.  If this keyword specified, the
	      functions in the time library assume that it is the
	      correct timezone and ignore the
	      daylight-savings-time? flag. Therefore if you
	      encode a <dclass>decoded-time</dclass> with
	      the timezone representing EST and the daylight-savings-time?
	      flag set to &true;, it will convert the time assuming
	      the local timezone is EST, not EDT.
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>default-from</paramname>
	    <paramtype>&lt;decoded-time></paramtype>
	    <paramdefault>$null-decoded-time</paramdefault>
	    <paramsummary>
	      Allows initialization from another
	      <dclass>decoded-time</dclass> instance.
	      If default-from: is specified, any slot that isn't
	      specified via an init-keyword will take its value of the
	      this slot's object.  If this keyword is not
	      specified, any slot not specified via an init-keyword
	      will have a value of &false;.
	    </paramsummary>
	  </keyparam>
  	</definitkeywords>
  	<defdescription>
  	  <para>
	    Note that there's no point in not defining a <dname>print-object</dname>
	    method, since the parse-time stuff already uses streams.
	    Might as well use print and format, too. 
	  </para>
	  <para>
	    We don't write "hh:mm:ss mm/dd/yy" or anything clever like
	    that because it might not look so hot with undefined
	    slots.  (Besides, mm/dd/yy is rather ambiguous)
	  </para>
	</defdescription>
      </dylanclassdef>

      <dylanconstantdef>
        <defname>$null-decoded-time</defname>
	<defsummary>
	  A <dclass>decoded-time</dclass> where all the
	  slots are initialized to &false;
	</defsummary>
	<deftype>&lt;decoded-time&gt;</deftype>
	<defdescription>
	  <para>
	    This is an internal constant used to default the
	    <dclass>decoded-time</dclass> when the
	    default-from: keyword is used.
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanconstantdef>
        <defname>$default-time</defname>
	<defsummary>
	  A <dclass>decoded-time</dclass> where all the
	  slots are initialized to 0 or 1 (or, in the case of
	  daylight-savings-time?, &false;)
	</defsummary>
	<deftype>&lt;decoded-time&gt;</deftype>
	<defdescription>
	  <para>
	    This constant gives a "0"
	    <dclass>decoded-time</dclass>.  Of note here
	    is that the year slot is initialized to 0, not 1970.  Is
	    this an error?
	  </para>
	</defdescription>
      </dylanconstantdef>

      <dylanmethoddef>
  	<defname>get-universal-time</defname>
  	<defsummary>
	  Return the current time as a
	  <dclass>universal-time</dclass>. 
  	</defsummary>
  	<defparameters>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>current-time</paramname>
  	    <paramtype>&lt;universal-time&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
	    Recall that <dclass>universal-time</dclass>
	    is an <dclass>integer</dclass> (seconds)
	    from 01 Jan 00:00:00Z 1970.  Use other functions to decode
	    this value. 
  	  </para>
  	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
  	<defname>get-decoded-time</defname>
  	<defsummary>
	  Return the current time as a
	  <dclass>decoded-time</dclass>. 
  	</defsummary>
  	<defparameters>
  	  <keyparam>
  	    <paramname>timezone</paramname>
  	    <paramtype>&lt;timezone&gt;</paramtype>
  	    <paramsummary>
	      If supplied, uses the timezone to convert the current
	      universal time.
  	    </paramsummary>
  	  </keyparam>
	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>current-time</paramname>
  	    <paramtype>&lt;decoded-time&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
	    This gives the current time, this time decoded into the
	    appropriate slots.  If timezone is supplied, then that
	    time is converted to the time in that timezone.
  	  </para>
  	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
  	<defname>decode-time</defname>
  	<defsummary>
	  Decode a <dclass>universal-time</dclass>
  	</defsummary>
  	<defparameters>
	  <param>
	    <paramname>universal-time</paramname>
	    <paramtype>&lt;universal-time&gt;</paramtype>
	    <paramsummary>The time to be decoded</paramsummary>
	  </param>
  	  <keyparam>
  	    <paramname>timezone</paramname>
  	    <paramtype>&lt;timezone&gt;</paramtype>
  	    <paramsummary>
	      If supplied, uses the timezone to convert the current
	      universal time.
  	    </paramsummary>
  	  </keyparam>
	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>decoded-time</paramname>
  	    <paramtype>&lt;decoded-time&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
	    Decode a <dclass>universal-time</dclass> into
	    a <dclass>decoded-time</dclass> using the
	    supplied timezone. 	  
	  </para>
  	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
  	<defname>encode-time</defname>
  	<defsummary>
	  Encode a <dclass>decoded-time</dclass>
  	</defsummary>
  	<defparameters>
	  <param>
	    <paramname>decoded-time</paramname>
	    <paramtype>&lt;decoded-time&gt;</paramtype>
	    <paramsummary>The time to be encoded</paramsummary>
	  </param>
	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>universal-time</paramname>
  	    <paramtype>&lt;universal-time&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
	    Encode a <dclass>decoded-time</dclass> into
	    the universal time format.
	  </para>
  	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
  	<defname>encodable-time?</defname>
  	<defsummary>
	  Sees if time can be encoded.
  	</defsummary>
  	<defparameters>
	  <param>
	    <paramname>time</paramname>
	    <paramtype>&lt;decoded-time&gt;</paramtype>
	    <paramsummary>The time to be tested</paramsummary>
	  </param>
	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>result</paramname>
  	    <paramtype>&lt;boolean&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
	    Returns &true; if time may be encoded.  A
	    <dclass>decoded-time</dclass> is encodable
	    if all of its slots are specified, except possibly day-of-week.
	  </para>
  	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
  	<defname>as</defname>
  	<defsummary>
	  Provides the <dname>as</dname> interface to get a
	  <dclass>decoded-time</dclass>.
  	</defsummary>
  	<defparameters>
	  <param>
	    <paramname>cls</paramname>
	    <paramtype>singleton(&lt;decoded-time&gt;)</paramtype>
	    <paramsummary>The type of the instance returned</paramsummary>
	  </param>
	  <param>
	    <paramname>universal-time</paramname>
	    <paramtype>&lt;universal-time&gt;</paramtype>
	    <paramsummary>the instance to decode</paramsummary>
	  </param>
	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>decoded-time</paramname>
  	    <paramtype>&lt;decoded-time&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
	    Decode a <dclass>universal-time</dclass> into
	    a <dclass>decoded-time</dclass> the
	    timezone is 0 for this method.
	  </para>
  	</defdescription>
      </dylanmethoddef>


    </sect1>
    <sect1 id="libs-time-timeio">
      <title>The Time-IO Module</title>
      <para>
        This module contains functions for basic time input and output.
      </para>


      <dylanmethoddef>
  	<defname>format-time</defname>
  	<defsummary>
	  Writes a <dclass>decoded-time</dclass> to a
	  <dclass>stream</dclass> according to a
	  format-string directive.
  	</defsummary>
  	<defparameters>
	  <param>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	    <paramsummary>Where the formatted time is going</paramsummary>
	  </param>
	  <param>
	    <paramname>format</paramname>
	    <paramtype>&lt;string&gt;</paramtype>
	    <paramsummary>
	      The instructions for formatting the time
	    </paramsummary>
	  </param>
	  <param>
	    <paramname>time</paramname>
	    <paramtype>&lt;decoded-time&gt;</paramtype>
	    <paramsummary>The time instance to format</paramsummary>
	  </param>
	</defparameters>
  	<defreturns>
  	</defreturns>
  	<defdescription>
  	  <para>
	    Format a <dclass>decoded-time</dclass> for
	    output on a <dclass>stream</dclass>.  The
	    format arguments are described in the next section.
	  </para>
  	</defdescription>
      </dylanmethoddef>

      <dylanfunctiondef>
        <defname>parse-time</defname>
	<defsummary>
	  Takes data on a stream and applies format arguments to
	  return a <dclass>decoded-time</dclass>.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname>input</paramname>
  	    <paramtype>&lt;stream&gt;</paramtype>
  	    <paramsummary>
	      Contains input data to be converted	      
  	    </paramsummary>
  	  </param>
  	  <param>
  	    <paramname>format-string</paramname>
  	    <paramtype>&lt;string&gt;</paramtype>
  	    <paramsummary>
	      Contains formatting directives (described in
	      <dmodule>Time-IO</dmodule>) to parse the data on the
	      stream into a
	      <dclass>decoded-time</dclass> instance.
  	    </paramsummary>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname>res</paramname>
  	    <paramtype>&lt;decoded-time&gt;</paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
	    Very useful function for when (e.g.) a user is asked to
  	    enter time information, or when (e.g.) reading in a text
  	    file of records which include dates or times.
  	    <dname>Parse-time</dname> allows the program to
  	    convert the input into a
  	    <dclass>decoded-time</dclass> instance.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>

      <para>
        This module contains two internal classes that provide
        information on the parse process
      </para>

      <dylanclassdef>
        <defname>&lt;parse-time-error&gt;</defname>
	<defadjectives>sealed</defadjectives>
	<defsummary>
	  Contains the error in parsing time format directives.
	</defsummary>
	<defsupers>
  	  <defsuper>
  	    &lt;error&gt;
  	  </defsuper>
  	</defsupers>
  	<definitkeywords>
	  <keyparam>
	    <paramname>parse-state</paramname>
	    <paramtype>&lt;parse-state&gt;</paramtype>
	    <paramsummary>
	      The <dclass>parse-state</dclass> class is
	      described below
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>error-format-string</paramname>
	    <paramtype>&lt;string&gt;</paramtype>
	    <paramsummary>
	      The control string for textual error representation
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>error-format-args</paramname>
	    <paramtype>&lt;sequence&gt;</paramtype>
	    <paramsummary>The arguments to the format-string</paramsummary>
	  </keyparam>
  	</definitkeywords>
  	<defdescription>
  	  <para>
	    The error we signal when we have trouble parsing
	    something.  Note that an unknown format directive is *not*
	    considered a
	    <dclass>time-parsing-error</dclass>, but a
	    normal, unnamed (and close to uncatchable) error.
	  </para>
	</defdescription>
      </dylanclassdef>

      <dylanclassdef>
        <defname>&lt;parse-state&gt;</defname>
	<defadjectives>sealed</defadjectives>
	<defsummary>
	  A parser containing the input stream, the formatting
	  directives, and information about the status on the parse
	  process.
	</defsummary>
	&obj-super;
  	<definitkeywords>
	  <keyparam>
	    <paramname>format-string</paramname>
	    <paramtype>&lt;string&gt;</paramtype>
	    <paramsummary>
	      The format-string we are trying to parse the time with
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>format-stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	    <paramsummary>
	      format-string, as a stream
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>input-stream</paramname>
	    <paramtype>&lt;stream&gt;</paramtype>
	    <paramsummary>
	      The stream we're trying to parse
	    </paramsummary>
	  </keyparam>
  	</definitkeywords>
  	<defdescription>
  	  <para>
	    This class contains several other slots containing
	    information about the parse state:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para>
	        <dlit>current-directive</dlit>: The directive we're
		currently trying to process, or #f if we're not trying
		to process one.  Used by the error handling stuff to
		give informative messages. 
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        <dlit>parsed-hour</dlit>:  slot used when parsing
	        12-hour hours.  Untouched when parsing 24-hour hours.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        <dlit>pm?</dlit>: (defaults to &false;), a parsed-hour
	        helper. 
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        <dlit>parsed-day-of-year</dlit>: We change this if
		we're asked to read in a day-of-year.  Since we can't
		make sense of a day-of-year without knowning if it's a
		leap-year (and thus, knowing the year), we delay
		processing of this information
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        <dlit>parsed-year</dlit>: Used for processing
		day-of-year.  The
		<dclass>decoded-time</dclass> doesn't
		actually get it's year from this slot, it gets that
		from the init-args.
	      </para>
	    </listitem>
	  </itemizedlist>
	</defdescription>
      </dylanclassdef>

    </sect1>
    <sect1 id="libs-time-parse">
      <title>Parse-Time Directives</title>
      <para>
        The following directives tell how to print or to parse times.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    %a -- abbreviated weekday name
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %A -- full weekday name
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %b -- abbreviated month name
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %B -- full month name
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %c -- local date and time representation
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %d -- day of the month (01-31)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %H -- hour (24-hour clock) (00-23)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %I -- hour (12-hour clock) (01-12)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %j -- day of the year (001-366)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %m -- month (01-12)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %M -- minute (00-59)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %p -- local equivalent of AM or PM
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %S -- second (00-59)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %U -- week number of the year (Sunday as 1st day of the
	    week) (00-53)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %w -- weekday (0-6, Sunday is 0)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %W -- week number of the year (Monday as 1st day of the
	    week) (00-53)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %x -- local date representation
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %X -- local time representation
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %y -- year without century (00-99)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %Y -- year with century
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %Z -- time zone name, if any
	  </para>
	</listitem>
	<listitem>
	  <para>
	    %% -- the % character
	  </para>
	</listitem>
      </itemizedlist>
      <para>
        See <xref linkend="libs-format-example-using-m-complex">,
        which demonstrates using these time-formatting commands to
        display time in a human-readable format.
      </para>
    </sect1>
  </CHAPTER>

  <CHAPTER ID="libs-random">
    <docinfo>
      <title>Random Library</title>
      <date>November 17, 2000</date>
      <author>&person.auclair;</author>
    </docinfo>

    <TITLE>The Random Library</TITLE>
    <PARA>
      The Random library provides random number support in several
      random number distributions.  This is a replacement for David
      Pierce's Random library.  This one is strongly based on Common
      Lisp.  Much of the implementation has been translated from
      CMUCL's rand.lisp, which was written by David Adam.  Code that
      turns a uniform random distribution into Gaussian and
      exponential distributions has been adapted from David Pierce's
      library. 
    </PARA>

    <sect1 id="libs-random-random">
      <title>The Random Module</title>

      <dylanmethoddef>
        <defname>random</defname>
	<defsummary>
	  Generates a random integer
	</defsummary>
	<defparameters>
	  <param>
	    <paramname>arg</paramname>
	    <paramtype>&lt;integer&gt;</paramtype>
	    <paramsummary>Maximum number generated</paramsummary>
	  </param>
	  <keyparam>
	    <paramname>state</paramname>
	    <paramtype>&lt;random-state&gt;</paramtype>
	    <paramdefault>*random-state*</paramdefault>
	    <paramsummary>
	      The state used to generate the random
	      number
	    </paramsummary>
	  </keyparam>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>random-number</paramname>
	    <paramtype>&lt;integer&gt;</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    Return a random integer between 0 (inclusive) and 
            <parameter>arg</parameter>
	    (exclusive).  We return the same kind of integer that arg
	    is. 
	  </para>
	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>random-bits</defname>
	<defsummary>
	  Generates a random series of bits
	</defsummary>
	<defparameters>
	  <keyparam>
	    <paramname>state</paramname>
	    <paramtype>&lt;random-state&gt;</paramtype>
	    <paramdefault>*random-state*</paramdefault>
	    <paramsummary>
	      The state used to generate the random
	      bit series.
	    </paramsummary>
	  </keyparam>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>bits</paramname>
	    <paramtype>&lt;integer&gt;</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    Returns a fixed integer that has
	    <constant>$random-bits-count</constant >
	    random bits. This function is the fastest way to get a
	    random series of bits. 
	  </para>
	</defdescription>
      </dylanmethoddef>

      <dylanconstantdef>
        <defname>$random-bits-count</defname>
        <defsummary>
	  Number of bits returned by random-bits.
        </defsummary>
        <deftype>
          &lt;integer&gt;
        </deftype>
        <defdescription>
          <para>
	    The computation of this constant takes the upper bound
	    integer (a number larger than 1e+9) bit size and adjusts
	    to avoid loss of randomness near the limit.
          </para>
        </defdescription>
      </dylanconstantdef>

      <dylanclassdef>
        <defname>&lt;random-state&gt;</defname>
	<defadjectives>
	  sealed
	  instantiable
	</defadjectives>
	<defsummary>
	  Used to compute a random number
	</defsummary>
	&obj-super;
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
	    The <dclass>random-state</dclass> has slots
	    that maintain a seed state so that a new random number can
	    be generated.
	  </para>
	</defdescription>
      </dylanclassdef>

      <dylanvariabledef>
        <defname>*random-state*</defname>
	<defsummary>
	  An instance that maintains the random state
	</defsummary>
	<deftype>&lt;random-state&gt;</deftype>
	<defdescription>
	  <para>
	    Used, by default, to compute random integers and series of
	    bits
	  </para>
	</defdescription>
      </dylanvariabledef>

    </sect1>
  </CHAPTER>
  
  <CHAPTER ID="libs-matrix">
    <docinfo>
      <title>Matrix Library</title>
      <date>November 18, 2000</date>
      <author>&person.auclair;</author>
    </docinfo>
    <TITLE>The Matrix Library</TITLE>
    <PARA>
      This library implements some basic matrix operations. These
      functions are not guarenteed to be stable or numerically sound,
      nor are they very optimized, but for smaller applications they
      should be suitable.  
    </para>
    <para>
      The <dclass>matrix</dclass> class is a subclass of
      <dclass>array</dclass>, so all operations on
      <dclass>array</dclass>s and collections in general
      should work as expected. One important limitation of matrices is
      that they are limited to two dimensions, and trying to use any
      other size results in an error. The
      <dclass>matrix</dclass> class has two ways to get
      instances and several operations for those instances. 
    </PARA>
    <sect1 id="libs-matrix-initialization">
      <title>Initialization</title>
      <dylanclassdef>
	<defname>&lt;matrix&gt;</defname>
	<defadjectives>sealed</defadjectives>
	<defsummary>Meta-information container</defsummary>
	<defsupers><defsuper>&lt;array&gt;</defsuper></defsupers>
	<definitkeywords></definitkeywords>
	<defdescription>
	  <para>
	    This class contains two slots:  dimensions, a
	    <dclass>sequence</dclass>, which contains
	    the two values of the size of the matrix, and components,
	    a <dclass>simple-object-vector</dclass>,
	    that contain the matrix elements.
	  </para>
	</defdescription>
      </dylanclassdef>

      <dylanmethoddef>
	<defname>initialize</defname>
	<defsummary>
	  Used by <dname>make</dname> to create instances of a
	  <dclass>matrix</dclass>
	</defsummary>
	<defparameters>
	  <keyparam>	
	    <paramname>dimensions</paramname>
	    <paramdefault>#[1, 1]</paramdefault>
	    <paramsummary>
	      A sequence of two elements which represent the rows and
	      column of the matrix respectively 
	    </paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>fill</paramname>
	    <paramdefault>0</paramdefault>
	    <paramsummary>
	      The objects that each element of matrix should be
	      initialized to
	    </paramsummary>
	  </keyparam>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>mat</paramname>
	    <paramtype>&lt;matrix&gt;</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    Use <dname>make</dname> with the above keywords to
	    obtain a <dclass>matrix</dclass> instance
	  </para>
	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
	<defname>matrix</defname>
	<defsummary>
	  Create instances of a <dclass>matrix</dclass>
	  from a list of <dclass>vector</dclass>s
	</defsummary>
	<defparameters>
	  <restparam>	
	    <paramname>row-vectors</paramname>
	  </restparam>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>mat</paramname>
	    <paramtype>&lt;matrix&gt;</paramtype>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    This method takes a list of
	    <dclass>vectors</dclass> and creates a
	    <dclass>matrix</dclass> instance from them,
	    for example:
	  </para>
	  <programlisting>
let mat = matrix(#[1, 1, 2], #[3, 5, 8], #[13, 21, 34]);
	  </programlisting>
	  <para>creates a 3x3 matrix.</para>
	  <para>Note: The row-vectors must all be of the same size.</para>
	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
	<defname>identity-matrix</defname>
	<defsummary>Creates the identity matrix</defsummary>
	<defparameters>
	  <keyparam>	
	    <paramname>dimensions</paramname>
	    <paramdefault>#[1, 1]</paramdefault>
	    <paramsummary>
	      Note: enter 2 dimensions for the matrix, an error may
	      occur if both dimensions are not equal.
	    </paramsummary>
	  </keyparam>
	</defparameters>
	<defreturns>
	  <param>
	    <paramname>mat</paramname>
	    <paramtype>&lt;matrix&gt;</paramtype>
	    <paramsummary>
	      The identity matrix, sized to dimensions
	    </paramsummary>
	  </param>
	</defreturns>
	<defdescription>
	  <para>
	    This function simply returns the identity matrix of the
	    specified dimension.  It is a very simple algorithm, it
	    merely fills a matrix with zeros, and then puts ones down
	    the diagonal. 
	    </para>
	  </defdescription>
	</dylanmethoddef>

    </sect1>
    <sect1 id="libs-matrix-operations">
      <title>Matrix Operations</title>
      <para>
        These are operations on matrices.  The include the "simple"
        arithmetic operations (\+, \-, \*), as well as other standard
        matrix operations, such as inverse, transpose, augment, and
        gauss-jordan elimations.
      </para> 

      <dylanmethoddef>
        <defname>\+</defname>
        <defsummary>Adds two matrices.</defsummary>
        <defparameters>
          <param>
            <paramname>matrix1</paramname>
            <paramtype>&lt;matrix&gt;</paramtype>
          </param>
          <param>
            <paramname>matrix2</paramname>
            <paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defparameters>
        <defreturns>
	    <param>
		<paramname>summation-matrix</paramname>
		<paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
	    Adds two matrices.  This is a binary operator that
	    performs matrix addition on the matrices "matrix1" and
	    "matrix2", storing the result in a new matrix "temp-mat",
	    "temp-mat" is then returned on exit.  Matrix addition is
	    very simple, all it is is adding terms in corresponding
	    positions 
          </para>
        </defdescription>
      </dylanmethoddef>
	
      <dylanmethoddef>
        <defname>\-</defname>
        <defsummary>Subtracts two matrices.</defsummary>
        <defparameters>
          <param>
            <paramname>matrix1</paramname>
            <paramtype>&lt;matrix&gt;</paramtype>
          </param>
          <param>
            <paramname>matrix2</paramname>
            <paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defparameters>
        <defreturns>
	    <param>
		<paramname>difference-matrix</paramname>
		<paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
	    Matrix subtraction is (surprise) just like matrix
	    addition, where the element i,j in (A - B) is (A[i,j] -
	    B[i,j]) 
          </para>
        </defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>\*</defname>
        <defsummary>Multiplies a matrix by a scalar.</defsummary>
        <defparameters>
          <param>
            <paramname>a</paramname>
            <paramtype>&lt;number&gt;</paramtype>
          </param>
          <param>
            <paramname>matrix1</paramname>
            <paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defparameters>
        <defreturns>
	    <param>
		<paramname>product-matrix</paramname>
		<paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
	    Multiplication of a matrix and a scalar quantity.  This
	    simply multiplies each element of the matrix by the scalar
	    quantity. 
          </para>
        </defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>\*</defname>
        <defsummary>Multiplies a matrix by a scalar.</defsummary>
        <defparameters>
          <param>
            <paramname>a</paramname>
            <paramtype>&lt;number&gt;</paramtype>
          </param>
          <param>
            <paramname>matrix1</paramname>
            <paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defparameters>
        <defreturns>
	    <param>
		<paramname>product-matrix</paramname>
		<paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
	    Same as the above <dname>\*</dname>, with the
	    opposite order of the parameters. 
          </para>
        </defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>\*</defname>
        <defsummary>Multiplies two matrices.</defsummary>
        <defparameters>
          <param>
            <paramname>matrix1</paramname>
            <paramtype>&lt;number&gt;</paramtype>
          </param>
          <param>
            <paramname>matrix2</paramname>
            <paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defparameters>
        <defreturns>
	    <param>
		<paramname>mult-matrix</paramname>
		<paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
	    Multiplies two matrices.  There are certain restrictions
	    on what matrices can be multiplied.  To multiply two
	    matrices, the dimensions must be MxN for the first matrix,
	    and NxP for the second.  The result of the multiplication
	    will be an MxP matrix.  (Note, this implies A * B is not
	    necessarily equal to B * A)  The element i,j in A * B is
	    the dot (inner) product of the ith row of A with the jth
	    column of B.  The dot product of a vector is the sum of
	    the products of corresponding elements. That is,  if
	    vector V=[a,b,c,d] and vector W=[w,x,y,z] then V*W= aw +
	    bx + cy + dz (Note that this is a scalar quantity).
	  </para> 
	  <para>
	    The actual algorithm used was reproduced from Sedgewick's
	    Algorithms, Ch. 36. Basically, the algorithm goes through
	    the temporary matrix, filling out each element in the
	    following way: For the i,jth element of the matrix,
	    calculate the dot product an element at a time, by having
	    a number k  range from 0 to the dimension N of the matrix.
	    Take A[i,k] and multiply it by B[k,j] to get one of the
	    terms in the dot product.  Continue this for each element
	    in the MxP matrix to get the result. 
	  </para>
        </defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>augment-matrix</defname>
        <defsummary>A special way to concatenate two matrices.</defsummary>
        <defparameters>
          <param>
            <paramname>matrix1</paramname>
            <paramtype>&lt;number&gt;</paramtype>
          </param>
          <param>
            <paramname>matrix2</paramname>
            <paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defparameters>
        <defreturns>
	    <param>
		<paramname>augmented-matrix</paramname>
		<paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
	    The augment-matrix procedure will take matrices A and B
	    and return a matrix | A B |. 
  	  </para>
        </defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>gauss-jordan</defname>
        <defsummary>Does a Gauss-Jordan elimination on a matrix.</defsummary>
        <defparameters>
          <param>
            <paramname>matrix1</paramname>
            <paramtype>&lt;number&gt;</paramtype>
          </param>
        </defparameters>
        <defreturns>
	    <param>
		<paramname>solution-matrix</paramname>
		<paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
	    This procedure does gauss-jordan elimation on a matrix of
	    dimension N by N + 1.  The first N columns are the
	    coefficents in a set of simultaneous equations, and the
	    last column is a solution vector.   The matrix that is
	    returned is an N by 1 matrix contaning the solution for
	    each variable.   For example, if you have a system of
	    equations like this: 
  	  </para>
	  <programlisting>
 2x + 4y - 2z = 2
 4x + 9y - 3z = 8
-2x - 3y + 7z = 10 
	  </programlisting>
	  <para>The matrix representing this would be </para>
	  <programlisting>
|  2  4 -2  2 |
|  4  9 -3  8 |
| -2 -3  7 10 |
	  </programlisting>
	  <para>The solution matrix returned would be:</para>
	  <programlisting>
| -1 |
|  2 |
|  2 |
	  </programlisting>
	  <para>where x is -1, y is 2, and z is 2</para>
	</defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>inverse</defname>
        <defsummary>Finds the inverse of a matrix.</defsummary>
        <defparameters>
          <param>
            <paramname>matrix1</paramname>
            <paramtype>&lt;number&gt;</paramtype>
          </param>
        </defparameters>
        <defreturns>
	    <param>
		<paramname>inverted-matrix</paramname>
		<paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
	    Finds the inverse of a matrix, by using a modified
	    gauss-jordan elimination.  Given any matrix, if there is
	    an inverse, the inverse will be returned, otherwise, an
	    error will be signalled. To determine the existance of an
	    inverse, the algorithm finds the upper triangular matrix,
	    and then multiplies all of the elements along the main
	    diagonal.  If the result of this multiplication is zero,
	    there is no inverse, otherwise, there is gaurenteed to be
	    an inverse. 
	  </para>
        </defdescription>
      </dylanmethoddef>

      <dylanmethoddef>
        <defname>det</defname>
        <defsummary>Returns the determinant of a matrix.</defsummary>
        <defparameters>
          <param>
            <paramname>matrix1</paramname>
            <paramtype>&lt;number&gt;</paramtype>
          </param>
        </defparameters>
        <defreturns>
	    <param>
		<paramname>determinant</paramname>
		<paramtype>&lt;number&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
	    This just does what the first half of inverse does. It
	    reduces the matrix to the upper triangular form, and then
	    returns the product of all of the elements along the
	    diagonal.  This is the determinant of the matrix. 
	  </para>
        </defdescription>
      </dylanmethoddef>
      <dylanmethoddef>
        <defname>inverse</defname>
        <defsummary>Returns the matrix transposed.</defsummary>
        <defparameters>
          <param>
            <paramname>matrix1</paramname>
            <paramtype>&lt;number&gt;</paramtype>
          </param>
        </defparameters>
        <defreturns>
	    <param>
		<paramname>transposed-matrix</paramname>
		<paramtype>&lt;matrix&gt;</paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
	    This function transposes a matrix.  It takes a M by N
	    matrix and turns it into an N by M matrix.  All it does is
	    take the i,jth element in the M by N matrix, and turns it
	    into the j,ith element in the N by M matrix. 
	  </para>
        </defdescription>
      </dylanmethoddef>


    </sect1>
  </CHAPTER>

  <chapter ID="libs-parse-arguments">
    <docinfo>
      <author>
	&person.emk;
      </author>
    </docinfo>

    <title>The Parse-Arguments Library</title>
    
    <para>The <dlibrary>Parse-Arguments</dlibrary> library provides a
    simple and flexible way to parse the command-line arguments of a Dylan
    program. It provides support for the most common types of command-line
    options, and can be extended to suit the needs of a particular
    application.</para>

    <sect1 id="libs-parse-arguments-terminology">
      <title>Terminology</title>

      <para>The <dlibrary>Parse-Arguments</dlibrary> library uses a
      standard set of terminology for representing the tokens which might
      appear on a command line.</para>

      <figure id="libs-parse-arguments-cmdline-1">
	<title>Sample command line.</title>
<screen>
<prompt>$</prompt> sample-app -v --repeat -n=10 foo.txt -- bar.txt
</screen>
      </figure>
      
      <glosslist>
	<glossentry>
	  <glossterm>application name</glossterm>
	  <glossdef>
	    <para>The application name appears first on the command
	    line. Under Unix-like systems, the application name is passed
	    to the program exactly as typed. In particular, it may be the
	    name of a symlink or include one or more directory
	    components.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>command-line arguments</glossterm>
	  <glossdef>
	    <para>Everything appearing after the application name is a
	    command-line argument.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>regular argument</glossterm>
	  <glossdef>
	    <para>In <xref linkend="libs-parse-arguments-cmdline-1">,
	    <literal>foo.txt</literal> and <literal>bar.txt</literal> are
	    regular arguments.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>option</glossterm>
	  <glossdef>
	    <para>Options are also known as flags and switches. They
	    control the behavior of the application, and may appear in one
	    of two forms. <glossterm>Short options</glossterm> always
	    appear after a single dash, but several of them may be grouped
	    together (e.g. <literal>-tzvf</literal> in GNU tar). In <xref
	    linkend="libs-parse-arguments-cmdline-1">,
	    <literal>-v</literal> and <literal>-n</literal> are both short
	    options. <glossterm>Long options</glossterm> such as
	    <literal>--repeat</literal> consist of entire words and are
	    always preceded by two dashes.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>parameter</glossterm>
	  <glossdef>
	    <para>Parameters modify the behavior of an option. In
            <xref linkend="libs-parse-arguments-cmdline-1">, the
	    <literal>10</literal> following <literal>-n</literal> is a
	    parameter. Note that the equals sign may be surrounded by
	    white space or omitted entirely where unambiguous.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>option terminator</glossterm>
	  <glossdef>
	    <para>The double dash without an option name is called an
	    option terminator. Any arguments appearing after the terminator
	    are automatically regular arguments, even if they begin with a
	    dash.</para>
	  </glossdef>
	</glossentry>
      </glosslist>
    </sect1>

    <sect1 id="libs-parse-arguments-example">
      <title>A Simple Example</title>

      <para><xref linkend="libs-parse-arguments-example-library"> and <xref
      linkend="libs-parse-arguments-example-with-macro"> demonstrate how to use
      the parse-arguments library in a simple application.</para>

      <figure id="libs-parse-arguments-example-library">
	<title>Library declaration for a sample application using
	parse-arguments.</title>
<programlisting>
Module: dylan-user

define library sample-application
  use dylan;
  use format-out;
  use parse-arguments;
end library;

define module sample-application
  use dylan;
  use extensions;
  use format-out;
  use parse-arguments;
end module;
</programlisting>
      </figure>


      <figure id="libs-parse-arguments-example-with-macro">
	<title>Source code for a sample application using
	parse-arguments, making use of the <dlit>define argument-parser</dlit> macro.</title>
<programlisting>
Module: sample-application

define argument-parser &lt;sample-parser> ()
  option verbose?, long: "verbose", short: "v";
  option logfile, kind: &lt;parameter-option-parser>, long: "logfile", short: "L";
  regular-arguments file-names;
end;

define method main(program-name :: &lt;string>, #rest arguments)
  let parser = make(&lt;sample-parser>);

  unless (parse-arguments(parser, arguments))
    format-out("Usage: %s [-v] [-Llogfile] files...\n", program-name);
    exit(exit-code: 1);
  end;

  // Body of program.
end;
</programlisting>
      </figure>

      <para>In <xref linkend="libs-parse-arguments-example-with-macro">, the
      variable <dlit>parser.verbose?</dlit> will be set to <dlit>#t</dlit> if
      either <literal>--verbose</literal> or <literal>-v</literal> appears
      on the command line. Otherwise, it will be set to
      <dlit>#f</dlit>. Similarly, if <literal>-Lfilename</literal> or
      <literal>--logfile=filename</literal> appears on the command line,
      the variable <dlit>parser.logfile</dlit> will be set the string
      <literal>"filename"</literal>. Otherwise, it too will be set to
      <dlit>#f</dlit>.</para>

      <para>Any other arguments will be collected and placed in the
      variable <dlit>parser.file-names</dlit>.</para>

      <para><xref linkend="libs-parse-arguments-example-source"> shows
      how to use the <dlibrary>Parse-Arguments</dlibrary> library
      without using the <dlit>define argument-parser</dlit>
      macro. Here the various arguments are added manually, and
      accessed using the <dname>option-value-by-long-name</dname>
      method.</para>

      <figure id="libs-parse-arguments-example-source">
	<title>Source code for a sample application using
	parse-arguments.</title>
<programlisting>
Module: sample-application

define method main(program-name :: &lt;string>, #rest arguments)
  let parser = make(&lt;argument-list-parser>);
  add-option-parser-by-type(parser,
                            &lt;simple-option-parser>,
                            long-options: #("verbose"),
                            short-options: #("v"));
  add-option-parser-by-type(parser,
                            &lt;parameter-option-parser>,
                            long-options: #("logfile"),
                            short-options: #("L"));

  unless (parse-arguments(parser, arguments))
    format-out("Usage: sample-application [-v] [-Llogfile] files...\n");
    exit(exit-code: 1);
  end;

  let verbose? = option-value-by-long-name(parser, "verbose");
  let logfile = option-value-by-long-name(parser, "logfile");
  let file-names = parser.regular-arguments;

  // Body of program.
end;
</programlisting>
      </figure>


      <para>Using the <dname>define argument-parser</dname> is the
      preferred way of using the <dlibrary>Parse-Arguments</dlibrary>
      library. It is both more convenient and better readable. The
      manual way is documented both for users of Mindy, which doesn't
      have macro capabilities, and for advanced users who wish to
      extend the functionality of the option parsers.</para>

    </sect1>

    <sect1 id="libs-parsing-arguments">
      <title>Parsing Arguments</title>
      
      <para>To parse a command-line, you create a new
      <dclass>argument-list-parser</dclass>, connect a number of
      individual <dclass>option-parser</dclass>s, call
      <dname>parse-arguments</dname>, and use the resulting
      information.</para>

      <sect2>
	<title>Argument List Parsers</title>

	<dylanclassdef>
	  <defname>&lt;argument-list-parser></defname>
	  <defadjectives>Sealed</defadjectives>
	  <defsummary>Describes how to parse an argument list, and contains
	  the data found when parsing one.</defsummary>
	  &obj-super;
	  <definitkeywords>
	  </definitkeywords>
	  <defdescription>
	    <para>An <dclass>argument-list-parser</dclass> represents
	    both a description of the data to be found in an argument list,
	    and the results of parsing a particular argument list for that
	    data.</para>

	    <para>Prior to calling <dname>parse-arguments</dname> for the
	    first time, no useful information can be extracted from an
	    argument list parser. Subsequent calls to
	    <dname>parse-arguments</dname> will update the data contained
	    within the parser.</para>
	  </defdescription>
	</dylanclassdef>

	<dylanfunctiondef>
	  <defname>regular-arguments</defname>
	  <defsummary>Returns the regular arguments found by parsing an
	  argument list.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>arguments</paramname>
	      <paramtype>&lt;sequence></paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>After calling <dname>parse-arguments</dname>, this
	    function can be used to find all of the <glossterm>regular
	    arguments</glossterm> that weren't consumed by any option
	    parser.</para>
	  </defdescription>
	</dylanfunctiondef>
      </sect2>

      <sect2>
	<title>Option Parsers</title>

	<dylanclassdef>
	  <defname>&lt;option-parser></defname>
	  <defadjectives>Abstract Open Primary</defadjectives>
	  <defsummary>Parses a single command-line option and any
	  parameters.</defsummary>
	  &obj-super;
	  <definitkeywords>
	    <keyparam>
	      <paramname>long-options</paramname>
	      <paramtype>&lt;list></paramtype>
	      <paramdefault>#()</paramdefault>
	      <paramsummary>Specifies the long options handled by this
	      parser, represented as strings.</paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>short-options</paramname>
	      <paramtype>&lt;list></paramtype>
	      <paramdefault>#()</paramdefault>
	      <paramsummary>Specifies the short options handled by this
	      parser, represented as strings.</paramsummary>
	    </keyparam>
	  </definitkeywords>
	  <defdescription>
	    <para>Different types of command-line options are parsed
	    according to different rules. An
	    <dclass>option-parser</dclass> knows how to handle one type of
	    option. The <dkeyword>long-options</dkeyword> and
	    <dkeyword>short-options</dkeyword> keywords are used to
	    specify which 
	    option names should be handled by a given parser.</para>

	    <para>An option parser can be connected to an
	    <dclass>argument-list-parser</dclass> for and the values to
	    be found. </para>
	  </defdescription>
	</dylanclassdef>
	
	<dylanfunctiondef>
	  <defname>option-present?</defname>
	  <defsummary>Tests whether an option was present on the
	  command-line.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;option-parser></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>present?</paramname>
	      <paramtype>&lt;boolean></paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>Returns &true; if and only if
	    <dname>parse-arguments</dname> found at least one corresponding
	    option on the command line. Returns &false; if
	    <dname>parse-arguments</dname> has not been called.</para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>option-value</defname>
	  <defsummary>Returns the value found by an option parser after
	  processing the command line.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;option-parser></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>value</paramname>
	    </param>	  
	  </defreturns>
	  <defdescription>
	    <para>Returns the value calculated by
            <parameter>parser</parameter> after running
            <dname>parse-arguments</dname>. Returns &false; if
            <dname>parse-arguments</dname> has not been called.</para>

	    <para>The exact type of <parameter>value</parameter> will vary
	    depending on the class of the option parser.</para>
	  </defdescription>
	</dylanfunctiondef>
      </sect2>

      <sect2>
	<title>Parsing an Argument List</title>

	<dylanfunctiondef>
	  <defname>add-option-parser</defname>
	  <defsummary>Attaches an <dclass>option-parser</dclass> to an
	  <dclass>argument-list-parser</dclass>.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>args-parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	    <param>
	      <paramname>option-parser</paramname>
	      <paramtype>&lt;option-parser></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	  </defreturns>
	  <defdescription>
	    <para>Attaches an <dclass>option-parser</dclass> to an
	    <dclass>argument-list-parser</dclass>. It is an error
	    to attach an <dclass>option-parser</dclass> more than once,
	    and no mechanism is provided to detach one.</para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>add-option-parser-by-type</defname>
	  <defsummary>Create an <dclass>option-parser</dclass> and add
	  it to an <dclass>argument-list-parser</dclass>.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>args-parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	    <param>
	      <paramname>option-parser-type</paramname>
	      <paramtype>subclass(&lt;option-parser>)</paramtype>
	      <paramsummary>The class for the new option
	      parser.</paramsummary>
	    </param>
	    <restparam>
	      <paramname>init-keys</paramname>
	      <paramsummary>Inititialization keywords for for the new
	      option parser.</paramsummary>
	    </restparam>
	  </defparameters>
	  <defreturns>
	  </defreturns>
	  <defdescription>
	    <para>This function is equivalent to calling:</para>

	    <programlisting>
let opt-parser =
  apply(make, option-parser-type, init-keys);
add-option-parser(args-parser, opt-parser);
</programlisting>

	    <para>Most programs will use this function instead of
	    <dname>add-option-parser</dname>.</para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>parse-arguments</defname>
	  <defsummary>Parses a list of command-line arguments.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>	      
	    </param>
	    <param>
	      <paramname>argument-list</paramname>
	      <paramtype>&lt;sequence></paramtype>
	      <paramsummary>The strings to be parsed.</paramsummary>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>success?</paramname>
	      <paramtype>&lt;boolean></paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>This routine does most of the work in the
	    <dlibrary>Parse-Arguments</dlibrary> library. It performs a
	    number of different steps:</para>

	    <orderedlist>
	      <listitem>
		<formalpara>
		  <title>Split the argument list</title> <para>If the
		  string <dlit>"--"</dlit> appears in the argument list,
		  discard it, and set aside everything to right for later
		  processing.</para>
		</formalpara>
	      </listitem>
	      <listitem>
		<formalpara>
		  <title>Chop individual arguments around any equals
		  sign</title> <para>If any argument contains the character
		  <dlit>'='</dlit>, break the argument into three strings:
		  everything before the first occurance of the equals sign,
		  the sign itself, and the remainder of the original
		  string.</para>
		</formalpara>
	      </listitem>
	      <listitem>
		<formalpara>
		  <title>Tokenize the argument list</title> <para>Convert
		  the argument list into a series of tokens. For more
		  details on this process, see <xref
		  linkend="libs-parse-arguments-extending">.</para>
		</formalpara>
	      </listitem>
	      <listitem>
		<formalpara>
		  <title>Process the argument list from left to right</title>
		  <para>For each option token, invoke the appropriate
		  option parser (which may consume additional
		  tokens). Record all regular argument tokens for later
		  use. If any other kinds of tokens appear in the argument
		  list, they must be consumed by an option parser or the
		  entire process will fail.</para>
		</formalpara>
	      </listitem>
	      <listitem>
		<formalpara>
		  <title>Collect the regular arguments</title>
		  <para>Take the regular arguments found while parsing,
		  and append any arguments set aside in the first step.</para>
		</formalpara>
	      </listitem>
	    </orderedlist>

	    <para>If an error occurs during this process, parsing will stop
	    immediately and <dname>parse-arguments</dname> will return
	    &false;. Otherwise, it will return &true;.</para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>option-parser-by-long-name</defname>
          <defsummary>Find an option parser, given a corresponding option
	  name.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	    <param>
	      <paramname>long-name</paramname>
	      <paramtype>&lt;string></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>option-parser</paramname>
	      <paramtype>&lt;option-parser></paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>This function can be used to recover an option parser
	    previously attached to an
	    <dclass>argument-list-parser</dclass>.</para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>option-present?-by-long-name</defname>
          <defsummary>Determine whether an option was present, given a
          corresponding option name.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	    <param>
	      <paramname>long-name</paramname>
	      <paramtype>&lt;string></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>present?</paramname>
	      <paramtype>&lt;boolean></paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>This function provides an easy way to determine whether a
	    given option parser found anything in an argument list.</para>

	    <note>
	      <para>If an option has multiple names, any one of
	      them can be used as the argument to this function without
	      changing the result.</para>
	    </note>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>option-value-by-long-name</defname>
          <defsummary>Find the value of an option, given a corresponding
          option name.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	    <param>
	      <paramname>long-name</paramname>
	      <paramtype>&lt;string></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>value</paramname>
	    </param>	  
	  </defreturns>
	  <defdescription>
	    <para>This function provides an easy way to find the value of a
	    particular option parser.</para>

	    <note>
	      <para>If an option has multiple names, any one of
	      them can be used as the argument to this function without
	      changing the result.</para>
	    </note>
	  </defdescription>
	</dylanfunctiondef>
      </sect2>
    </sect1>

    <sect1 id="libs-parse-arguments-option-parsers">
      <title>Standard Option Parser Classes</title>

      <para><dlibrary>Parse-Arguments</dlibrary> supports the most popular
      types of <acronym>POSIX</acronym> and <acronym>GNU</acronym>
      command-line options.</para>

      <dylanclassdef>
	<defname>&lt;negative-option-parser></defname>
	<defadjectives>Abstract Open</defadjectives>
	<defsummary>Parses command-line options which may appear in
	positive and negative forms.</defsummary>
	<defsupers>
	  <defsuper>&lt;option-parser></defsuper>
	</defsupers>
	<definitkeywords>
	  <keyparam>
	    <paramname>negative-long-options</paramname>
	    <paramtype>&lt;list></paramtype>
	    <paramdefault>#()</paramdefault>
	    <paramsummary>Specifies the negative long options handled by
	    this parser, represented as strings.</paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>negative-short-options</paramname>
	    <paramtype>&lt;list></paramtype>
	    <paramdefault>#()</paramdefault>
	    <paramsummary>Specifies the negative short options handled by
	    this parser, represented as strings.</paramsummary>
	  </keyparam>
	</definitkeywords>
	<defdescription>
	  <para>This class is exported from the module
	  <dmodule>option-parser-protocol</dmodule>. We document it here
	  because it is the superclass of
	  <dclass>simple-option-parser</dclass>.</para>

	  <para>Certain command-line options appear in a positive and
	  negative form. For example, many programs accept
	  <literal>--verbose</literal> and <literal>--quiet</literal>
	  options.</para>

	  <para>This class provides internal support for creating parsers
	  to handle such options. It cannot be instantiated.</para>
	</defdescription>
      </dylanclassdef>

      <dylanclassdef>
	<defname>&lt;simple-option-parser></defname>
	<defadjectives>Sealed</defadjectives>
	<defsummary>Parses options without any parameters.</defsummary>
	<defsupers>
	  <defsuper>&lt;negative-option-parser></defsuper>
	</defsupers>
	<definitkeywords>
	  <keyparam>
	    <paramname>default</paramname>
	    <paramtype>&lt;boolean></paramtype>
	    <paramdefault>#f</paramdefault>
	    <paramsummary>Specifies the value returned by this option
	    parser if no applicable options appear on the command
	    line.</paramsummary>
	  </keyparam>
	</definitkeywords>
	<defdescription>
	  <para>Simple options have no parameters, and may appear in both
	  positive and negative forms. When parsing a list of arguments,
	  <dname>option-value</dname> is first set to the default. As the
	  command line is then scanned from left to right, each positive
	  option sets the value to <dlit>#t</dlit> and each negative option
	  sets it to <dlit>#f</dlit>.</para>

	  <para>This behavior is consistent with that of the utility
	  <literal>rm</literal>, which allows the user to set default
	  options with a shell alias of the form <literal>alias rm="rm
	  -i"</literal>. Such defaults can be overriden by explicity
	  passing a flag when calling <literal>rm</literal> because the
	  rightmost value takes precedence.</para>
	</defdescription>
	<defsection>
	  <title>Option Forms</title>
	  
	  <para><literal>-q</literal>, <literal>--quiet</literal>,
	  <literal>-v</literal>, <literal>--verbose</literal></para>
	</defsection>
      </dylanclassdef>

      <dylanclassdef>
	<defname>&lt;parameter-option-parser></defname>
	<defadjectives>Sealed</defadjectives>
	<defsummary>Parses options which have a parameter and which may
        appear only once.</defsummary>
	<defsupers>
	  <defsuper>&lt;option-parser></defsuper>
	</defsupers>
	<definitkeywords>
	</definitkeywords>
	<defdescription>
	  <para>A <dclass>parameter-option-parser</dclass> sets
	  <dname>option-value</dname> to either <dlit>#f</dlit> or a
	  <dclass>string</dclass>. If the option appears more than
	  once on the command line, the rightmost value is used.</para>
	</defdescription>
	<defsection>
	  <title>Option Forms</title>
	  
	  <para><literal>-fname</literal>, <literal>-f name</literal>,
	  <literal>-f=name</literal>, <literal>-f = name</literal>,
	  <literal>--file name</literal>, <literal>--file=name</literal>,
	  <literal>--file = name</literal></para>
	</defsection>
      </dylanclassdef>

      <dylanclassdef>
	<defname>&lt;repeated-parameter-option-parser></defname>
	<defadjectives>Sealed</defadjectives>
	<defsummary>Parses options which have a parameter and which may
	appear more than once.</defsummary>
	<defsupers>
	  <defsuper>&lt;option-parser></defsuper>
	</defsupers>
	<definitkeywords>
	</definitkeywords>
	<defdescription>
	  <para>A <dclass>repeated-parameter-option-parser</dclass> sets
	  <dname>option-value</dname> to a <dclass>sequence</dclass> of
	  strings. </para>
	</defdescription>
	<defsection>
	  <title>Option Forms</title>
	  
	  <para><literal>-fname</literal>, <literal>-f name</literal>,
	  <literal>-f=name</literal>, <literal>-f = name</literal>,
	  <literal>--file name</literal>, <literal>--file=name</literal>,
	  <literal>--file = name</literal></para>
	</defsection>
      </dylanclassdef>
    </sect1>

    <sect1 id="libs-parse-arguments-extending">
      <title>Writing New Option Parser Classes</title>

      <para>This section is empty.</para>
    </sect1>
  </chapter>

  <!-- CHAPTER ID="libs-dylan-tk">
    <TITLE>The TK Library</TITLE>

    <PARA></PARA>
  </CHAPTER -->
</BOOK>
