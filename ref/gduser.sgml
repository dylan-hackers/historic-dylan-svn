<!DOCTYPE BOOK PUBLIC "UNREGISTERED::Eric Kidd//DTD DylanDoc V3.1//EN" [
 <!ENTITY % entities SYSTEM "entities.sgml">
 %entities;
]>
<BOOK ID="gduser">
  <title>Gwydion Dylan User's Guide</title>
  <titleabbrev>User's Guide</titleabbrev>

  <bookinfo>
    <COPYRIGHT>
      <YEAR>1998</YEAR>
      <HOLDER>Carnegie Mellon University</HOLDER>
      <HOLDER>Gwydion Dylan Maintainers</HOLDER>
    </COPYRIGHT>
    &cmu.terms;
    <bookbiblio>
      <date>09 September 1998</date>
      <editor>&person.housel;</editor>
    </bookbiblio>
  </bookinfo>

  <CHAPTER ID="gduser-intro">
    <TITLE>Introduction</TITLE>

    <SECT1 ID="gduser-what-is-dylan">
      <TITLE>What is Dylan?</TITLE>

      <PARA>&dylan; is a fully buzzword-compliant programming
      language. It supports:</PARA>

      <ITEMIZEDLIST>
	
	<LISTITEM>
	  <PARA>An advanced object model, including headache-free
	multiple inheritance</PARA> </LISTITEM>

	<LISTITEM>
	  <PARA>Multiple dispatch, which makes complex object-oriented
	designs simple (research at Harlequin shows that three
	quarters of the concepts illustrated in Design Patterns can be
	implemented more easily in Dylan than in C++ or Java)</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>A choice between efficient static typing as used in
	C++ and Eiffel, and convenient dynamic typing, which is
	commonly associated with scripting and prototyping
	languages</PARA>
	</LISTITEM>
	
	<LISTITEM>
	  <PARA>Convenient goodies to make development easier,
	including garbage collection, functional access to data
	members, and runtime safety</PARA> </LISTITEM>
	
	<LISTITEM>
	  <PARA>Reasonable performance (code generated by the current
	development version of Gwydion runs at a third to half the
	speed of native C)</PARA> </LISTITEM>
	
	<LISTITEM>
	  <PARA>Advanced development tools such as closures, definable
	language constructs and introspection</PARA> </LISTITEM>

      </ITEMIZEDLIST>
      
      <PARA>Dylan is easy to learn, easy to use, and more powerful
      than C++ or Java. It tries to balance the best features of
      traditional compiled languages with advantages of prototyping
      and scripting languages.</PARA>

      <PARA>Dylan isn't without some serious shortcomings. It's not
      widely supported as of the summer of 1998, with only two majors
      implementations, one of which is still incomplete. Several
      features of the language could be more elegant, and there's a
      wickedly intricate set of tradeoffs when implementing shared
      libraries.</PARA>
    </SECT1>

    <SECT1 ID="gduser-about-gwydion">
      <TITLE>About Gwydion Dylan</TITLE>

      <PARA>Gwydion Dylan is an implementation of the Dylan
      programming language for Unix systems. Originally written as a
      research project by the Gwydion group at CMU, it is now
      maintained by a group of volunteers.</PARA>

      <PARA>The current version of Gwydion is development code, and
      intended only for use by Dylan fanatics. The compiler is slow,
      lacks shared library support and still needs lots of bug
      fixes. To make life more exciting, the documentation is
      incomplete, and you'll need to read the source and ask questions
      on the mailing list. If this sounds like fun, you'll enjoy
      Gwydion.</PARA>

      <PARA>Thanks to the skilled programmers at CMU, Gwydion can
      already generate exceptionally efficient code (half the speed of
      C in most cases) and implements about 98% of the Dylan standard
      with many extra libraries.</PARA>
    </SECT1>

    <SECT1 ID="gduser-gwydion-resources">
      <TITLE>Gwydion Dylan Resources</TITLE>

      <PARA></PARA>

    </SECT1>

  </CHAPTER>

  <CHAPTER ID="gduser-installing-gwydion">
    <TITLE>Installing Gwydion Dylan</TITLE>

    <PARA>This chapter gives instructions for installing Gwydion Dylan.</PARA>

    <SECT1 ID="gduser-prerequisites">
      <TITLE>Prerequisite Software Installation</TITLE>

      <PARA>Gwydion Dylan depends on a C compiler being installed,
      plus, of course, all the tools and header files the C compiler
      needs to do his job. Your best bet on most platforms is having
      <ULINK
      URL="http://gcc.gnu.org/">gcc</ULINK>
      installed, plus the <ULINK
      URL="http://www.gnu.org/software/binutils/binutils.html">binutils</ULINK>,
      and whatever standard C library and headers are
      appropriate. Installation of <ULINK
      URL="http://www.gnu.org/software/make/make.html">GNU
      Make</ULINK> is also required.</PARA>

      <PARA>If you want to use shared libraries (which is the default
      on most systems), you need to install the <ULINK
      URL="http://www.gnu.org/software/libtool/libtool.html">libtool</ULINK>
      package as well.</PARA>
    </SECT1>


    <SECT1 ID="gduser-supported-systems">
      <TITLE>Supported Systems</TITLE>

      <PARA>As of the current writing, Gwydion Dylan supports several
      flavors of Unix-like systems, including GNU/Linux (on x86 and PowerPC
      machines), FreeBSD, and Solaris. Other systems are supported but not
      current, including Windows NT and several varieties of Unix. Binary
      packages are available for a wide range of Linux
      distributions. Bringing an ignored port up to date requires one or
      more recompilations. Creating a new port requires several days to a
      few weeks of work, and a familiarity with both Dylan and the target
      system.
      </PARA>
    </SECT1>

    <SECT1 ID="gduser-rpm-installation">
      <TITLE>RPM Installation</TITLE>

      <Para>To install Gwydion Dylan on a Linux system using RPM, type:
      (FIXME: FTP commands are now different.)</para>
    
      <screen>
      <prompt>$</prompt> <userinput>ncftp &ftpdir;</userinput>
      <prompt>ncftp></prompt> <userinput>get gwydion-dylan*.rpm</userinput>
      <prompt>ncftp></prompt> <userinput>quit</userinput>
      <prompt>$</prompt> <userinput>su</userinput>
      <prompt>Password:</prompt> <userinput>secret!</userinput>
      <prompt>%</prompt> <userinput>rpm -Uvh gwydion-dylan*.rpm</userinput>
      <prompt>%</prompt> <userinput>exit</userinput>
      </screen>
    </SECT1>

    <SECT1 ID="gduser-debian-installation">
      <TITLE>Debian Package Installation</TITLE>

      <PARA></PARA>
    </SECT1>

    <SECT1 ID="gduser-freebsd-installation">
      <TITLE>FreeBSD Installation</TITLE>
      
      <PARA>Gwydion Dylan installation on FreeBSD systems can be done using
      the FreeBSD ports system, described in the
      <ULINK URL="http://www.freebsd.org/handbook/">FreeBSD Handbook</ULINK>.
      </PARA>
    </SECT1>

  </CHAPTER>
  
  <CHAPTER ID="gduser-using-d2c">
    <TITLE>Using &d2c;</TITLE>

    <PARA>This chapter describes the Gwydion Dylan-to-C compiler,
    &d2c;.</PARA>

    <sect1 id="gduser-getting-started">
      <title>Getting Started with &d2c;</title>

      <para>This section explains the structure of a simple Dylan program,
      and shows how to use &d2c;</para>

      <SECT2 ID="gduser-program-structure">
	<TITLE>Structure of a Simple Dylan Program</TITLE>
	
	<PARA>A Dylan program currently consists of several files. These
        are the Library Interchange Definition (or <Acronym/LID/) file, the
        inport/exports file, and one or more source files. For the time
        being, it is not possible to compile a standalone source
        file.</para>
      
	<para>The <acronym>LID</acronym> file instructs the compiler how to
        build a Dylan library or application. It includes a list of source
        files, compiler options and other descriptive information. It can
        be identified by the file name extenion
        <literal>lid</literal>.</para>

        <para>A second file lists all the function and variable names
        imported and exported by the program. This generally ends in
        <literal/-exports.dylan/ or <literal/-library.dylan/. Technically,
        this file consists of Dylan source code, but it almost never
        contains any declarations but <literal/define library/ or
        <literal/define module/.</para>

        <para>Other files end in the extension <literal/dylan/ and contain
        the actual Dylan source code.</para>
      </SECT2>

      <SECT2 ID="gduser-make-dylan-app">
	<TITLE>Using <command>make-dylan-app</command></TITLE>

	<para>Because &d2c; requires such a complex set of files for even a
         simple program, it's usually best to take advantage of the program
         <Command/make-dylan-app/ to create a new application. To use this,
         <command/cd/ to an appropriate directory and type
         <command>make-dylan-app <parameter/program-name/</command>. This
         will create a new directory containing a simple program which uses
         a set of libraries useful for a command line utility.</para>
      </sect2>

      <sect2 id="gduser-hello-world">
	<title>A Sample Program</title>

	<para>Create a new program called <literal/hello/ by running
	the command <command/make-dylan-app hello/. This will create a
	new directory named <filename/hello/. Go there by typing
	<literal>cd hello</literal> and take a look at the files.</para>

	<para>Open up the file <filename>hello/hello.dylan</filename>
	and fill in reasonable values for the <literal/author:/ and
	<literal/copyright:/ keywords. You will notice that
	<command>make-dylan-app</command> already filled in a
	statement printing <quote>Hello, World!</quote> for us, as a
	placeholder for the code we want to add to the program.</para>

<ProgramListing>
module: hello
synopsis: Print the string "Hello, World!"
author: J. Random Hacker &lt;jrandom@randomhacks.com&gt;
copyright: Copyright 1998, J. Random Hacker

define function main(name, arguments)
  format-out("Hello world!\n");
  exit-application(0);
end function main;

// Invoke our main() function.
main(application-name(), application-arguments());
</ProgramListing>

	<para>The three other files in this directory are a
	<filename>Makefile</filename> for compiling your program (it
	is not strictly needed, as you could call &d2c; directly), an
	export declaration file named
	<filename>hello-exports.dylan</filename>, which declares the
	libraries and modules that are used by your program, and a LID
	file listing all of your Dylan source files (two in this case)
	plus the name of the resulting executable.</para>

	<para>To compile the program, simply type
	<command>make</command>. Alternatively, call &d2c;, passing it
	the LID file as a parameter, as in <command>d2c
	hello.lid</command>. You can now run your program by typing
	<command>./hello</command>.</para>

	<para>Note that, when using shared libraries, the file
	<filename>hello</filename> is just a script that calls the
	real program <filename>.libs/hello</filename>. The reason for
	that is rather intricate and has to do with the rpath to
	shared libraries which are part of your project. In other
	words, don't worry about it now, and read the
	<command>libtool</command> documentation when you need more
	advanced features.</para>

      </sect2>
    </sect1>

    <SECT1 ID="gduser-working-with-lid">
      <TITLE>Working with LID (Library Interchange Definition) Files</TITLE>
      
      <PARA>As described in the DRM, in the Dylan language the basic
      unit of compilation is the library.  FIXME more to say about this.</PARA>

      <PARA>A LID file is composed of entries of the form
      <LITERAL>keyword: <PARAMETER>value</PARAMETER></LITERAL>,
      similar to mail headers and to the Dylan file header
      format. Currently &d2c; expects the list of source files to
      appear as the "main body" of the LID file, after the header and
      a blank line. In the Harlequin LID format, there is a
      <LITERAL>Files:</LITERAL> entry which is used instead, and which
      we do not yet support. </PARA>

      <PARA>&d2c; recognizes these LID entries:</PARA>

      <VARIABLELIST>
	<VARLISTENTRY>
	  <TERM><LITERAL>Library:
	  <PARAMETER>dylan-library-name</PARAMETER></LITERAL></TERM>
	  <LISTITEM>
	    <PARA>The Dylan name for the library that we are
	    defining. There must be a corresponding <LITERAL>define
	    library</LITERAL> somewhere in the source for this
	    library.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><LITERAL>Unit-prefix:
	  <PARAMETER>c_legal_identifier_fragment</PARAMETER></LITERAL></TERM>
	  <LISTITEM>
	    <PARA>This prefix is used to make the C translation of
	    names in this library unique w.r.t. any other libraries
	    that might be used. This defaults to the library name,
            mangled according to the Dylan-to-C name mangling rules.
	    </PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><LITERAL>Unique-ID-base:
	  <PARAMETER>decimal-integer</PARAMETER></LITERAL></TERM>
	  <LISTITEM>
	    <PARA>Unique class identifiers for classes defined in this
	    library are assigned sequentially starting with the
	    specified integer. This should always be specified, but
	    you won't get a sensible error if it is missing. The base
	    should be sufficiently far from the base for any other
	    library so that class IDs won't overlap. You will get a
	    compile-time error if overlap occurs. A good base for user
	    code would be 30000.</PARA>
	    <para>The Unique ID is used for multimethod dispatch, and it is
            bound to go away in the near future.</para>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><LITERAL>Executable:
	  <PARAMETER>result-file-name</PARAMETER></LITERAL></TERM>
	  <LISTITEM>
	    <PARA>Specifies that we are building a runnable
	    application rather than a library. The executable is
	    generated with the specified name.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><LITERAL>Entry-Point:
	  <PARAMETER>dylan-module</PARAMETER>:<PARAMETER>dylan-variable</PARAMETER></LITERAL></TERM>
	  <LISTITEM>
	    <PARA>When generating an executable, this LID option
	    specifies which Dylan function is called as the main entry
	    point. You can also have no main entry point, in which
	    case the program exits after running all of the top level
	    forms. This entry-point function is called with two
	    arguments, argc (an integer) and argv (a raw
	    pointer). Note that this is incompatible with Mindy, and
	    rather brutal as well. You can get the &mindy; semantics
	    of calling <LITERAL>Extensions:Main</LITERAL> by using the
	    <LITERAL>Extensions</LITERAL> module in your main module
	    and then specifying: <LITERAL>Entry-Point:
	    <PARAMETER>mymodule</PARAMETER>:%main</LITERAL> in the LID
	    file. The <LITERAL>%Main</LITERAL> function parses the
	    arguments and then calls <LITERAL>Main</LITERAL>. </PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><LITERAL>Linker-options:
	  <PARAMETER>various-ld-flags</PARAMETER></LITERAL> </TERM>
	  <LISTITEM>
	    <PARA>This option specifies flags which must be passed to
	    <COMMAND>ld</COMMAND> when linking against this
	    library. This is primarily used when a foreign library is
	    called via one of the undocumented callout mechanisms. For
	    example, <FILENAME>Dylan.lid</FILENAME> specifies
	    <OPTION>-lm</OPTION> so that it can use the math
	    library. This dependency is automatically propagated to
	    users of the library.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><LITERAL>Features:
	  <PARAMETER>features-list</PARAMETER></LITERAL></TERM>
	  <LISTITEM>
	    <PARA>The argument is a space-separated list of features
	    or misfeatures. If the token begins with
	    <LITERAL>~</LITERAL>, then the rest of the token is
	    interpreted as a feature to remove. Otherwise, the token
	    is added as a feature.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>
      </VARIABLELIST>

      <PARA>Here is a sample LID file:</PARA>

      <PROGRAMLISTING>
rcs-header: $Header: /scm/cvs/ref/Attic/gduser.sgml,v 1.12 2002/07/13 17:56:17 gabor Exp $
library: my-program
unit-prefix: myprog
unique-id-base: 30000
executable: mp
entry-point: main:%main

myprog-exports.dylan
myprog.dylan</PROGRAMLISTING>
    </SECT1>

    <SECT1 ID="gduser-invoking-d2c">
      <TITLE>Invoking &d2c;</TITLE>

      <PARA></PARA>
    </SECT1>


    <SECT1 ID="gduser-environment-variables">
      <TITLE>Environment Variables</TITLE>

      <PARA>These environment variables are used by &d2c;:</PARA>

      <VARIABLELIST>
	<VARLISTENTRY>
	  <TERM><ENVAR>DYLANDIR</ENVAR></TERM>
	  <LISTITEM>
	    <PARA>The root of the installed Gwydion tree. In the
	    default configuration, this defaults to
	    <FILENAME>/usr/local</FILENAME> on Unix and
	    <FILENAME>c:\dylan</FILENAME> on win32. This variable in
	    turn establishes the defaults for <ENVAR>DYLANPATH</ENVAR>
	    and the <FILENAME>platforms.descr</FILENAME> file. </PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><ENVAR>DYLANPATH</ENVAR></TERM>
	  <LISTITEM>
	    <PARA>The search path for Dylan libraries. Directories in
	    the <ENVAR>DYLANPATH</ENVAR> are searched after any
	    directories specified by explicit <OPTION>-L</OPTION>
	    options. If not set, this defaults to
	    "<LITERAL>.:$DYLANDIR/lib/dylan</LITERAL>"
	    ("<LITERAL>.;%DYLANDIR%\lib\dylan</LITERAL>" on Win32). If
	    set, the value must include the directory where the
	    <LITERAL>Dylan</LITERAL> library is to be found.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><ENVAR>PATH</ENVAR></TERM>
	  <LISTITEM>
	    <PARA>&d2c; expects to find <Command>make</Command> and
	    the C compiler in <ENVAR>PATH</ENVAR>. On Unix we use the
	    GNU tools <COMMAND>gmake</COMMAND>,
	    <COMMAND>gcc</COMMAND>, and <COMMAND>ld</COMMAND>. Other
	    compilers can work, but at a minimum this requires a new
	    platform description in
	    <FILENAME>$DYLANDIR/etc/platforms.descr</FILENAME>. You
	    must also have some of the GNU-win32 tools to run &d2c; on
	    Windows, though <COMMAND>make</COMMAND> and Visual C++ are
	    normally used for compilation. To build &d2c;, you also
	    need perl and the various scripts in the
	    <FILENAME>tools</FILENAME> directory. </PARA>

	    <PARA>The GNU assembler must be used in conjunction with
	    the generated code from <COMMAND>gcc</COMMAND>. If you
	    somehow end up running the HP/UX <COMMAND>as</COMMAND>
	    with <COMMAND>gcc</COMMAND>, it will produce many errors
	    about STAB entries, etc. </PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><ENVAR>CCFLAGS</ENVAR></TERM>
	  <LISTITEM>
	    <PARA>This variable holds the flags passed to the C
	    compiler. The default is platform-specific, but always
	    includes <LITERAL>-I$DYLANDIR/include</LITERAL>. If you do
	    set this variable, you must also specify the Dylan system
	    include directory. The default optimization flags for gcc
	    are <LITERAL> -g -O4 -finline-functions</LITERAL>. You can
	    roughly halve the size of the executable by omitting the
	    <OPTION>-g</OPTION>, but at the cost of
	    debuggability. Leaving out the other optimize flags will
	    speed compilation at the cost of runtime speed. </PARA>
	  </LISTITEM>
	</VARLISTENTRY>
      </VARIABLELIST>
    </SECT1>

    <!--
Limitations 
Extensions and Libraries 
Mindy compatibility notes 
Debugger 
DIG Commands 
DIG Gotchas 
Environment 
Function Representations 
Naming 
Character Set Translation 
Basic Name Translation 
Derived Name Translation 
Object representations 
Special adjectives 
Optimizations 
Generated Files 
Compile Time Constants
    -->
  </CHAPTER>

  <CHAPTER ID="gduser-using-mindy">
    <TITLE>Using &mindy;</TITLE>

    <PARA></PARA>
  </CHAPTER>

  
  <CHAPTER id="melange">
    <DOCINFO>
      <title>Using the Melange Interface Generator</title>
      <titleabbrev>Melange</titleabbrev>
      <date>04 June 1997</date>
      <authorgroup>
	  <author>&person.rstockton;</author>
      </authorgroup>
    </DOCINFO>

    <TITLE>Using the Melange Interface Generator</TITLE>

    <abstract>
      <para>The Melange interface generator provides a mechanism for
      providing access to native C code. It is modeled upon Apple
      Computer's Creole, and shares Creole's goals of automatically
      providing full support for a foreign interface based upon existing
      interface descriptions. It also, like Creole, provides mechanisms for
      explicitly adapting these interfaces to provide a greater match
      between C and Dylan data models.</para>

      <para>Melange, however, differs from Creole in a number of
      significant ways. This document, therefore, provides a gentle
      introduction to Melange without attempting to build upon any existing
      descriptions of Creole.</para>
    </abstract>

    <SECT1 id="melange-introduction">
      <title>Introduction</title>

      <para>Melange is an automatic interface generator which provides
      transparent access to both functions and data defined or
      generated by existing C libraries. It allows users to import
      "interfaces"<footnote> <para>In fact, a C header file may
      contain arbitrary C code which Melange is unprepared to
      handle. By convention, however, ".h" files con tain only
      "interface declarations"&mdash;type declarations, function
      prototypes, global variable declarations, and "preprocessor
      constants."  Since Melange can meaningfully process all of
      these, it is capable of handling the vast majority of header
      files which will be encountered in practice.</para></footnote>
      from existing C header files, controlled by the contents of a
      "define interface" top-level form which may be included in the
      same file as arbitrary Dylan code. The user may use the
      functions and data specified by this interface as if they were
      native Dylan objects, and may export them to other
      modules.</para>

      <para>Melange provides reasonable interpretations for the
      various sorts of C declarations which may appear in a header
      file, as well as mechanisms for explicitly modifying the default
      interpretations when necessary. For example, users may: </para>

      <itemizedlist>
	<listitem>
	  <para>specify rules for the translation of foreign names</para>
	</listitem>
	<listitem>
	  <para>explicitly specify new names for specific objects or
	  routines</para>
	</listitem>
	<listitem>
	  <para>specify parameter passing conventions or mutability of
	  foreign objects</para>
	</listitem>
	<listitem>
	  <para>specify mappings or equivalences between "foreign"
	  data and native equivalents</para>
	</listitem>
	<listitem>
	  <para>choose to import only a subset of the declarations in the
	  header file</para>
	</listitem>
      </itemizedlist>

      <para>All of these customizations, as well as the name of the C
      header file, are specified by a "define interface" clause. See
      <xref linkend="melange-concrete-example"> for an
      example. </para>

      <para>The basic model for interface importation is based upon
      that used within Apple Computer's "Creole" interface
      generator. There are, however, significant differences in some
      of the details.  (For instance, the "equate", "map", and
      "object-file" directives used in the above example are unique to
      Melange. Likewise, Creole's "type" directive would not be
      accepted by Melange) You should, therefore, not expect Creole
      interface declarations to work within Melange without some
      modification. </para>
    </SECT1>

    <SECT1 id="melange-concrete-example">
      <title>A Concrete Example</title>

      <para>In order to get a feel for using Melange, it is probably
      best to start with a concrete example.  This section contains a
      complete program which will use native C libraries to list the
      contents of some directories. For now, you should simply skim
      this example to get a general overview of Melange's
      capabilities. These will be described in more detail in later
      sections.</para>

      <para>We will first begin with an "interface file" which
      contains a mixture of basic Dylan code and "define interface"
      forms which will be processed by Melange. We will name this file
      "dirent.intr".</para>

      <programlisting>
module: Junk
synopsis: A poor imitation of &quot;ls&quot;

define library junk
  use dylan;
  use streams;
end library junk;

define module junk
  use dylan;
  use extensions;
  use extern;
  use streams;
  use standard-io;
end module junk;

define interface
  // This clause is more complex than it needs to be, but it does
  // demonstrate a lot of Melange's features.
  #include &quot;/usr/include/sys/dirent.h&quot;,
    mindy-include-file: &quot;dirent.inc&quot;,
    equate: {&quot;char /* Any C declaration is legal */ *&quot; =&gt; &lt;c-string&gt;},
    map: {&quot;char *&quot; =&gt; &lt;byte-string&gt;},
    // The two functions require callbacks, which we don&#146;t support.
    exclude: {&quot;scandir&quot;, &quot;alphasort&quot;, &quot;struct _dirdesc&quot;},
    seal-functions: open,
    read-only: #t,
    name-mapper: minimal-name-mapping;
  function &quot;opendir&quot;, map-argument: {#x1 =&gt; &lt;string&gt;};
  function &quot;telldir&quot; =&gt; tell, map-result: &lt;integer&gt;;
  struct &quot;struct dirent&quot;,
    prefix: &quot;dt-&quot;,
    exclude: {&quot;d_namlen&quot;, &quot;d_reclen&quot;};
end interface;

define method main (program, #rest args)
  for (arg in args)
    let dir = opendir(arg);
    for (entry = readdir(dir) then readdir(dir),
         until entry = $null-pointer)
      write-line(entry.dt-d-name, *standard-output*);
    end for;
    closedir(dir);
  end for;
end method main;</programlisting>

      <para>We will then process this file through Melange to produce
      a file of pure Dylan code. On a system with &d2c; support, there
      will be an executable named melange, which you can invoke like
      this:

      <screen>
      <userinput>melange dirent.intr dirent.dylan</userinput>
      </screen>

      On a mindy-only system, where melange is contained in a file
      <FILENAME>melange.dbc</FILENAME>, we would use the following
      command line:</para>

      <screen>
      <userinput>mindy -f melange.dbc dirent.intr dirent.dylan</userinput>
      </screen>

      <para>This command will process "melange.intr" and write a file
      named "dirent.dylan". In this case, it will also silently write
      a file named "dirent.inc", whose use will be explained
      later.</para>

      <para>You can compile "dirent.dylan" normally, via mindycomp,
      but in order to execute it, you must make sure that the Mindy
      interpreter will be able to load the appropriate routines from
      the library containing the "dirent" routines. Ideally, you would
      simply let Mindy load the appropriate code dynamically. However,
      this is presently only available for a few machines.  Therefore,
      we will follow a messier approach and build a new version of the
      interpreter which is aware of the desired functions.</para>

      <para>Move to the build directory for the Mindy interpreter, and
      edit the Makefile so the "EXTERN-INCLUDES" line mentions
      "your_dir_path/dirent.inc" and then run "make mindy". In this
      case, this is all that is required to build a new interpreter
      which is aware of the dirent routines.</para>

      <para>You can now put it all together, invoking the new interpreter on
      the compiled program, with:</para>

      <screen>
        <userinput>mindy -f dirent.dbc .</userinput>
      </screen>

      <para>This should print a list of all files in the current
      directory.</para>

      <para>Because of the difficulty of relinking the interpreter for
      each new library, it is expected that administrators will build
      a set of "standard" library interfaces which are prelinked into
      the interpreter and exported as general Dylan library
      interfaces. In the future, as Melange (and the Gwydion
      environment) are extended to support better linking and loading
      capabilities, it should become easier to incorporate C libraries
      on an "as-needed" basis.</para>
    </SECT1>

    <SECT1 id="melange-basic-use">
      <title>Basic Use</title>

      <para>Although the "define interface" form provides a fairly
      rich sublanguage for specifying interfaces, it is often
      sufficient to use just the "minimal" form. For example, if
      "gc.h" contained the following code:</para>

      <programlisting>
typedef char bool;
typedef struct obj obj_t;
typedef char *str;
extern obj_t alloc(obj_t class, int bytes);
extern void scavenge(obj_t *addr);
extern obj_t transport(obj_t obj, int bytes);
extern void shrink(obj_t obj, int bytes);
extern void collect_garbage(void);
extern bool TimeToGC;
#define ForwardingMarker ((obj_t)(0xDEADBEEF))</programlisting>

      <para>then you could import it by creating a file named
      "class.intr" which includes arbitrary Dylan code and the
      following:</para>

      <programlisting>
define interface
   #include "gc.h";
end interface;</programlisting>

      <para>You would then run "melange class.intr" [Or possibly "
      mindy -f melange.dbc class.intr ", depending upon the
      installation on your particular machine.] , which would produce
      a file of Dylan code which contains approriate definitions for
      the classes &lt;bool&gt;", "&lt;obj&gt;", "&lt;obj_t&gt;", and
      "&lt;str&gt;"; the variable "TimeToGC"; and the functions
      "alloc", "scavenge", "transport", "shrink", and
      "collect_garbage". (The constant "ForwardingMarker" will be
      excluded because it is not a simple literal.)</para>

      <programlisting>
if (TimeToGC() ~= 0)
   collect_garbage();
end if;</programlisting>

      <para>This code fragment points out some of the hazards of
      "simple" imports. Melange has no way of knowing that "bool"
      should correspond to Mindy's &lt;boolean&gt; class, so you are
      stuck with a simple integer. Likewise, the system wouldn't be
      able to guess that "char *" shoudl correspond to the Mindy class
      "&lt;c-string&gt;". We will explain in later sections how "map:"
      or "equate:" options may be used to provide this information to
      Melange.</para>

      <SECT2 id="melange-loading-and-finding">
	<title>Loading and Finding Objects</title>

	<para>As mentioned above, the include directive in the
        previous example will only work for files which have been
        previously linked into Mindy. There are extra facilities
        available to handle other situations.</para>

	<para>If your machine is one for which we support dynamic
        loading [Currently support is primarily for HPUX machines, but
        some work has been done on Macintoshes and ELF systems.
        Contact us for more details.] , and you wish to load some
        declared objects from a shared library, you can add one or
        more "object-file:" options to the "#include" clause, as in
        the following:</para>

	<programlisting>
define interface
   #include "gc.h",
      object-file: "/usr/lib/mindy/gc.sl";
end interface;</programlisting>

	<para>This would cause the code from "gc.sl" to be loaded into
        Mindy at run-time and make its functions and objects available
        just as they were in the previous example.  If you are running
        on a non-HPUX machine, you will have to statically link Mindy
        with the appropriate library and a list of mappings from names
        to addresses. This can be accomplished most easily by
        following these steps: </para>

	<orderedlist>
	  <listitem>
	    <para>Add a "mindy-include-file:" option to your interface
            definition. This specifies the name of an "interface
            description file" which will be written by Melange, and
            which can later be linked into Mindy along with the
            appropriate library.</para>
	  </listitem>
	  <listitem>
	    <para>Run Melange on the source file in the normal
            manner. You may wish to move the newly created interface
            description file into your Mindy build directory.</para>
	  </listitem>
	  <listitem>
	    <para>Change the Makefile in the Mindy build directory, by
            adding the imported library to LIBS and the interface
            description file to EXTERN-INCLUDES.</para>
	  </listitem>
	  <listitem>
	    <para>Run "make" to rebuild Mindy with the new library
	    information.</para>
	  </listitem>
	  <listitem>
	    <para>Compile and run the generated Dylan code as normal.</para>
	  </listitem>
	</orderedlist>
      
	<para>A typical interface definition for this approach might
        be:</para>

	<programlisting>
define interface
   #include "gc.h",
      mindy-include-file: "/usr/local/mindy-build/gc.inc"
end interface;</programlisting>

      </SECT2>
    </SECT1>

    <SECT1 id="melange-importing-headers">
      <title>Importing Header Files</title>

      <para>You import C definitions into Dylan by specifying one or more
      header files in an "#include" clause. This may take one of two
      different forms:</para>

      <programlisting>
define interface
   #include "file1.h";
end interface;</programlisting>

      <para>or</para> 

      <programlisting>
define interaface
   #include {"file1.h", "file2.h"};
end interface;</programlisting>

      <para>Melange will parse all of the named files in the specified
      order, and produce Dylan equivalents for (i.e. "import") some
      fraction of declarations in these files. By default, Melange
      will import all of the declarations from the named files, and
      any declarations in recursively included files (i.e. those
      specified via "#include" directives in the ".h" file) which are
      referenced by imported definitions. It will not, however, import
      every declaration in recursively included files. This insures
      that you will see a complete, usable, set of declarations
      without having to closely control the importation process. If
      you wish to exert more control over the set of objects to be
      imported, you may do so via the "import", "exclude", and
      "exclude-file" options.</para>

      <para>If you only need a small set of definitions from a set of
      imported files, you can explicitly specify the complete list of
      declarations to be imported by using the "import:" option. You
      could, for example, say:</para>

      <programlisting>
define interface
   #include "gc.h",
      import: {"scavenge", "transport" => move};
end interface;</programlisting>

      <para>This would result in Dylan definitions for "scavenge",
      "move", "&lt;obj_t&gt;", and "&lt;obj&gt;".  The latter types
      would be dragged in because they are referenced by the two
      imported functions.  Again, if you equated "obj_t" to
      &lt;object&gt; then neither of the types would be imported. The
      second import in the above example performs a renaming at the
      same time as it specifies the object to be imported. Other forms
      specify global behaviors. "Import: all" willcause Melange to
      import every "top level" definition which is not explicitly
      excluded. "Import: all-recursive" causes it to import
      definitions from recursively included files as well. "Import:
      none" restricts importation to those declarations which are
      explicitly imported or are used by an imported declaration.  You
      may also use the "import:" option to specify importation
      behavior on a per-file basis. The options</para>

      <programlisting>
import: "file.h" => {"import1", ...}
import: "file.h" => all
import: "file.h" => none</programlisting>

      <para>work like the options described above, except that they
      only apply to the symbols in a single imported file.  The
      "exclude:" and "exclude-file:" options may be used to keep one
      or more unwanted definitions from being imported. For example,
      you could use:</para>

      <programlisting>
define interface
   #include "gc.h",
      exclude: {"scavenge", "transport"},
      exclude-file: "gc1.h";
end interface;</programlisting>

      <para>This would prevent the two named functions and everything
      in the named file from being imported, while still including all
      of the other definitions from "gc.h". Note that these options
      should be used with care, as they can easily result in
      "incomplete" interfaces in which some declarations refer to
      types which are not defined. This could result in errors in the
      generated Dylan code. (The "import: file => none" option
      described above is a safer way of achieving an effect similar to
      "exclude-file:"</para>

      <para>You may also prevent some type declarations from being
      imported by using the "equate:" option (described in a later
      section). If, for example, you equated "obj_t" to
      &lt;object&gt;, then Melange would ignore the definition for
      "obj_t" and simply assume that the existing definition for
      &lt;object&gt; was sufficient.</para>

      <para>You may have any number of "import:", "exclude:", and
      "exclude-file:" options, and may name the same declarations in
      multiple clauses. "Exclude:" options take priority over
      "import:"s. If no "import:" options are specified, the system
      will import all non-excluded symbols, just as if you had said
      "import: all".</para>
    </SECT1>

    <SECT1 id="melange-specifying-object-names">
      <title>Specifying Object Names</title>

      <para>Because naming conventions differ between C and Dylan,
      Melange attempts to translate the names specified in C
      declarations into a form more appropriate to Dylan. This
      involves</para>

      <itemizedlist>
	<listitem>
	  <para>Adding angle brackets around type names.</para>
	</listitem>
	<listitem>
	  <para>Adding dollar signs at the beginning of constant
	  names.</para>
	</listitem>
	<listitem>
	  <para>Translating (non-initial) underlines into hyphens.</para>
	</listitem>
	<listitem>
	  <para>Adding "struct-name$" prefixes to slot accessors.</para>
	</listitem>
      </itemizedlist>

      <para>In many cases, this default behavior will be precisely
      what you want. However, Melange provides mechanisms for
      specifying different translations for some or all of the
      declarations.</para>

      <SECT2 ID="melange-mapping-functions">
	<title>Mapping functions</title>

	<para>The translations described above are provided by calls
        to a built-in "name mapping function" named
        "minimal-name-mapping-with-structure-prefix". You may specify
        other mapping functions via a "name-mapper:" option. Our
        example interface might then look like this:</para>

	<programlisting>
define interface
   #include "gc.h",
      object-file: "/usr/lib/mindy/gc.o",
      name-mapper: c-to-dylan;
end interface;</programlisting>

	<table id="melange-name-mapping">
	  <title>Standard Name Mapping Functions</title>
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry>minimal-name-mapping-with-structure-prefix</entry>
		<entry>Provides the translations described above.</entry>
	      </row>
	      <row>
		<entry>minimal-name-mapping</entry>
		<entry>Same as above, but excludes the "struct-name$"
	        prefixes.</entry>
	      </row>
	      <row>
		<entry>c-to-dylan</entry>
		<entry><para>Like minimal-name-mapping, but:</para><itemizedlist>
		    <listitem>
		      <para>Adds hyphens to reinforce "CaseBased" word
                      separation.</para>
		    </listitem>
		    <listitem>
		      <para>Adds "get-" prefixes to slot accessors.</para>
		    </listitem>
		  </itemizedlist></entry>
	      </row>
	      <row>
		<entry>identity-name-mapping</entry>
		<entry>Does no translation.</entry>
	      </row>
	    </tbody>
          </tgroup>
	</table>
	
	<para><xref linkend="melange-name-mapping"> describes the four
        standard mapping functions that are provided by Melange.
        Users may link new mapping functions into Melange. In the
        Mindy implementation, this is done as follows:</para>

	<procedure>
	  <step>
	    <para>Create a new module which imports module "name-mappers"
            from library "c-parse".</para>
	  </step>
	  <step>
	    <para>Define methods on the "map-name" generic function which
            accepts the following parameters:</para>

	    <variablelist>
	      <varlistentry>
		<term>mapper</term>
		<listitem>
		  <para>a &lt;symbol&gt; which is typically specialized by a
                  singleton to select a specific name mapper method.</para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term>category</term>
		<listitem>
		  <para>a &lt;symbol&gt; which will always be one of:
		  #"type", #"constant", #"variable", or
		  #"function".</para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term>prefix</term>
		<listitem>
		  <para>a &lt;string&gt; which is typically prepended to the
		  result string.</para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term>name</term>
		<listitem>
		  <para>a &lt;string&gt; which supplies the original C
		  name.</para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term>sequence-of-classes</term>
		<listitem>
		  <para>a sequence of simple names for the classes
                  which logically "contain" the given object. For
                  example, if we were processing the declaration
                  "struct str {int size; char *chars", one of the
                  calls to the mapping function would have with
                  namebound to "size" and classes bound to
                  #["str"].</para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <para>and returns a &lt;string&gt; which will be used as the
            Dylan name for the declaration.</para>
	  </step>

	  <step>
	    <para>Compile this module and "link" it into Melange by
            concatenating it to the end of the melange.dbc.</para>
	  </step>
	</procedure>

	<para>Mapping functions may call "hyphenate-case-breaks" which
        performs the same "CaseBased separation" as is done by
        "c-to-dylan". The trivial "identity-name-mapping" described
        above might be implemented by:</para>

	<programlisting>
define method map-name
   (mapper == #"identity-name-mapping", category, prefix, name, classes)
=> (result :: &lt;string&gt;)
   name;
end method map-name;</programlisting>

	<para>You may specify different name mappers to be applied to
        the slots of "container types". This capability is described
        in a later section.</para>
      </SECT2>

      <SECT2 ID="melange-prefixes">
	<title>Prefixes</title>

	<para>As noted above, the name mapping function is passed a
        "prefix" argument. By default, it is an empty string, but
        users may specify a different value by adding a "prefix:"
        option to the interface definition. For example, we might
        expand the previous example to:</para>

	<programlisting>
define interface
   #include "gc.h",
      object-file: "/usr/lib/mindy/gc.o",
      name-mapper: c-to-dylan,
      prefix: "gc-";
end interface;</programlisting>
	
	<para>This would cause Melange to tack "gc-" onto the
        beginning of every translated symbol.  Because the system
        knows about the "standard" Dylan naming conventions, it can do
        this intelligently. You would, therefore, get names like
        "&lt;gc-bool&gt;", "gc-time-to-gc", and "gc-scavenge".</para>

	<para>Note that the interpretation of the "prefix" is entirely
        up to the name mapping routine.  Identity-name-mapping, for
        example, completely ignores the prefix. All of the other
        standard mapping functions prepend it to the name before
        adding brackets or dollar signs, but after performing all
        other transformations.</para>

	<para>Facilities for adding "localized" prefixes to slot
        accessors, enumeration literals, etc.  will be described in
        later sections.</para>
      </SECT2>

      <SECT2 ID="melange-explicit-renaming">
	<title>Explicit Renaming</title>
      
	<para>Although the automatic name mapping described above is
        sufficient for most objects named within a header file, there
        are cases in which you might wish to explicitly control the
        name of one or more specific objects. You can do this through
        a "rename:" option. This options specifies a list of
        translations between raw C names and Dylan identifiers. For
        example, we might have:</para>

	<programlisting>
define interface
   #include "gc.h",
      object-file: "/usr/lib/mindy/gc.o",
      name-mapper: c-to-dylan,
      prefix: "gc-"
      rename: {"struct obj" => &lt;C-Object&gt;, "collect_garbage" => GC};
end interface;</programlisting>

	<para>Note that the "target" of the renaming is an ordinary
        Dylan variable and is therefore case-insensitive. However, the
        source is an "alien name", which is (like all C code) case
        sensitive. Alien names should refer to an object, function, or
        type in exactly the same way you would refer to them in C. We
        therefore say "struct obj" instead of simply "obj", and might
        also say "enum foo" or "union bar". Alien names are actually
        parsed according to the standard lexical conventions of C, so
        you may use arbitrary spacing and even include comments if you
        really wish.</para>

	<para>Note that "rename:" options supply names for new objects
        (and types) that are being imported into Dylan. You cannot,
        therefore, simply rename "bool" to "&lt;Boolean&gt;" to make
        it equivalent to the existing type -- this would simply result
        in a name conflict. For these purposes, you would instead use
        the "equate" and "map" operations, which will be described
        later. (In fact, if the C declaration had defined a type name
        "boolean", you might have to explicitly rename it to something
        else in order to avoid name conflicts with the existing type.
        Of course, in the above example, the "gc-" prefix would be
        sufficient to make the name unique.)</para>
      </SECT2>

      <SECT2 ID="melange-anonymous-types">
	<title>Anonymous Types</title>

	<para>The alien names described above can also be used to
        refer to C's so-called "anonymous types". You can therefore
        refer to "char *", "int [23]", or even "int (*) (char *foo)"
        (i.e. a pointer to function which takes a string and returns
        an integer) [At present, function types are not fully
        supported. You should not depend upon them to work as
        expected.]  . The ability to refer to anonymous types is
        useful because it allows you to use the "rename" option to
        provide explicit names for such types. Normally Melange would
        simply generate a an arbitrary "anonymous" identifier for the
        type. Without knowing the name of this type, you could not
        define new operations upon it. However, by saying, for
        example, "rename: {"char * => &lt;char-ptr&gt;"}", you can
        provide a convenient handle to use in defining new
        operations.</para>
      </SECT2>
    </SECT1>

    <SECT1 id="melage-type-definitions">
      <title>Type Definitions</title>

      <para>When Melange encounters a "type definition" [The
      definition may be implicit, as in "char ** int" or "struct foo
      *bar". Simply by being present these code fragments supply
      implicit definitions for "char *", "char **" and "struct foo".]
      within a header file, it will typically create a new Dylan class
      which corresponds to that C type. Usually, this will be a
      subclass of &lt;statically-typed-pointer&gt;, which encapsulates
      the raw C pointer value (i.e an object address).  Each
      statically typed pointer class will have exactly the same
      structure (i.e. a single address), but the class itself can be
      used to determine what operations are supported on the
      data. This could include slot accessors for "struct"s and
      "union"s, dereference operations for "pointer" types, or general
      information about the objectUs size, etc.</para>

      <para> There are times when you will find that some of the types
      defined in a header file are not really "new". It might be that
      they are completely identical to some type defined in another
      interface definition, or they might be "isomorphic" to some
      existing type which has more complete support. Melange provides
      support for both of these cases. The first case is handled by
      "equating" the two types, while the second is handled by
      "mapping" (i.e.  transforming) one type into the other.</para>

      <para>For example, many header files contain definitions use the
      types "char *" and "boolean".  The declarations of these types
      don't provide any semantic interpretations -- "char *" is simply
      the address of a character, and boolean is nothing but a
      one-byte integer. However, by equating "char *" to the
      predefined &lt;c-string&gt; type, we can tell Melange that it is
      actually a &lt;string&gt; and should inherit all of the
      operations defined upon &lt;string&gt;s. Likewise, we can map
      the integral "boolean" values into "#t" and "#f" to get a
      &lt;boolean&gt;. These integral values will be automatically
      translated into &lt;boolean&gt;s when they are returned by a C
      function, and &lt;boolean&gt;s will be translated back into
      integers when passed as arguments to C functions.</para>

      <SECT2 ID="melange-implicit-class-definitions">
	<title>Implicit class definitions</title>

	<para>Unless otherwise specified, new classes will be created
        for each type defined in a C header file. When the header file
        provides meaningful names for these types, then Melange will
        pass those names to the mapping functions to generate names
        for the Dylan classes. Otherwise, an anonymous name will be
        generated, limiting your ability to refer to the new type. For
        example, "struct foo" would typically generate the class
        "&lt;foo&gt;", while "struct foo ***" might generate the class
        "&lt;anonymous-107&gt;". In either case, you can explicitly
        specify the name for the new class by using the "rename:"
        option described above.</para>

	<para>Different sorts of C declarations will yield different
        sorts of Dylan classes as well as different sets of operations
        defined upon them. Therefore, we will consider each variety
        separately:</para>

	<variablelist>
	  <varlistentry>
	    <term>Primitive types</term>
	    <listitem>
	      <para>The types "int", "char", "long", "short" and their
              unsigned counterparts are simply translated into
              &lt;integer&gt;, while "float" and "double" are
              translated into &lt;float&gt;.  However, Melange knows
              the sizes of each of these types so that pointers and
              native C "vectors" of them (described below) will work
              properly. No new types are created for these
              types.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Pointer types</term>
	    <listitem>
	      <para>Declarations like "int *" or "struct foo ***"
              generate new subclasses of
              "&lt;statically-typed-pointer&gt;". Note that "struct
              foo *" is actually treated as a synonym for "struct
              foo", and does not get a distinct class, although any
              extra levels of indirection (i.e.  "struct foo **") will
              generate new pointer classes. Three operations are
              supported upon pointer classes:</para>

	      <programlisting>
pointer-value (pointer, #key index) =&gt; (value)</programlisting>

	      <para>This function "dereferences" the pointer and
              returns the value. If index is supplied, then "pointer"
              is treated as a vector of values and the appropriate
              element is returned.</para>

	      <programlisting>
content-size (cls) =&gt; integer</programlisting>

	      <para>Returns the size of the value referenced by
              instances of "cls". If the size is not known, this is
              0.</para>

	      <para>Note that these types are not automatically
              treated as vectors. You may, however, make them so by
              using a "superclasses:" option to make them
              &lt;c-vector&gt;s.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Vector types</term>
	    <listitem>
	      <para>Declarations like "char [256]" are treated almost
              identically to pointer types, but they are automatically
              defined as subclasses of &lt;c-vector&gt;, so that all
              vector operations will be defined on them. However,
              because many systems depend upon the lack of bounds
              checking in C, vector types have a default size of
              "#f". You may explicitly define "size" functions to
              provide a more accurate size.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Structure types</term>
	    <listitem>
	      <para>Declarations like "struct bar {int a; char *b;}"
              also generate new subclasses of
              "&lt;statically-typed-pointer&gt;". Melange will define
              all of the operations defined for pointer values
              (described above), as well as accessors for each of the
              structure slots.  Structure objects are always accessed
              through "pointers" to them. Therefore, unless a non-zero
              index is specified, "pointer-value" will simply return
              the object passed to it. (The operation is still defined
              because non-zero indices can be used for vector
              access.)</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Union types</term>
	    <listitem>
	      <para>Declarations like "union bar {int a, char *b;}"
              are treated the same as struct declarations, except that
              the slot accessors all refer to the same areas in
              memory.  Enumeration types -- Declarations like "enum
              foo {one, two, three};" are simply aliased to
              &lt;integer&gt;. However, constants are defined for each
              of the enumeration literals.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Typedefs</term>
	    <listitem>
	      <para>Declarations like "typedef struct foo bar" simply define
              new names for existing types.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </SECT2>

      <SECT2 id="melange-class-inheritance">
	<title>Specifying class inheritance</title>
	
	<para>When Melange creates new
        "&lt;statically-typed-pointer&gt;" classes, it typically
        creates them as simple subclasses of
        "&lt;statically-typed-pointer&gt;", with no other
        superclasses. However, you might sometimes need more control
        over the class hierarchy. For example, you might wish to
        specify that a C type should be considered a subtype of the
        abstract class "&lt;sequence&gt;". You could accomplish this
        via the following declarations:</para>

	<programlisting>
define interface
   #include "sequence.h";
   struct "struct cons_cell" =&gt; &lt;c-list&gt;,
      superclasses: {&lt;sequence&gt;};
   function "c_list_size" =&gt; size;
end interface;

define method forward-iteration-protocol (seq :: &lt;c-list&gt;)
....</programlisting>

	<para>Note that the type "&lt;c-list&gt;" will still be a
        subclass of "&lt;statically-typed-pointer&gt;"&mdash;we have
        simply added "&lt;sequence&gt;" to the list of
        superclasses. If "&lt;statically-typed-pointer&gt;" is not
        explicitly included in the "superclasses:" option, then it
        will be added at the end of the superclass list.</para>

	<para>As demonstrated in the above example, you are still
        responsible for specifying whatever functions are required to
        satisfy the contract for the declared
        superclasses. "&lt;C-list&gt;" will be declared as a sequence,
        but you must specify a forward iteration protocol before any
        of the standard sequence operations will work properly.</para>

	<para>The "superclasses:" option may currently be used within
        "struct", "union", and "pointer" clauses.</para>
      </SECT2>
    </SECT1>

    <SECT1 id="melage-translating-representations">
      <title>Translating Object Representations</title>

      <para>Whenever a native C object is returned from a function or
      a Dylan object is passed into a C function, it is necessary to
      translate between the object representations used by the two
      languages. From MelangeUs standpoint, native C objects consist
      of an arbitrary bit pattern which can be translated to or from a
      small number of "low level" Dylan types -- namely
      &lt;integer&gt;, &lt;float&gt;, or any subclass of
      &lt;statically-typed-pointer&gt;. This translation is handled
      automatically, although the user may explicitly specify which of
      the possible Dylan types should be chosen for any given C object
      type. In some cases, a further translation may take place,
      converting the "low level" Dylan value to or from some arbitrary
      "high level" Dylan type. (For example, an &lt;integer&gt; might
      be translated into a &lt;boolean&gt; or a &lt;character&gt;, and
      a &lt;c-string&gt; might be translated into a
      &lt;byte-string&gt;.) These "high level" translations are
      automatically invoked at the appropriate times, but both the
      "target" types and the methods for performing the translation
      must be specified by the user.</para>

      <SECT2 ID="melange-low-level-transformations">
	<title>Specifying low level transformations</title>

	<para>The target Dylan type for "low level" translations is
        typically chosen automatically by Melange. Integer and
        enumeration types are translated into &lt;integer&gt;;
        floating point types are translated to &lt;float&gt;; and all
        other types are translated into newly created subclasses of
        &lt;statically-typed-pointer&gt;. However, you may explicitly
        declare the target Dylan type for any C type by means of an
        "equate:" option:</para>

	<programlisting>
define interface
   #include "gc.h",
      equate: {"char *" =&gt; &lt;c-string&gt;};
end interface;</programlisting>

	<para>This declaration makes the very strong statement that
        any values declared in C as "char *" are identical in form to
        the predefined type "&lt;c-string&gt;" (which is described in
        Appendix I). The system will therefore not define a distinct
        type for "char *" and will ignore any structural information
        provided in the header file. You migh also use an "equate:"
        option to equate a type mentioned in one interface definition
        with an identically named type which was defined in an earlier
        interface definition.</para>

	<para>You should use caution when equating two types. Since
        Melange has no way of knowing when two types are equivalent,
        it must trust your declarations. No type checking can or will
        be done, so if you incorrectly equate two types, the results
        will be unpredictable. In some cases, you may wish to go with
        the less efficient but slightly safer technique of letting
        Melange create a new type and then "mapping" that new type
        into the desired type. (This is described in detail
        below.)</para>

	<para>Note also that two types with identical purposes will
        not necessarily have identical representations. For example,
        C's boolean types are simple integers and are not equivalent
        to Dylan's &lt;boolean&gt;. Again, explicit "mapping" may be
        used to transform between these two representations.</para>

	<para>In the current implementation, an "equate:" option only
        applies within a single interface definition. Other interface
        definitions will not automatically inherit the effects of the
        declaration. In future versions, we may add the ability to
        "use" other interface definitions (just as you would "use"
        another module withing a module definition) and thus pick up
        the effects of the "equate: (and "map:") options within those
        interfaces.</para>
      </SECT2>

      <SECT2 ID="melange-high-level-transformations">
	<title>Specifying high level transformations</title>

	<para>Sometimes you may wish to use instances of some C type
        as if they were instances of some existing Dylan class, even
        though they have different representations. In this case, you
        can specify a secondary translation phase which
        semi-automatically translates between a "low level" and a
        "high level" Dylan representation. In order to do this, you
        must provide a "map:" option:</para>

	<programlisting>
define interface
   #include "gc.h",
      equate: {"char *" =&gt; &lt;c-string&gt;},
      map: {"bool" =&gt; &lt;boolean&gt;};
end interface;</programlisting>

	<para>This clause will cause any functions defined within the
        interface to call transformation functions wherever the
        original C functions accept or return values of type
        "bool". Two different functions may be called:</para>

	<programlisting>
import-value (high-level-class :: &lt;class&gt;, low-level-value :: &lt;object&gt;)</programlisting>

	<para>This function is called to transform result values
        returned by C functions into a "high level" Dylan class. It
        should always return an instance of "high-level-class".</para>

	<programlisting>
export-value (lowlevel-class :: &lt;class&gt;, high-level-value :: &lt;object&gt;)</programlisting>

	<para>This function is called to transform "high level"
        argument values passed to C functions into the "low level"
        representations which will be meaningful to native C code. It
        should always return an instance of "low-level-class".</para>

	<para>Default methods, which simply call "as", are provided
        for each of these functions.  This will be sufficient to
        transform C's integral "char"s into &lt;character&gt;s,
        &lt;c-string&gt;s into other &lt;string&gt;s, or one "pointer"
        type into another. There is also a predefined method which
        will transform &lt;integer&gt;s into
        &lt;boolean&gt;s. However, if you wish to perform arbitrary
        transformations upon the values, you may need to define
        additional methods for either or both of these functions. For
        example, the default methods for transforming to and from
        &lt;boolean&gt; are:</para>

	<programlisting>
define method export-value (cls == &lt;integer&gt;, value :: &lt;boolean&gt;)
 =&gt; (result :: &lt;integer&gt;);
   if (value) 1 else 0 end if;
end method export-value;

define method import-value (cls == &lt;boolean&gt;, value :: &lt;integer&gt;)
 =&gt; (result :: &lt;boolean&gt;);
   value ~= 0;
end method import-value;</programlisting>

	<para>It is important to note that, unlike "equate:" options,
        "map:" options don't prevent Melange from creating new
        types. You may, in fact, both equate and map the same
        type. This will cause low level values to be created as
        instances of the "equated" type and then transformed into
        instances of the "target" type of the mapping. For example,
        you might take advantage of the defined transformations
        between string types by declaring:</para>

	<programlisting>
define interface
   #include "/usr/include/sys/dirent.h",
      equate: {"char *" =&gt; &lt;c-string&gt;},
       map: {"char *" =&gt; &lt;byte-string&gt;};
end interface;</programlisting>

	<para>This causes the system to automatically translate "char
        *" pointers into &lt;c-string&gt;s (i.e. a particular variety
        of statically typed pointer) and then to call "import-value"
        ot translate the &lt;c-string&gt; into a
        &lt;byte-string&gt;. If we did not provide the "equate:"
        option, then we would have to explicitly provide a function to
        transform "pointers to characters" into
        &lt;byte-string&gt;s. The "equate:" option lets us take
        advantage of all of the predefined functions for
        &lt;string&gt;s, which includes transformation into other
        string types.</para>
      </SECT2>
    </SECT1>

    <SECT1 id="melange-file-options">
      <title>Other File Options</title>

      <para>There are a few other options that may be specified within
      an "#include" clause, but which do not fit into any of the above
      categories. These options are "define:", "undefine:",
      "seal-functions:" and "read-only:".</para>

      <para>The "define:" and "undefine:" options control the C
      preprocessor definitioins which will be implicitly defined
      during parsing of the header files. If you specify neither of
      these options, Melange will use a default set of definitions
      which correspond to those used by a typical C compiler for the
      machine you are running on. [At present, the only set of
      definitions provided will be those appropriate for the HPUX
      OS. However, it is straightforward to add dif ferent sets of
      definitions to Melange.]  The define options takes a string
      containing a single C token and an optional string or integer
      literal, which will be used as the expansion. (If no literal is
      specified, the token will be expanded to "1".)  The "undefine:"
      removes one or more of the default definitions. You might, for
      example, use:</para>

      <programlisting>
define interface
   #include "gc.h",
      define: {"PMAX", "BSD_VERSION" => "4.3"},
      undefine: {"HPUX"};
end interface;</programlisting>

      <para>The "seal-functions:" option controls whether the various
      imported functions and slot accessors will be sealed or open. By
      default, functions are sealed, but you may explicitly specify
      this by using "seal-functions: sealed" or reverse it by using
      "seal-functions: open". Melange does not support the Creole's
      "inline" sealing option.</para>

      <para>The "read-only:" option specifies whether setter functions
      should be defined for slot and object accessors. They will be
      defined by default, but if you specify "read-only: #t", no
      setters will be defined.</para>

      <para>The effects of the "seal-functions:" and "read-only:"
      options can be modified for particular container types. We will
      explain how to do this in a later sections.</para>
    </SECT1>

    <SECT1 id="melange-function-classes">
      <title>Function Clauses</title>

      <para>Imported functions can be easily invoked, in almost every
      case, without any additional declarations. However, by exerting
      explicit control over argument handling, the interfaces to some
      functions may be made cleaner. This control is exerted via
      function clauses. The primary purpose of these clauses is to
      specify additional type information for specific parameters or
      to specify alternative argument passing conventions. For
      example, if we had two alternate "read-integers" functions with
      the following declarations:</para>

      <programlisting>
int ReadInts1(int **VectorPtr);  /* result is a count of integers */
int *ReadInts2(int *Count);      /* result is a vector of  integers */</programlisting>

      <para>we might use the following interface definition:</para>

      <programlisting>
define interface
   #include "readints.h",
      rename: {"int *" =&gt; int-vector};
   function "ReadInts1"
      output-argument: 1;
   function "ReadInts2" =&gt; Read-Integers-Vector,
   output-argument: Count;
end interface;</programlisting>

      <para>This would produce two functions, both of which take 0
      arguments but return two values. The first would return an
      &lt;integer&gt; following by an "&lt;int-vector&gt;", while the
      second would return the &lt;int-vector&gt; first and the
      &lt;integer&gt; second.</para>

      <programlisting>
let (count :: &lt;integer&gt;, values :: &lt;int-vector&gt;)
   = Read-Ints1();
let (values :: &lt;int-vector&gt;, count :: &lt;integer&gt;) 
   = Read-Integers-Vector();</programlisting>

      <para>The function clause consists of a function name (which is
      a string), an optional renaming (as illustrated above), and an
      optional sequence of "options". The options include the
      following:</para>

      <variablelist>
	<varlistentry>
	  <term>seal:</term>
	  <listitem>
	    <para>specifies whether the resulting method should be
            sealed. Possible values are sealed or open, and the
            default is taken from the value specified in the initial
            file clause. (The "default default" is sealed.)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>equate-result:</term>
	  <listitem>
	    <para>overrides the default interpretation of the result
            type. The named type is assumed to be fully
            defined.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>map-result:</term>
	  <listitem>
	    <para>specifies that "import-value" should be called to map the
            result value to the named type.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>ignore-result:</term>
	  <listitem>
	    <para>specifies that the functions result value should be
            ignored, just as if the function had been declared
            "void". Although you may specify any boolean literal, the
            only meaningful value is #t.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>equate-argument:</term>
	  <listitem>
	    <para>overrides the default interpretation of some
            argument's type. The argument may be specified by name or
            by position.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>map-argument:</term>
	  <listitem>
	    <para>specifies that "export-value" should be called to
            map the given argument into the named type. Again, the
            argument may be specified by position or by name.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>input-argument:</term>
	  <listitem>
	    <para>indicates that the specified argument should be
            passed by value. This is the default.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>output-argument:</term>
	  <listitem>
	    <para>indicates that the specified argument should be be
            treated as a return value rather than a "parameter". The
            effect is to declare that the C parameter will be passed
            by reference and that the reference variable need not be
            initialized to any object.  This option assumes that the C
            parameter will have been declared as a "pointer" type, and
            will strip one "*" off of the argument type. Thus, if the
            parameter declaration specifies "int **", the actual value
            returned will have the Dylan type corresponding to "int
            *".</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>input-output-argument:</term>
	  <listitem>
	    <para>indicates that the specified argument should be
            considered both an input argument and that its
            (potentially modified) value should be returned as an
            additional result value. The effect is similar to that of
            "output-argument" except that the reference variable will
            be initialized with the argument value.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>The following (nonsensical) example demonstrates all of
      the options, as they might be applied to the functions:</para>

      <programlisting>
extern struct object *bar(int first, int *second,struct object **third);
extern baz(char first, struct object *second);

define interface
   #include "demo.h";
   function "bar",
      seal: open,
      equate-result: &lt;object&gt;,
      map-result: &lt;bar-object&gt;,
      input-argument: first,   // passed normally
      output-argument: 2,      // nothing passed in, second result value
            // will be &lt;integer&gt;
      input-output-argument: third;   // passed in as second argument, 
            // returned as third result
   function "baz" =&gt; arbitrary-function-name,
      seal: sealed,      // default
      ignore-result: #t,
      equate-argument: {second =&gt; &lt;object&gt;},
      map-argument: {2 =&gt; &lt;baz-object&gt;};
end interface;</programlisting>

    </SECT1>

    <SECT1 ID="mleange-struct-and-union-clauses">
      <title>Struct and Union Clauses</title>

      <para>"Struct clauses" and "union clauses" (referred to
      collectively as "container clauses") are used to specify naming
      in inclusion of class slots in exactly the same way that the
      options in the file clause control the handling of global
      definitions. Like the function clauses described above, they
      consist of the reserved word "struct" or "union", a string which
      gives the full C name of the container declaration, an optional
      renaming, and a list of options. If we have a structure defined
      by</para>

      <programlisting>
typedef struct cons {
   int index;
   struct object *head;
   struct cons *tail;
} cons_cell;</programlisting>

      <para>we could use the following interface definition:</para>

      <programlisting>
define interface
   #include "cons.h";
   struct "struct cons" =&gt; &lt;c-list&gt;,
      superclasses: {&lt;sequence&gt;},
      prefix: "c-list-",
      name-mapper: identity-name-mapping,
      exclude: {"index"};
end interface;</programlisting>

      <para>Valid options for container clauses include: import:,
      prefix:, exclude:, rename:, seal-functions:, read-only:,
      equate:, and map:.These options act like the equivalent options
      which may be specified in a file clause, but they apply to the
      slots of a single "class" rather than to globally defined
      objects. Options specified within a container clause override
      any global defaults that might have been specified in the
      "#include" clause.  Container clauses also permit the
      "superclasses:" option described in <xref
      linkend="melange-class-inheritance">.  Although the recommended
      method for specifying a container type is to use the full C name
      (i.e. "struct foo"), you may also use an alias defined by a
      typedef. Thus, in the above example, you could have specified
      either "struct cons" or "cons_cell", with identical
      results.</para>
    </SECT1>

    <SECT1 ID="melange-pointer-clauses">
      <title>Pointer Clauses</title>

      <para>"Pointer clauses" modify the definitions of pointer
      declarations such as "int *" or "struct foo ***", or vector
      declarations such as "char [256]". Like all such clauses, they
      may be used to specify renamings for the classes. This is
      particularly useful for pointer types since they are not
      automatically assigned user-meaningful names. It also allows
      specification of the "superclasses:" option described in <xref
      linkend="melange-class-inheritance">. A typical use might
      be:</para>

      <programlisting>
define interface
   #include "vec.h";
   pointer "int *" =&gt; &lt;int-vector&gt;,
      superclasses: {&lt;c-vector&gt;};
   pointer "struct person **" =&gt; &lt;people&gt;,
      superclasses: {&lt;c-vector&gt;};
   pointer "char [256]" =&gt; &lt;fixed-string&gt;;
end interface;</programlisting>

      <para>This clause is particularly useful for declaring pointer
      types to be subclasses of &lt;c-vector&gt; so that they can be
      indexed via "element". (Note that this is not necessary for
      vector declarations, since they are automatically declared to be
      &lt;c-vectors&gt;.)</para>
    </SECT1>

    <SECT1 ID="melange-constant-clauses">
      <title>Constant Clauses</title>

      <para>Constant clauses are used to override the values of
      constants specified in header files (i.e. "#define MAXINT
      27"). The "value:" option, which is the only one supported,
      specifies a Dylan literal which will be taken as the value of
      the named constant. A typical use might be:</para>

      <programlisting>
define interface
   #include "const.h";
   constant "MAXINT" => $maximum-fixed-integer,
      value: 9999999;
end interface;</programlisting>

    </SECT1>

    <SECT1 ID="melange-variable-clauses">
      <title>Variable Clauses</title>

      <para>Global variables declared within C header files are
      translated into "getter" functions which retrieve the value of
      the C variables and optional "setter" functions to modify those
      values. In effect, they are treated as slots of a "null
      object"&mdash;the getter function takes no arguments and returns
      the value of the variable, while the setter function takes a
      single value which will be the new value of the variable. Type
      mapping takes place for the arguments and results of these
      functions, just as it would for slot accessors.</para>

      <para>Variable clauses support the following options:</para>

      <variablelist>

	<varlistentry>
	  <term>getter:</term>
	  <listitem>
	    <para>specifies a Dylan variable name which will be used
            to hold the getter function.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>setter:</term>
	  <listitem>
	    <para>specifies either a Dylan variable name which will be
            used to hold the setter function, or #f to indicate that
            there should be no setter function.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>read-only:</term>
	  <listitem>
	    <para>specifies whether the variable should be
            settable. "read-only: #t" is equivalent to "setter:
            #f".</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>seal:</term>
	  <listitem>
	    <para>specifies whether the getter and setter functions
            should be sealed. Possible values are "sealed" or "open",
            and the default is taken from the "seal-functions:" option
            in the "#include" clause (or "sealed" if not specified
            there).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>map:</term>
	  <listitem>
	    <para>specifies the high-level type to which the variable
            should be mapped.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>equate:</term>
	  <listitem>
	    <para>specifies the low-level type to which the raw C
            value should be implicitly converted.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </SECT1>

    <SECT1 ID="melange-low-level-support">
      <title>Low level support facilities</title>
    
      <para>The high level functions for calling C routines or for
      accessing global variables are all built upon a relatively small
      number of built-in primitives which perform specific low-level
      tasks. You should seldom have any need to deal with these
      primitives directly, but they are nonetheless available should
      you need to make use of them.  To use these types and
      operations, you should "use" the module "system" from the
      "Dylan" library.</para>

      <SECT2 ID="melange-predefined-types">
	<title>Predefined types</title>

	<programlisting>
&lt;statically-typed-pointer&gt; [class] </programlisting>

	<para>Unless otherwise specified, C pointers are implicitly
        "equated" to newly created subclasses of
        &lt;statically-typed-pointer&gt;. This class is contains a
        single implicit slot which contains the raw C pointer. Because
        of implementation limitations in Mindy, you may not add any
        extra slots to subclasses of &lt;statically-typed-pointer&gt;,
        nor can such a subclass inherit slots from other classes. You
        may, however, create classes which are subclasses of both
        &lt;statically-typed-pointer&gt; and other (presumably
        abstract) classes which have no slots.</para>

	<para>The "make" method for takes three keywords. The
        "pointer:" keyword tells it to initialize the new variable
        with the given value, which must be a
        &lt;statically-typed-pointer&gt; or an &lt;integer&gt;. If the
        no pointer value is specified, space will be allocated based
        upon the content-size of the specific type and upon the
        "extra-bytes:" and "element-count:" keywords. These keywords,
        which default to "0" and "1" respectively, tell how many
        objects are going to be stored in the memory and how many
        bytes of extra memory (beyond that specified by
        "content-size") should be allocated for each element.</para>

	<programlisting>
&lt;c-vector&gt; [class]</programlisting>

	<para>&lt;C-vector&gt; is a subclass of
        &lt;statically-typed-pointer&gt; which inherits operations
        from &lt;vector&gt;. Because systems often depend upon C's
        lack of bounds checking, the default size for
        &lt;c-vector&gt;s is "#f". However, subclasses of
        &lt;c-vector&gt; may provide a concrete size if desired. Types
        corresponding to declarations such as "char [256]" are
        automatically declared as subclasses of &lt;c-vector&gt;, but
        pointer declarations such as "char *" are not.</para>

	<programlisting>
&lt;c-string&gt; [class] </programlisting>

	<para>&lt;C-string&gt; is a subclass of
        &lt;statically-typed-pointer&gt; which also inherits
        operations from &lt;string&gt;. It is implemented as a C
        pointer to a null-terminated vector of characters, and
        provides a method on forward-iteration-protocol which
        understands this implementation. This class may, therefore, be
        used for manipulating C's native format for "string"s
        (i.e. "char *"). Note that the "null" string is considered to
        be a valid empty string. This is somewhat contrary to the
        semantics of many C operations, but provides a safer model for
        Dylan code.</para>
      
	<para>The "make" method for &lt;c-string&gt;s accepts the
        "size:" and "fill:" keywords.</para>

	<para>There are a few surprising properties of
        &lt;c-strings&gt; which may users should be aware of, both of
        which result from the "null-terminated"
        implementation. Firstly, the "size" of the string is computed
        by counting from the beginning of the string, and is therefore
        not nearly as efficient as you might expect. Secondly, you
        should expect odd results if you try to store
        "as(&lt;character&gt;, 0)" into such a string. Finally, the
        "element" and "element-setter" methods must scan the string in
        order to do bounds checking, and may therefore be fairly
        slow. If you wish to (unsafely) bypass this checking, you must
        use "pointer-value" instead.</para>

	<programlisting>
&lt;c-function&gt; [class] </programlisting>

	<para>&lt;c-function&gt;s, like
        &lt;statically-typed-pointer&gt;s, encapsulate a raw "C"
        pointer. However, &lt;c-function&gt;s also encode information
        about the calling conventions of the function which is
        (presumably) located at the given address. They may,
        therefore, be directly invoked just like any other
        function.</para>

	<programlisting>
&lt;foreign-file&gt; [class] </programlisting>

	<para>The &lt;foreign-file&gt; class is used to store
        information about the contents of a particular object file. It
        is created by "load-object-file", and may be passed as an
        option to "find-c-function" and "find-c-pointer". (All of
        these functions are described below.)</para>
      </SECT2>

      <SECT2 ID="melange-locating-c-objects">
	<title>Locating native C objects</title>

	<para>There are several functions provided which search for C
        functions or variables and return Dylan objects which refer to
        them. Note that Mindy does not have sufficient information to
        determine whether any given C object is a function, and
        therefore it depends upon the user (or, more often, Melange)
        to provide it with correct information.</para>

	<programlisting>
load-object-file(files :: &lt;list&gt;, #key symbols) [function]</programlisting>

	<para>This function (which is presently only works on HPUX
        machines) attempts to dynamically load a given object file
        (i.e. ".o" or ".a") into the current Mindy process and load
        itUs symbol table to allow its contents to be located by
        "find-c-pointer" or "find-c-function". If it successfully
        loads the file, it will return a &lt;foreign-file&gt;
        encapsulating the symbol table information. Otherwise, it will
        return #f.</para>

	<para>If you are not running on an HPUX machine, you will have
        to statically link object files into Mindy, as described in
        Chapter II.</para>

	<programlisting>
find-c-pointer(name :: string, #key file :: &lt;foreign-file) [function] </programlisting>

	<para>This function searches through the symbol table for the
        object file corresponding to the specified file (or for Mindy
        itself) and attempts to locate a symbol with the given
        name. If it finds such a symbol, it converts the corresponding
        address to a &lt;statically-typed-pointer&gt; and returns
        it. Otherwise, it returns #f.</para>

	<programlisting>
find-c-function (name :: &lt;string&gt;, #key file) [function] 

constrain-c-function (fun :: &lt;c-function&gt;, [function] 

specializer :: &lt;list&gt;, rest? :: &lt;boolean&gt;, 

results :: &lt;list&gt;) </programlisting>

	<para>The function "find-c-function" is like "find-c-pointer",
        except that the result is a &lt;c-function&gt; (or #f). The
        resulting function is specialized to "fun(#rest args) ::
        &lt;object&gt;". However, it may be constrained to a different
        set of specializers via "constrain-c-function".  This function
        accepts lists of types for the arguments and for the return
        values, and a boolean value which states whether optional
        arguments are accepted. The result declarations are
        particularly important, since they are used to coerce the raw
        C result value into an appropriate low level Dylan type. The
        possible types are &lt;boolean&gt;, &lt;integer&gt;, or any
        subclass of &lt;statically-typed-pointer&gt;. Note that
        although a list of result types is accepted, only the first
        can be meaningful since C does not support multiple return
        values.</para>

	<note>
	  <para>The functions in this section are likely to change
	  drastically in the near future.</para>
	</note>
      </SECT2>

      <SECT2 ID="melange-pointer-manipulation">
	<title>Pointer manipulation operations</title>

	<para>Each &lt;statically-typed-pointer&gt; encapsulates a
        pointer to some area of memory (i.e. a raw machine
        address). In itself, this does little good, except as an
        arbitrary token. However, Mindy provides a number of primitive
        operations which manipulate the contents of these addresses,
        or do basic comparisons and arithmetic upon the addresses
        themselves.</para>

	<programlisting>
signed-byte-at (ptr :: &lt;statically-typed-pointer&gt;, #key offset) [function] 

unsigned-byte-at (ptr :: &lt;statically-typed-pointer&gt;, #key offset)
[function] 

signed-short-at (ptr :: &lt;statically-typed-pointer&gt;, #key offset) [function] 

unsigned-short-at( ptr :: &lt;statically-typed-pointer&gt;, #key offset)
[function] 

signed-long-at (ptr :: &lt;statically-typed-pointer&gt;, #key offset) [function] 

unsigned-long-at (ptr :: &lt;statically-typed-pointer&gt;, #key offset)
[function] 

pointer-at (ptr :: &lt;statically-typed-pointer&gt;, [function] 

#key offset, class) </programlisting>
	
	<para>These operations return an object which represents the
        value stored at the address corresponding to "ptr". The first
        six operations all return &lt;integer&gt;s -- the different
        versions are required because the same number may be
        represented in a variety of formats (differing in length and
        interpretation of the high-order bit) and because Mindy has no
        way of determining which might be used in a given situation.
        The final operation, "pointer-at", returns a new
        &lt;statically-typed-pointer&gt; encapsulating the address
        referenced by the origninal pointer.  You may use the "class:"
        keyword to specify that the new object should be an instance
        of some particular subclass of
        &lt;statically-typed-pointer&gt;. (Thus, for example
        "pointer-at(foo, class: &lt;bar&gt;)" would be roughly
        equivalent to "as(&lt;bar&gt;, pointer-at(foo))".)</para>

	<para>The offset parameter (if provided) is added to the
        integer corresponding to the machine address before the
        pointer is dereferenced.  This is useful, for example, in
        loading an object from within a C "struct".</para>

	<para>Setter functions are provided corresponding to each of
        the above functions. You can therefore, say</para>

	<programlisting>
signed-short-at(ptr) := 32767;
pointer-at(ptr1) := ptr2;

as(cls == &lt;integer&gt;, ptr :: &lt;statically-typed-pointer&gt;) [G.F. Method] 

as(cls == &lt;statically-typed-pointer&gt;, ptr :: &lt;statically-typed-pointer&gt;) 

[G.F. Method] 

as(cls == &lt;statically-typed-pointer&gt;, int:: &lt;integer&gt;) [G.F. Method] </programlisting>

	<para>Method upon "as" are provided for converting from
        &lt;integer&gt; to any statically typed pointer class and from
        any statically typed pointer class to &lt;integer&gt; or to
        another statically typed pointer class.</para>

	<programlisting>
\+ (ptr :: &lt;statically-typed-pointer&gt;, int :: &lt;integer&gt;) [G.F. Method] 

\- (ptr1 :: &lt;statically-typed-pointer, ptr2 :: &lt;statically-typed-pointer&gt;) 

[G.F. Method] 

\= (ptr1 :: &lt;statically-typed-pointer, ptr2 :: &lt;statically-typed-pointer&gt;) 

[G.F. Method] </programlisting>

	<para>These functions do arithmetic upon the integers corresponding
        to the given pointers. The following code fragment</para>

	<programlisting>
let new-ptr = ptr1 + 3;
let difference = ptr2 + ptr3;
let same? = (ptr2 = ptr3)</programlisting>

	<para>is equivalent to</para>
      
	<programlisting>
let new-ptr = as(ptr1.object-class, as(&lt;integer&gt;, ptr1) + 3);
let difference = as(&lt;integer&gt;, ptr2) - as(&lt;integer&gt;, ptr3);
let same = (as(&lt;integer&gt;, ptr2) = as(&lt;integer&gt;, ptr3));</programlisting>

      </SECT2>
    </SECT1>

    <SECT1 ID="melange-static-linking">
      <title>Static linking mechanisms</title>
    
      <para>Because object file formats vary widely by architecture,
      Mindy does not support dynamic loading of object files or
      automatic symbol table look up for all architectures. In the
      general case, it is necessary to depend upon a less elegant
      technique for explicitly making certain C objects
      available.</para>

      <para>Simple instructions for using this mechanism from within
      Melange are given in <xref
      linkend="melange-loading-and-finding">. This section simply
      provides more information on the underlying mechanism.</para>

      <para>In order to make sure that the desired symbols can be
      located, it is necessary to build an explicit table which maps
      between the symbol's name and its address. This table is
      automatically created by running the "make-init.pl" script [This
      requires you to have PERL installed on your system.] upon a list
      of "interface definition files". This will create two files
      ",extern1.def" and ",extern2.def", which should then be renamed
      to "extern1.def" and "extern2.def" respectively. These files are
      automatically included by "ext-init.c" so that the table will be
      created after Mindy is rebuilt.</para>

      <para>The interface definition files consist of zero or more
      lines of text, each of which should contain the name of one
      object. If the object is a function, it should be immediately
      followed by a set of parentheses. For example, the file which
      defines the memory allocation routines used by Melange's support
      code contains the following four lines:</para>

<programlisting>
free()
malloc()
strcmp()
strlen()
</programlisting>

      <para>The only other step required to make the objects available
      is simply to ensure that the library which contains them is
      linked into Mindy. The easiest way to accomplish all of this is
      to simply modify the Makefile in Mindy's source directory. If
      you add the names of the required libraries to LIBS and the
      names of the interface definition files to EXTERN-INCLUDES, make
      will do the necessary work for you. You should be sure to leave
      "../compat/libcompat.a" or "-lm" in LIBS and "malloc.inc" in
      EXTERN-INCLUDES.</para>
    </SECT1>

    <SECT1 ID="melange-differences-from-creole">
      <title>Differences from Creole</title>
    
      <para>It would be difficult to produce an exhaustive list of the
      differences between Creole and Melange. We can, however, include
      a brief examination of the most important incompatibilities
      between the two systems.</para>

      <itemizedlist>
	<listitem>
	  <para>Creole's "type:" options have been replaced by
          Melange's "equate:" and "map:" options.</para>
	</listitem>
	<listitem>
	  <para>Creole's "access path" options have been replaced by
          "object-file:" and "mindy-include-file:".</para>
	</listitem>
	<listitem>
	  <para>The interface to "import-value" and "export-value" differ
          between the two systems.</para>
	</listitem>
	<listitem>
	  <para>Melange does not inherit type mappings from other
          "define interface" forms.</para>
	</listitem>
	<listitem>
	  <para>Creole does not import definitions from "recursively
          included" header files, even if they are referenced by
          definitions which are imported.</para>
	</listitem>
	<listitem>
	  <para>Creole does not support C vectors or "sub-structures" as
          first class objects.</para>
	</listitem>
	<listitem>
	  <para>Melange does not presently support callbacks,
          "export-temporary-value", "&lt;pascal-string&gt;",
          "with-stack-structure", "with-stack-block", or
          "alien-method".</para>
	</listitem>
	<listitem>
	  <para>Creole will never consider instances of two distinct
          statically typed pointer classes to be "=", even if they
          refer to the same address.</para>
	</listitem>
      </itemizedlist>
    </SECT1>

    <SECT1 ID="melange-known-limitations">
      <title>Known limitations</title>
    
      <para>Although mostly complete, the current implementation of
      Melange is missing a few elements which might be required for
      some applications. The following capabilites probably should be
      present, but are not yet supported:</para>

      <itemizedlist>
	<listitem>
	  <para>Floating point numbers.</para>
	</listitem>
	<listitem>
	  <para>Callbacks.</para>
	</listitem>
	<listitem>
	  <para>Function types. (It is, however, possible to import a
          function as a simple &lt;statically-typed-pointer&gt; and
          then manipulate it like any other object.)</para>
	</listitem>
      </itemizedlist>
    </SECT1>

    <SECT1 ID="melange-proposed-modifications">
      <title>Proposed modifications</title>
    
      <para>Although Melange seems to be fairly useful in its present
      form, we are currently considering a number of ways in which it
      may be made more useful. This section contains a brief
      discussion of several potential changes which may be implemented
      in the future.</para>

      <SECT2 ID="melange-enumeration-clauses">
	<title>Enumeration clauses</title>

	<para>At present, there is no way to modify the default
        handling of a C enumeration declaration. It is clear that you
        might wish a mechanism to specify several different explicit
        options: prefixes for the enumeration constants;
        respecification of constant values; and, of course, explicit
        "import:" and "exclude:" options.</para>
      </SECT2>

      <SECT2 ID="melange-map-equate-inheritance">
	<title>Inheritance of "map" and "equate" options</title>

	<para>There are some cases in which a set of types imported
        within one interface definition might be used extensively
        within another. In the present implementation, the two
        interface definitions would be handled independently and
        equivalences between types would not be recognized in the
        abscence of explicit "equate:" options.</para>

	<para>One proposed solution would involve the ability to
        explicitly "use" one interface definition within another. This
        would result in all identically named types being implicitly
        equated and all top-level "map:" options being inherited. The
        "use" clause could support roughly the same syntax as the
        "use" clauses in library and module definitions.In order to
        make this work, it would be necessary to assign arbitrary
        names to interface definitions. This would have the added
        benefit of making them more consistent with other standard
        Dylan definition forms.</para>

	<para>If this change were implemented, a typical interface
        definition might look something like the following:</para>

	<programlisting>
define interface date
   #include "date.h";
   use time, import: {"struct time"};
end interface date;</programlisting>

	<para>A less ambitious version might remain compatible with
        the current syntax by replacing the interface name with an
        "interface-name" option, which would default to the root of
        the file name. Thus,</para>
	
	<programlisting>
define interface
   #include "date.h",
      interface-name: "date";
end interface;</programlisting>

	<para>would yield the same effect as the previous example.</para>
      </SECT2>

      <SECT2 ID="melange-merging-map-equate">
	<title>Remerging of the "equate:" and "map:" options</title>

	<para>It has been pointed out that the current method of
        specifying low-level and high-level mappings, while
        sufficiently expressive, is somewhat verbose and confusing. It
        would therefore be good to find an alternative
        notation.</para>

	<para>It has been suggested that definitions like:</para>
      
	<programlisting>
define interface
   #include "dirent.h",
      equate: {"char *" =&gt; &lt;c-string&gt;},
      map: {"char *" =&gt; &lt;byte-string&gt;};
end interface;</programlisting>

	<para>might be replaced by something like:</para>

	<programlisting>
define interface
   #include "dirent.h",
      equate-and-map: {"char *" =&gt; &lt;c-string&gt; =&gt; &lt;byte-string&gt;};
end interface;</programlisting>

	<para>or</para>

	<programlisting>
define interface
   #include "dirent.h";
   transform "char *",
      low-level: &lt;c-string&gt;,
      high-level: &lt;byte-string&gt;;
end interface;</programlisting>

      </SECT2>
    </SECT1>
  </CHAPTER>
</BOOK>

